C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO_T
OBJECT MODULE PLACED IN servo_t.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo_t.c DB OE BR

line level    source

   1          
   2          #include "c8051f120.h"
   3          #include "init_t.h"
   4          #include <intrins.h>
   5          #include <ctype.h>
   6          #include <stdio.h>
   7          #include <stdlib.h>
   8          #include <math.h> 
   9          //system
  10          #define SYSCLK      24810000  // (24856840L * 1 / 1) 
  11          #define FREQT0 580 //1183 //Hz
  12          #define FREQPCA 15.799 //Hz
  13          //сигнальные
  14          sbit P3_3 = P3^3;
  15          sbit LED = P1^6;  // Ўим 1
  16          sbit LED2 = P2^6; // Ўим 2
  17          sbit BUTTON = P3^7;
  18          
  19          //ADC
  20          sfr16 ADC0     = 0xbe;   // ADC0 data
  21          bit DavlFlag = 0;
  22          xdata long Result;                    
  23          xdata unsigned int_dec = 256;    
  24          xdata long accumulator = 0L;       
  25          
  26          //LIR
  27          sbit LIR_DATA = P2^0; //P2^2;
  28          sbit LIR_SCK = P2^1;
  29          xdata unsigned int LData, THTL_mem=0;
  30          xdata float A = 0, A_pr = 0, A_zad = 0, V = 0, V_pr = 0, V_zad = 0, V_zad_pr = 0,  Vmax = 400, u = 0, u_za
             -d = 0, Umax = 36000;
  31          
  32          #define UgolMaxV 4.
  33          
  34          //Veter
  35          bit VeterFlag = 0;
  36          sbit WSpeed = P1^1;
  37          sbit WAngle = P1^3;
  38          
  39          xdata float Vspeed=0, Angle=0;
  40          xdata unsigned int RTC=0, RTCV=0, RTCA=0;
  41          xdata float TV=0,TA=0;
  42          
  43          //UART0
  44          #define NBFM            50
  45          xdata unsigned char BuferFromModem [NBFM]; 
  46          xdata unsigned char wBFM, rBFM, marBFM;
  47          xdata unsigned int u0timer;
  48          
  49          #define SIZE_BUFFER0            50
  50          xdata char BufferInModem[SIZE_BUFFER0]; 
  51          xdata int r0, rk;
  52          bit flTransmiter;       
  53          
  54          xdata unsigned char startbit45, startbit46;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 2   

  55          xdata unsigned int P_signal=0;
  56          xdata long Lat_Bort=0, Lon_Bort=0, LonFly=0, LatFly=0;
  57          xdata float dy, dx, pi=3.14;
  58          bit flNewAngle;
  59          
  60          //GPS
  61          
  62          #define NS      75
  63          xdata char mess [NS], r, w, mar;                
  64          bit flNewGPS;
  65          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  66          xdata unsigned long LatGnd=0, LonGnd=0;
  67          
  68          
  69          #define cT              0x885e //0xA04B
  70          #define ctau    0x2FDA //0X17ED
  71          
  72          //------------------------------------------------------------------------------
  73          void OutModem1(unsigned char Data, char i)
  74          {
  75   1              BufferInModem[i] = Data | 0x80;
  76   1      }
  77          
  78          //------------------------------------------------------------------------------
  79          void OutModem2(unsigned int Data, char i)
  80          {
  81   1              BufferInModem[i] = (Data & 0x007f)| 0x80;
  82   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  83   1      }
  84          
  85          //------------------------------------------------------------------------------
  86          void OutModem4(unsigned long int Data, char i)
  87          {
  88   1              BufferInModem[i] = (Data & 0x0000007f)| 0x80;
  89   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
  90   1              BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
  91   1         BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
  92   1      }
  93          //------------------------------------------------------------------------------------
  94          void main(void)
  95          {
  96   1      //ADC
  97   1              xdata long Pressure = 0;
  98   1              xdata float PressureFl = 0.0;
  99   1      
 100   1      //GPS
 101   1         bit ValidGPS, flPoint;       
 102   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 103   1              xdata unsigned long temp_koord;
 104   1              xdata unsigned int i;
 105   1      
 106   1         xdata unsigned char chtmp;
 107   1              xdata int tmp;
 108   1      
 109   1              EA = 0;
 110   1              WDTCN     = 0xDE;       //выкл собаки
 111   1         WDTCN     = 0xAD;
 112   1              EA= 1;   
 113   1              
 114   1              LED=0;
 115   1              LED2=0;
 116   1      
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 3   

 117   1              Port_IO_Init();
 118   1              Oscillator_Init();   
 119   1              Interrupts_Init(); 
 120   1              Timer_Init();
 121   1              UART0_Init();
 122   1         UART1_Init();
 123   1              PCA_Init();
 124   1         ADC_Init();
 125   1      
 126   1              flNewGPS = 0;
 127   1              u0timer=0;
 128   1      
 129   1              while(1)
 130   1              {
 131   2      //ADC
 132   2                      EIP2 |= 0x02;
 133   2                      if(DavlFlag==1)
 134   2                      {
 135   3                              EA = 0; 
 136   3                              Pressure =  Result * 2430 / 4095;
 137   3                              EA = 1; 
 138   3                              DavlFlag = 0;
 139   3                              PressureFl = PressureFl + (Pressure - PressureFl)*0.5;
 140   3                      }
 141   2      
 142   2                      //GPS---------------------------------------------------------------------------
 143   2                      if(flNewGPS == 1)       
 144   2                      {
 145   3                              if (r < w+mar*NS) 
 146   3                              {
 147   4                                      if(mess[r] == '$')
 148   4                                      {
 149   5                      nLetter = 0;
 150   5                                      }
 151   4                      else if ((nLetter == 0) && (mess[r] == 'G'))
 152   4                      nLetter++;
 153   4                      else if ((nLetter == 1) && (mess[r] == 'P'))
 154   4                      nLetter++;
 155   4                      else if ((nLetter == 2) && (mess[r] == 'R'))
 156   4                      nLetter++;
 157   4                       else if ((nLetter == 3) && (mess[r] == 'M'))
 158   4                       nLetter++;
 159   4                 else if ((nLetter == 4) && (mess[r] == 'C'))
 160   4                      {
 161   5                      nLetter++;
 162   5                                              i_comma = 0;
 163   5                                              ValidGPS = 0;
 164   5                 } 
 165   4                              else if(mess[r] == ',')
 166   4                                      {
 167   5                                              i_comma++;
 168   5                                              i = 0;
 169   5                                              flPoint = 0;
 170   5                                      }
 171   4                              else if(i_comma == 2)
 172   4                                      {
 173   5                                              if(mess[r] == 'A') 
 174   5                                                      ValidGPS = 1;
 175   5                                              else
 176   5                                              {
 177   6                                                      ValidGPS = 0;
 178   6              //                                      flNoKoord = 1;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 4   

 179   6              //                                      liTimer_tick_GPS = liTimer_tick;
 180   6                                              }
 181   5                                      }
 182   4                      else if (ValidGPS)
 183   4                                      {
 184   5                                              if (i_comma == 3)                                       //Latitude
 185   5                                              {
 186   6                                                      if(mess[r] == '.')
 187   6                                                      {
 188   7                                                              flPoint = 1;
 189   7                                                              i = 0;
 190   7                                                      }
 191   6                                                      else if (flPoint == 0)                                          //celaya chast
 192   6                                                      {
 193   7                                                              tmpGPS[i++] = mess[r];
 194   7                                                              if(i == 2)
 195   7                                                              {
 196   8                                              tmpGPS[i] = 0;
 197   8                                                                      temp_koord = atoi(tmpGPS);
 198   8                                              temp_koord = 60UL*10000*temp_koord;
 199   8                                                              }       
 200   7                                                              else if(i == 4)
 201   7                                                              {
 202   8                                                                      tmpGPS[0] = tmpGPS[1] = '0';
 203   8                                              tmpGPS[i] = 0;
 204   8                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 205   8                                                              }       
 206   7                                                      }
 207   6                                                      else                                                                                            //drobnaya chast
 208   6                                                      {
 209   7                                                              tmpGPS[i++] = mess[r];
 210   7                                      tmpGPS[i] = 0;
 211   7                                                      }
 212   6                                              }
 213   5                                              else if (i_comma == 4)
 214   5                                              {
 215   6                                      temp_koord = temp_koord+atoi(tmpGPS);
 216   6      //-----------
 217   6      //lLatGnd = 55UL*60*10000+50UL*10000+8680;
 218   6      //--------
 219   6                                                      if (mess[r] == 'S')                                             //znak Latitude
 220   6                                                              LatGnd = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 221   6                                                      else              
 222   6                                                              LatGnd = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 223   6                                              }
 224   5                                              else if (i_comma == 5)                          //Longitude
 225   5                                              {
 226   6                                                      if(mess[r] == '.')
 227   6                                                      {
 228   7                                                              flPoint = 1;
 229   7                                                              i = 0;
 230   7                                                      }
 231   6                                                      else if (flPoint == 0)                                          //celaya chast
 232   6                                                      {
 233   7                                                              tmpGPS[i++] = mess[r];
 234   7                                                              if(i == 3)
 235   7                                                              {
 236   8                                              tmpGPS[i] = 0;
 237   8                                              temp_koord = atoi(tmpGPS);
 238   8                                              temp_koord = 60UL*10000*temp_koord;
 239   8                                                              }       
 240   7                                                              else if(i == 5)
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 5   

 241   7                                                              {
 242   8                                                                      tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 243   8                                              tmpGPS[i] = 0;
 244   8                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 245   8                                                              }       
 246   7                                                      }
 247   6                                                      else                                                                                            //drobnaya chast
 248   6                                                      {
 249   7                                                              tmpGPS[i++] = mess[r];
 250   7                                      tmpGPS[i] = 0;
 251   7                                                      }
 252   6                                              }
 253   5                                              else if (i_comma == 6)
 254   5                                              {
 255   6                                      temp_koord = temp_koord+atoi(tmpGPS);
 256   6      //----------------
 257   6      //lLonGnd = 49UL*60*10000+6UL*10000+3760;
 258   6      //----------------
 259   6                                                      if (mess[r] == 'W')                                             //znak Longitude
 260   6                                                              LonGnd = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 261   6                                                      else       
 262   6                                                              LonGnd = temp_koord+108000000UL;                //180UL*60*10000;
 263   6                                              }
 264   5                                              else if (i_comma == 7)                                                  //skorost v uzlah
 265   5                                              {
 266   6                                                      if(mess[r] == '.')
 267   6                                                      {
 268   7                                                              flPoint = 1;
 269   7                                      Vz = 1.852*atoi(tmpGPS)/3.6;            //preobrazovat iz uzlov v m/s
 270   7      //---------
 271   7      //Vz = 20;
 272   7      //-----------
 273   7                                                      }
 274   6                                                      else if(flPoint == 0)
 275   6                                                      {
 276   7                                                              tmpGPS[i++] = mess[r];
 277   7                                      tmpGPS[i] = 0;
 278   7                                                      }
 279   6                      }
 280   5                                              else if (i_comma == 8)                                                  //kurs v gradusah
 281   5                                              {
 282   6                                                      if(mess[r] == '.')
 283   6                                                      {
 284   7                                                              flPoint = 1;
 285   7                                      koors = atoi(tmpGPS);
 286   7                              if (koors < 0)
 287   7                              koors = 360+koors;
 288   7                                                              flNoKoord = 0;
 289   7                                                              flNewGPS = 1;
 290   7                                                              liTimer_tick_GPS = liTimer_tick;        
 291   7              //                          OutModem20();
 292   7      //-----------                                              
 293   7      //koors = 30;
 294   7      //-----------
 295   7                                                      }
 296   6                                                      else if(flPoint == 0)
 297   6                                                      {
 298   7                                                              tmpGPS[i++] = mess[r];
 299   7                                      tmpGPS[i] = 0;
 300   7                                                      }
 301   6                          }
 302   5                                      }
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 6   

 303   4                                      r++;
 304   4                              if(r >= NS)
 305   4                                      {
 306   5                              r = 0;
 307   5                                              mar = 0;        
 308   5                                      }      
 309   4                              }
 310   3                              flNewGPS = 0;
 311   3                      }
 312   2      
 313   2                      //---------------------------------------------------------------------
 314   2      
 315   2                      if(flTransmiter == 0 && (u0timer > 2*FREQPCA))
 316   2                      {
 317   3                              u0timer = 0;
 318   3      
 319   3                              if(flNewAngle==1)
 320   3                              {
 321   4                                      flNewAngle=0;
 322   4                                      if(wBFM > 10)
 323   4                                      {
 324   5                                              startbit45 = 0;
 325   5                                              while(startbit45<(wBFM-10))
 326   5                                              {
 327   6                                                      chtmp = 0;
 328   6                                                      for (i = startbit45; i < (11+startbit45); i++ )
 329   6                                                      chtmp = chtmp ^ BuferFromModem[i];
 330   6                                                      chtmp = chtmp | 0x80;
 331   6                                                      if(BuferFromModem[11+startbit45]!= 0x80 && chtmp == BuferFromModem[11+startbit45] && BuferFromModem[
             -startbit45] == (45 | 0x40))
 332   6                                                      {
 333   7                                                              Lat_Bort = BuferFromModem[1+startbit45]&~0x80;
 334   7                                              Lat_Bort |= ((long)(BuferFromModem[2+startbit45]&~0x80)<<7);
 335   7                                      Lat_Bort |= ((long)(BuferFromModem[3+startbit45]&~0x80)<<14);
 336   7                                              Lat_Bort |= ((long)(BuferFromModem[4+startbit45]&~0x80)<<21);
 337   7                                                              Lon_Bort = BuferFromModem[5+startbit45]&~0x80;
 338   7                                              Lon_Bort |= ((long)(BuferFromModem[6+startbit45]&~0x80)<<7);
 339   7                                      Lon_Bort |= ((long)(BuferFromModem[7+startbit45]&~0x80)<<14);
 340   7                                              Lon_Bort |= ((long)(BuferFromModem[8+startbit45]&~0x80)<<21);
 341   7                                                              P_signal =      BuferFromModem[9 + startbit45]&~0x80;
 342   7                                      P_signal |= ((int)(BuferFromModem[10 + startbit45]&~0x80)<<7);
 343   7                                                                              
 344   7                                                              dy = LonGnd;
 345   7                                                              dy = 0.1856*(dy - LonFly);
 346   7                                                      dx = LatGnd;
 347   7                                                              dx = 0.1856*(dx - LatFly);
 348   7                                                              if(dx>0 && dy>=0)
 349   7                                                              {
 350   8                                                                      tmp = atan(dy/dx);
 351   8                                                              }
 352   7                                                              else if(dx>0 && dy<0)
 353   7                                                              {
 354   8                                                                      tmp = atan(dy/dx)+2*pi;
 355   8                                                              }
 356   7                                                              else if(dx<0)
 357   7                                                              {
 358   8                                                                      tmp = atan(dy/dx)+pi;
 359   8                                                              }
 360   7                                                              else if(dx==0 && dy>0)
 361   7                                                              {
 362   8                                                                      tmp = pi/2;
 363   8                                                              }
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 7   

 364   7                                                              else if(dx==0 && dy<0)
 365   7                                                              {
 366   8                                                                      tmp= 3*pi/2;
 367   8                                                              }
 368   7                                                              else if(dx==0 && dy==0)
 369   7                                                              {
 370   8                                                                      tmp =0;
 371   8                                                              }       
 372   7                                                              
 373   7                                                              tmp = tmp / pi * 180.;
 374   7                                                              if(tmp<=360 && tmp>=0)
 375   7                                                              {
 376   8                                                                      A_zad = tmp;
 377   8                                                      }
 378   7                                                      }
 379   6                                                      startbit45++;
 380   6                                              }
 381   5                                      }
 382   4                                      
 383   4                                      if(wBFM > 2)
 384   4                                      {                       
 385   5                                              startbit46 = 0;
 386   5                                              while(startbit46<(wBFM-2))
 387   5                                              {
 388   6                                                      chtmp = 0;
 389   6                                                      for (i = startbit46; i < (3+startbit46); i++ )
 390   6                                                      chtmp = chtmp ^ BuferFromModem[i];
 391   6                                                      chtmp = chtmp | 0x80;
 392   6                                                      if(BuferFromModem[3+startbit46] != 0x80 && chtmp == BuferFromModem[3+startbit46] && BuferFromModem[s
             -tartbit46] == (46 | 0x40))
 393   6                                                      {
 394   7                                                              tmp = BuferFromModem[1+startbit46]&~0x80;
 395   7                                              tmp |= ((int)(BuferFromModem[2+startbit46]&~0x80)<<7);
 396   7                                                              if(tmp<=360 && tmp>=0)
 397   7                                                              {
 398   8                                                                      A_zad = tmp;
 399   8                                                      }
 400   7                                                              
 401   7                                                      }
 402   6                                                      startbit46++;
 403   6                                              }
 404   5                                              wBFM = 0;
 405   5                                      }
 406   4                              }
 407   3              
 408   3                              BufferInModem[0] = 0x40 | 40;           
 409   3                              if(ValidGPS)
 410   3                         {
 411   4                                      OutModem4(LatGnd, 1);
 412   4                                      OutModem4(LonGnd, 5);
 413   4                              }
 414   3                              else
 415   3                      {
 416   4                              i=1;
 417   4                                      while(i<9)
 418   4                                      {
 419   5                                              if(i==4)
 420   5                                                      OutModem1(0xff, i++);
 421   5                                              else
 422   5                                                      OutModem1(0x80, i++);
 423   5                                      }
 424   4               }
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 8   

 425   3                              OutModem2((int)Angle, 9);
 426   3                              OutModem2((int)Vspeed, 11);
 427   3                              OutModem2((int)PressureFl, 13);
 428   3                      BufferInModem[15] = 0;
 429   3      
 430   3                              for (i = 0; i < 15; i++ )
 431   3                              BufferInModem[15] = BufferInModem[15] ^ BufferInModem[i];
 432   3                              BufferInModem[15] = 0x80 |      BufferInModem[15];
 433   3      
 434   3                              BufferInModem[16] = 0x40 | 41;
 435   3                              OutModem2((int)A, 17);
 436   3                      BufferInModem[19] = BufferInModem[16] ^ BufferInModem[17] ^ BufferInModem[18] | 0x80;
 437   3                              r0 = 0;
 438   3                              rk = 20;
 439   3                              
 440   3                              flTransmiter = 1;
 441   3                              
 442   3                              SFRPAGE = 0x00;
 443   3                              TI0 = 1;
 444   3                      }
 445   2              }
 446   1      }
 447          //------------------------------------------------------------------------------------
 448          void INT0 (void) interrupt 0 //skorost vetra
 449          {
 450   1              EX0 =   0;
 451   1              RTCV = RTC;
 452   1              return;
 453   1      }
 454          
 455          //------------------------------------------------------------------------------------
 456          void TIMER_ISR0 (void) interrupt 1
 457          {
 458   1              xdata float tmp;
 459   1              static xdata  unsigned int shim;
 460   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 461   1              static xdata char flShim = 0;
 462   1              SFRPAGE = TIMER01_PAGE;
 463   1      
 464   1              if(flShim == 0)
 465   1              {       
 466   2                      flShim = 1;
 467   2      
 468   2                      LData = 0;
 469   2                      EA = 0; //опрос Ћ»–
 470   2              
 471   2                      LIR_SCK = 1;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 472   2                      LIR_SCK = 0;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 473   2                              
 474   2                      LIR_SCK = 1;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 475   2                      LIR_SCK = 0;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++; 
 476   2                      LData = LData | LIR_DATA;       
 477   2      
 478   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 479   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 480   2                      LData = (LData << 1) | LIR_DATA;        
 481   2              
 482   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 483   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 484   2                      LData = (LData << 1) | LIR_DATA;        
 485   2      
 486   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 9   

 487   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 488   2                      LData = (LData << 1) | LIR_DATA;        
 489   2              
 490   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 491   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 492   2                      LData = (LData << 1) | LIR_DATA;        
 493   2      
 494   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 495   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 496   2                      LData = (LData << 1) | LIR_DATA;        
 497   2      
 498   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 499   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 500   2                      LData = (LData << 1) | LIR_DATA;        
 501   2      
 502   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 503   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 504   2                      LData = (LData << 1) | LIR_DATA;        
 505   2      
 506   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 507   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 508   2                      LData = (LData << 1) | LIR_DATA;        
 509   2      
 510   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 511   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 512   2                      LData = (LData << 1) | LIR_DATA;        
 513   2      
 514   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 515   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 516   2                      LData = (LData << 1) | LIR_DATA;        
 517   2      
 518   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 519   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 520   2                      LData = (LData << 1) | LIR_DATA;
 521   2      
 522   2                      LIR_SCK = 1; 
 523   2                      EA = 1;
 524   2              
 525   2                      //управление антеной------------------------------------------------------------------------
 526   2                      tmp = 360.0/4095.0*LData;
 527   2                      if ((A > 270) && (tmp < 90))
 528   2                      {
 529   3                              A = A+(tmp+360-A);
 530   3                              if (A > 360)
 531   3                                      A = A-360;
 532   3                      }
 533   2                      else if ((tmp > 270) && (A < 90))
 534   2                      {
 535   3                              A = A+(tmp-A-360);
 536   3                              if (A < 0)
 537   3                                      A = A+360;
 538   3                      }
 539   2                      else
 540   2                              A = A+(tmp-A);
 541   2      
 542   2                      if ((A_pr > 270) && (A < 90))
 543   2                              V = V+((A+360-A_pr)*FREQT0-V); 
 544   2                      else if ((A > 270) && (A_pr < 90))
 545   2                              V = V+((A-A_pr-360)*FREQT0-V); 
 546   2                      else
 547   2                              V = V+((A-A_pr)*FREQT0-V); 
 548   2                      A_pr = A;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 10  

 549   2      
 550   2                      u = u+((V-V_pr)*FREQT0-u);
 551   2                      V_pr = V;
 552   2              
 553   2                      V_zad = A_zad-A;
 554   2                      while (V_zad > 180)
 555   2                      V_zad -= 360;
 556   2                      while (V_zad < -180)
 557   2                      V_zad += 360;
 558   2                      
 559   2                      V_zad = (Vmax/UgolMaxV)*V_zad;
 560   2                      if(V_zad>Vmax)
 561   2                              V_zad=Vmax;
 562   2                      else if(V_zad<-Vmax)
 563   2                              V_zad=-Vmax;
 564   2      
 565   2                      u_zad = u_zad+((V_zad-V_zad_pr)*FREQT0-u_zad);
 566   2                      V_zad_pr = V_zad;
 567   2                      if(u_zad>Umax)
 568   2                              u_zad=Umax;
 569   2                      else if(u_zad<-Umax)
 570   2                              u_zad=-Umax;            
 571   2      
 572   2                      tmp = A_zad-A;
 573   2                      while (tmp > 180)
 574   2                      tmp -= 360;
 575   2                      while (tmp < -180)
 576   2                      tmp += 360;
 577   2                      
 578   2                      if(fabs(tmp)<(UgolMaxV))
 579   2                              tmp = (u_zad-u)/Umax*ctau + (V_zad-V)/Vmax*ctau;
 580   2                      else
 581   2                              tmp = (V_zad-V)/Vmax*ctau;
 582   2      
 583   2                      if (tmp > (ctau)) 
 584   2                              tmp = ctau;
 585   2                      else if (tmp < -(ctau)) 
 586   2                              tmp = -(ctau);
 587   2      
 588   2                      if (tmp > 512)
 589   2                      {
 590   3                              shim = 0xffff-tmp;
 591   3                      LED2 = 0;
 592   3                              LED = 1;
 593   3                              THTL_mem = TH0;
 594   3                              THTL_mem = ((THTL_mem << 8) & 0x00ff) + TL0;
 595   3                              TH0 = (shim & 0xff00) >> 8;
 596   3                         TL0 = shim & 0x00ff;
 597   3                              
 598   3                              shim = 0xffff-0x3fff*fabs(tmp)/(float)ctau;
 599   3                              PCA0CPH0  = 0xFF;
 600   3                              PCA0CPL0  = 0xFF;
 601   3                              PCA0CPH1  = (shim & 0xff00) >> 8;
 602   3                      //PCA0CPL1  = shim & 0x00ff;
 603   3                      }
 604   2                      else if(tmp < -512)
 605   2                      {
 606   3                              shim = 0xffff+tmp;
 607   3                         LED = 0;
 608   3                              LED2 = 1;
 609   3                              THTL_mem = TH0;
 610   3                              THTL_mem = ((THTL_mem << 8) & 0x00ff) + TL0;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 11  

 611   3                              TH0 = (shim & 0xff00) >> 8;
 612   3                         TL0 = shim & 0x00ff;
 613   3                              
 614   3                              shim = 0xffff-0x3fff*fabs(tmp)/(float)ctau;
 615   3                              PCA0CPH1  = 0xff;       
 616   3                              PCA0CPL1         = 0xff;
 617   3                              PCA0CPH0  = (shim & 0xff00) >> 8;
 618   3                              //PCA0CPL0  = shim & 0x00ff;
 619   3                      }
 620   2                      else
 621   2                      {
 622   3                      shim = 0xffff - ctau;
 623   3                         LED = 0;
 624   3                              LED2 = 0;
 625   3                              TH0 = (shim & 0xff00) >> 8;
 626   3                         TL0 = shim & 0x00ff;
 627   3                              
 628   3                              PCA0CPH0  = 0xFF;
 629   3                      PCA0CPH1  = 0xFF;
 630   3                      }
 631   2              //      P3_3=0;
 632   2              }
 633   1              else
 634   1              {
 635   2                      flShim = 0;
 636   2                      LED = 0;
 637   2                      LED2 = 0;
 638   2                      
 639   2                      if((THTL_mem + (0xffff-shim))<(0xffff-cT))
 640   2                      {
 641   3                              shim = cT + THTL_mem + (0xffff-shim);
 642   3                              TH0 = (shim & 0xff00) >> 8;
 643   3                              TL0 = shim & 0x00ff;
 644   3                      }
 645   2                      else
 646   2                      {
 647   3                              shim = 0xffff; 
 648   3                              TH0 = (shim & 0xff00) >> 8;
 649   3                              TL0 = shim & 0x00ff;
 650   3                      }
 651   2              }
 652   1              SFRPAGE = SFRPAGE_SAVE;
 653   1              return;
 654   1      }
 655          
 656          //------------------------------------------------------------------------------------
 657          void INT1 (void) interrupt 2 //napravl vetra
 658          {
 659   1              EX1=0;
 660   1              RTCA = RTC;
 661   1              return;
 662   1      }
 663          
 664          //------------------------------------------------------------------------------------
 665          void COM_UART0_isr(void) interrupt 4
 666          {
 667   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 668   1              SFRPAGE = UART0_PAGE;
 669   1              
 670   1              if (RI0)
 671   1              {
 672   2                      flNewAngle=1;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 12  

 673   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 674   2                      if(wBFM >= NBFM)
 675   2                      {
 676   3                      wBFM = 0;
 677   3                              marBFM = 1;
 678   3                      }
 679   2                      RI0 = 0;
 680   2              }
 681   1              if (TI0)
 682   1              {
 683   2                      if(r0 < rk)
 684   2                      {
 685   3                              SBUF0 = BufferInModem[r0++];
 686   3                      }
 687   2                      else
 688   2                      {
 689   3                              flTransmiter = 0;
 690   3                      }
 691   2                      TI0 = 0;
 692   2              }
 693   1              
 694   1              SFRPAGE = SFRPAGE_SAVE;
 695   1              return;
 696   1      }
 697          
 698          //-------------------------------------------------------------------
 699          
 700          void PCA_isr (void)interrupt 9 
 701          {
 702   1      //FREQPCA 15.799 Hz
 703   1              xdata float tmp_a;
 704   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 705   1              SFRPAGE = PCA0_PAGE;
 706   1              CF = 0;                                                                                 //—брос флага прерывани€ шимогенератора
 707   1              RTC++;
 708   1              u0timer++;
 709   1      
 710   1              if(WSpeed != 0)
 711   1                      EX0 = 1;
 712   1      
 713   1              if(WAngle != 0)
 714   1                      EX1 = 1;
 715   1      
 716   1              if(RTC<RTCV)
 717   1                      TV = TV + ((0xffff - RTCV + RTC) - TV)/FREQPCA;
 718   1              else if(RTC>RTCV)
 719   1                      TV = TV + ((RTC - RTCV) - TV)/FREQPCA;          
 720   1      
 721   1              if(RTC<RTCA)
 722   1                      TA = TA + ((0xffff - RTCA + RTC) - TA)/FREQPCA;
 723   1              else 
 724   1                      TA = TA + ((RTC - RTCA) - TA)/FREQPCA;
 725   1      
 726   1              
 727   1              tmp_a = 0;
 728   1              if(TV > 0)
 729   1                      tmp_a = TA/TV;
 730   1              if(tmp_a <= 1 && tmp_a >= 0)
 731   1                      Angle = Angle + (360. - (360.*tmp_a) - Angle)/FREQPCA*0.8;
 732   1      
 733   1              
 734   1              Vspeed = Vspeed + (((float)FREQPCA/((float)TV*0.75))-Vspeed)/FREQPCA;
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 13  

 735   1      
 736   1      //      P3_3=!P3_3;
 737   1              SFRPAGE = SFRPAGE_SAVE;
 738   1              return;
 739   1      }
 740          //-------------------------------------------------------------------
 741          
 742          void ADC0_ISR (void) interrupt 15
 743          {
 744   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 745   1              SFRPAGE = ADC0_PAGE;
 746   1              AD0INT = 0;                         // Clear ADC conversion complete
 747   1                                             // indicator
 748   1         accumulator += ADC0;                // Read ADC value and add to running
 749   1                                             // total
 750   1         int_dec--;                          // Update decimation counter
 751   1      
 752   1         if (int_dec == 0)                   // If zero, then post result
 753   1         {
 754   2                      int_dec = 256;                          // Reset counter
 755   2            Result = accumulator >> 8;
 756   2            accumulator = 0L;                // Reset accumulator
 757   2                      DavlFlag = 1;
 758   2                      EIP2  &= ~0x02;
 759   2         }
 760   1              SFRPAGE = SFRPAGE_SAVE;
 761   1              return;
 762   1      }
 763          //-------------------------------------------------------------------
 764          void GPS_UART1_isr(void) interrupt 20
 765          {
 766   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 767   1              SFRPAGE = UART1_PAGE;
 768   1              if (RI1)
 769   1              {
 770   2                      flNewGPS = 1;
 771   2                      mess [w++] = SBUF1;  // read character
 772   2                      if(w >= NS)
 773   2                      {
 774   3                      w = 0;
 775   3                              mar = 1;
 776   3                      }
 777   2                      RI1 = 0;
 778   2              }
 779   1              if (TI1)
 780   1              {
 781   2                              
 782   2              }
 783   1              SFRPAGE = SFRPAGE_SAVE;
 784   1              return;
 785   1      }
 786          
 787          
 788          //#endif
 789          
 790          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11288    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    320      38
C51 COMPILER V9.00   SERVO_T                                                               11/28/2012 11:44:24 PAGE 14  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
