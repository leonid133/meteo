C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO_T3
OBJECT MODULE PLACED IN servo_t3.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo_t3.c DB OE BR

line level    source

   1          
   2          #include "c8051f120.h"
   3          #include "init_t.h"
   4          //#include "comport.h"
   5          #include <intrins.h>
   6          #include <ctype.h>
   7          #include <stdio.h>
   8          #include <stdlib.h>
   9          #include <math.h> 
  10          //system
  11          #define SYSCLK      24883200  // (24856840L * 1 / 1) 
  12          #define FREQT0 1//1183 //Hz
  13          
  14          //сигнальные
  15          sbit P3_3 = P3^3;
  16          sbit LED = P1^6;
  17          sbit LED2 = P2^7;
  18          sbit BUTTON = P3^7;
  19          xdata unsigned char InitFlag;
  20          xdata unsigned int iter;
  21          
  22          //ADC
  23          sfr16 ADC0     = 0xbe;   // ADC0 data
  24          bit DavlFlag = 0;
  25          xdata long Result;                    
  26          xdata unsigned int_dec = 256;    
  27          xdata long accumulator = 0L;       
  28          
  29          //LIR
  30          sbit LIR_DATA = P2^0; //P2^2;
  31          sbit LIR_SCK = P2^1;
  32          xdata unsigned int LData, THTL_mem=0;
  33          xdata float A = 0, A_pr = 0, A_zad = 0, A_zad_pr = 0, V = 0, V_pr = 0, V_zad = 0, V_zad_pr = 0, u = 0, u_z
             -ad = 0, Accel=0, tau=0.0, K = 1.0;
  34          /*
  35          typedef union INT {                   
  36             unsigned int i;
  37             unsigned char b[2];
  38          } INT;
  39          */
  40          xdata int  UgolMaxV = 4, Vmax = 200, Umax = 2;
  41          xdata float taumax = 0.000025;
  42          
  43          xdata unsigned char F;
  44          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  45          //Veter
  46          bit VeterFlag = 0;
  47          sbit WSpeed = P1^1;
  48          sbit WAngle = P1^3;
  49          
  50          xdata float Vspeed=0, Angle=0;
  51          xdata unsigned long RTC, RTCV, RTCA;
  52          xdata unsigned long TV,TA;
  53          
  54          typedef union FLOAT {                   
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 2   

  55             float f;
  56             unsigned char b[4];
  57          } FLOAT;
  58          //UART0
  59          #define NBFM            50
  60          xdata unsigned char BuferFromModem [NBFM]; 
  61          xdata unsigned char wBFM, rBFM, marBFM;
  62          xdata unsigned int u0timer;
  63          
  64          #define SIZE_BUFFER0            50
  65          xdata char BufferInModem[SIZE_BUFFER0]; 
  66          xdata int r0, rk;
  67          bit flTransmiter;       
  68          
  69          //GPS
  70          typedef union LINT {                   
  71             unsigned long i;
  72             unsigned char b[4];
  73          } LINT;
  74          #define NS      75
  75          xdata char mess [NS], r, w, mar;                
  76          bit flNewGPS;
  77          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  78          xdata unsigned long LatGnd=0, LonGnd=0;
  79          
  80          
  81          #define cT              0xA04B
  82          #define ctau    0X17ED
  83          
  84          //------------------------------------------------------------------------------
  85          void OutModem1(unsigned char Data, char i)
  86          {
  87   1              BufferInModem[i] = Data | 0x80;
  88   1      }
  89          
  90          //------------------------------------------------------------------------------
  91          void OutModem2(unsigned int Data, char i)
  92          {
  93   1              BufferInModem[i] = (Data & 0x007f)| 0x80;
  94   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  95   1      }
  96          
  97          //------------------------------------------------------------------------------
  98          void OutModem4(unsigned long int Data, char i)
  99          {
 100   1              BufferInModem[i] = (Data & 0x0000007f)| 0x80;
 101   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
 102   1              BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
 103   1         BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
 104   1      }
 105          //------------------------------------------------------------------------------------
 106          void main(void)
 107          {
 108   1      //ADC
 109   1              xdata long Pressure = 0;
 110   1              xdata float PressureFl = 0.0;
 111   1      //UART
 112   1      //   xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 113   1      //        unsigned int Value;
 114   1      //      INT Aint;
 115   1              FLOAT Bfloat;
 116   1              LINT tmpLong;
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 3   

 117   1      //GPS
 118   1         bit ValidGPS, flPoint;       
 119   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 120   1              xdata unsigned long temp_koord;
 121   1              xdata unsigned int i;
 122   1      
 123   1         xdata unsigned char chtmp;
 124   1              xdata int tmp;
 125   1      
 126   1              EA = 0;
 127   1              WDTCN     = 0xDE;       //выкл собаки
 128   1         WDTCN     = 0xAD;
 129   1              EA= 1;   
 130   1              
 131   1              LED=0;
 132   1      
 133   1              Port_IO_Init();
 134   1              Oscillator_Init();   
 135   1              Interrupts_Init(); 
 136   1              Timer_Init();
 137   1              UART0_Init();
 138   1      //   UART1_Init();
 139   1      //      PCA_Init();
 140   1      //  ADC_Init();
 141   1      
 142   1      //      LirTarget = 0x03ff;
 143   1      //      Fdelta = 0;
 144   1              flNewGPS = 0;
 145   1              u0timer=0;
 146   1      
 147   1              while(1)
 148   1              {
 149   2      //ADC
 150   2      /*              EIP2 |= 0x02;
 151   2                      if(DavlFlag==1)
 152   2                      {
 153   2                              EA = 0; 
 154   2                              Pressure =  Result * 2430 / 4095;
 155   2                              EA = 1; 
 156   2                              DavlFlag = 0;
 157   2                              PressureFl = PressureFl + (Pressure - PressureFl)*0.5;
 158   2                      }
 159   2      
 160   2      //Veter
 161   2                      if(VeterFlag==1)
 162   2                      {
 163   2                              Vspeed = (float)FREQT0/((float)TV*0.75);        //???
 164   2                              Angle = 360. - (360.*(float)TV/(float)TA);
 165   2                              VeterFlag = 0;
 166   2                      }
 167   2      
 168   2                      //GPS---------------------------------------------------------------------------
 169   2                      if(flNewGPS == 1)       
 170   2                      {
 171   2                              flNewGPS = 0;
 172   2                              if (r < w+mar*NS) 
 173   2                              {
 174   2                                      if(mess[r] == '$')
 175   2                                      {
 176   2                      nLetter = 0;
 177   2                                      }
 178   2                      else if ((nLetter == 0) && (mess[r] == 'G'))
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 4   

 179   2                      nLetter++;
 180   2                      else if ((nLetter == 1) && (mess[r] == 'P'))
 181   2                      nLetter++;
 182   2                      else if ((nLetter == 2) && (mess[r] == 'R'))
 183   2                      nLetter++;
 184   2                       else if ((nLetter == 3) && (mess[r] == 'M'))
 185   2                       nLetter++;
 186   2                 else if ((nLetter == 4) && (mess[r] == 'C'))
 187   2                      {
 188   2                      nLetter++;
 189   2                                              i_comma = 0;
 190   2                                              ValidGPS = 0;
 191   2                 } 
 192   2                              else if(mess[r] == ',')
 193   2                                      {
 194   2                                              i_comma++;
 195   2                                              i = 0;
 196   2                                              flPoint = 0;
 197   2                                      }
 198   2                              else if(i_comma == 2)
 199   2                                      {
 200   2                                              if(mess[r] == 'A') 
 201   2                                                      ValidGPS = 1;
 202   2                                              else
 203   2                                              {
 204   2                                                      ValidGPS = 0;
 205   2              //                                      flNoKoord = 1;
 206   2              //                                      liTimer_tick_GPS = liTimer_tick;
 207   2                                              }
 208   2                                      }
 209   2                      else if (ValidGPS)
 210   2                                      {
 211   2                                              if (i_comma == 3)                                       //Latitude
 212   2                                              {
 213   2                                                      if(mess[r] == '.')
 214   2                                                      {
 215   2                                                              flPoint = 1;
 216   2                                                              i = 0;
 217   2                                                      }
 218   2                                                      else if (flPoint == 0)                                          //celaya chast
 219   2                                                      {
 220   2                                                              tmpGPS[i++] = mess[r];
 221   2                                                              if(i == 2)
 222   2                                                              {
 223   2                                              tmpGPS[i] = 0;
 224   2                                                                      temp_koord = atoi(tmpGPS);
 225   2                                              temp_koord = 60UL*10000*temp_koord;
 226   2                                                              }       
 227   2                                                              else if(i == 4)
 228   2                                                              {
 229   2                                                                      tmpGPS[0] = tmpGPS[1] = '0';
 230   2                                              tmpGPS[i] = 0;
 231   2                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 232   2                                                              }       
 233   2                                                      }
 234   2                                                      else                                                                                            //drobnaya chast
 235   2                                                      {
 236   2                                                              tmpGPS[i++] = mess[r];
 237   2                                      tmpGPS[i] = 0;
 238   2                                                      }
 239   2                                              }
 240   2                                              else if (i_comma == 4)
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 5   

 241   2                                              {
 242   2                                      temp_koord = temp_koord+atoi(tmpGPS);
 243   2      //-----------
 244   2      //lLatGnd = 55UL*60*10000+50UL*10000+8680;
 245   2      //--------
 246   2                                                      if (mess[r] == 'S')                                             //znak Latitude
 247   2                                                              LatGnd = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 248   2                                                      else              
 249   2                                                              LatGnd = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 250   2                                              }
 251   2                                              else if (i_comma == 5)                          //Longitude
 252   2                                              {
 253   2                                                      if(mess[r] == '.')
 254   2                                                      {
 255   2                                                              flPoint = 1;
 256   2                                                              i = 0;
 257   2                                                      }
 258   2                                                      else if (flPoint == 0)                                          //celaya chast
 259   2                                                      {
 260   2                                                              tmpGPS[i++] = mess[r];
 261   2                                                              if(i == 3)
 262   2                                                              {
 263   2                                              tmpGPS[i] = 0;
 264   2                                              temp_koord = atoi(tmpGPS);
 265   2                                              temp_koord = 60UL*10000*temp_koord;
 266   2                                                              }       
 267   2                                                              else if(i == 5)
 268   2                                                              {
 269   2                                                                      tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 270   2                                              tmpGPS[i] = 0;
 271   2                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 272   2                                                              }       
 273   2                                                      }
 274   2                                                      else                                                                                            //drobnaya chast
 275   2                                                      {
 276   2                                                              tmpGPS[i++] = mess[r];
 277   2                                      tmpGPS[i] = 0;
 278   2                                                      }
 279   2                                              }
 280   2                                              else if (i_comma == 6)
 281   2                                              {
 282   2                                      temp_koord = temp_koord+atoi(tmpGPS);
 283   2      //----------------
 284   2      //lLonGnd = 49UL*60*10000+6UL*10000+3760;
 285   2      //----------------
 286   2                                                      if (mess[r] == 'W')                                             //znak Longitude
 287   2                                                              LonGnd = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 288   2                                                      else       
 289   2                                                              LonGnd = temp_koord+108000000UL;                //180UL*60*10000;
 290   2                                              }
 291   2                                              else if (i_comma == 7)                                                  //skorost v uzlah
 292   2                                              {
 293   2                                                      if(mess[r] == '.')
 294   2                                                      {
 295   2                                                              flPoint = 1;
 296   2                                      Vz = 1.852*atoi(tmpGPS)/3.6;            //preobrazovat iz uzlov v m/s
 297   2      //---------
 298   2      //Vz = 20;
 299   2      //-----------
 300   2                                                      }
 301   2                                                      else if(flPoint == 0)
 302   2                                                      {
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 6   

 303   2                                                              tmpGPS[i++] = mess[r];
 304   2                                      tmpGPS[i] = 0;
 305   2                                                      }
 306   2                      }
 307   2                                              else if (i_comma == 8)                                                  //kurs v gradusah
 308   2                                              {
 309   2                                                      if(mess[r] == '.')
 310   2                                                      {
 311   2                                                              flPoint = 1;
 312   2                                      koors = atoi(tmpGPS);
 313   2                              if (koors < 0)
 314   2                              koors = 360+koors;
 315   2                                                              flNoKoord = 0;
 316   2                                                              flNewGPS = 1;
 317   2                                                              liTimer_tick_GPS = liTimer_tick;        
 318   2              //                          OutModem20();
 319   2      //-----------                                              
 320   2      //koors = 30;
 321   2      //-----------
 322   2                                                      }
 323   2                                                      else if(flPoint == 0)
 324   2                                                      {
 325   2                                                              tmpGPS[i++] = mess[r];
 326   2                                      tmpGPS[i] = 0;
 327   2                                                      }
 328   2                          }
 329   2                                      }
 330   2                                      r++;
 331   2                              if(r >= NS)
 332   2                                      {
 333   2                              r = 0;
 334   2                                              mar = 0;        
 335   2                                      }      
 336   2                              }
 337   2                      }
 338   2      */
 339   2                      //---------------------------------------------------------------------
 340   2      
 341   2      //if(u0timer > (3*FREQT0))
 342   2      //              if((flTransmiter == 0) && (u0timer > FREQT0*0.3))
 343   2                      if(flTransmiter == 0 && (u0timer >1000))
 344   2                      {
 345   3                              u0timer = 0;
 346   3                              if(wBFM > 4)
 347   3                              {
 348   4                              
 349   4                                      chtmp = 0;
 350   4                                      for (i = 0; i < 5; i++ )
 351   4                                      chtmp = chtmp ^ BuferFromModem[i];
 352   4                                      chtmp = chtmp | 0x80;
 353   4                                      if(chtmp == BuferFromModem[5] && BuferFromModem[0] == (46 | 0x40))
 354   4                                      {
 355   5                                              tmp = BuferFromModem[1]&~0x80;
 356   5                              tmp |= ((int)(BuferFromModem[2]&~0x80)<<7);
 357   5                                              if(tmp<=360 && tmp>=0)
 358   5                                              {
 359   6                                                      A_zad = tmp;
 360   6                                                      tmp = BuferFromModem[3]&~0x80;
 361   6                                                      tmp |= ((int)(BuferFromModem[4]&~0x80)<<7);
 362   6                                                      K = 0.01*tmp;
 363   6                                              }
 364   5                                      }
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 7   

 365   4                                      wBFM = 0;
 366   4                              }
 367   3      
 368   3                              BufferInModem[0] = 0x40 | 40;                   
 369   3                              OutModem4(LatGnd, 1);
 370   3                              OutModem4(LonGnd, 5);
 371   3                              OutModem2((int)Angle, 9);
 372   3                              OutModem2((int)Vspeed, 11);
 373   3                              OutModem2((int)PressureFl, 13);
 374   3                      BufferInModem[15] = 0;
 375   3                              for (i = 0; i < 15; i++ )
 376   3                              BufferInModem[15] = BufferInModem[15] ^ BufferInModem[i];
 377   3                              BufferInModem[15] = 0x80 |      BufferInModem[15];
 378   3      
 379   3                              BufferInModem[16] = 0x40|41;
 380   3                              OutModem2((int)A, 17);
 381   3                      BufferInModem[19] = BufferInModem[16] ^ BufferInModem[17] ^ BufferInModem[18] | 0x80;
 382   3                              r0 = 0;
 383   3                              rk = 20;
 384   3                              //dopolnitelnye dannye
 385   3                              tmp = (int)(Accel);
 386   3                              OutModem2(tmp, 20);
 387   3                              rk+=2;
 388   3                              //A_zad, V, V_zad
 389   3                              tmp = (int)(A_zad*10.);
 390   3                              OutModem2(tmp, 22);
 391   3                              tmp = (int)(V*10.);
 392   3                              OutModem2(tmp, 24);
 393   3                              tmp = (int)(V_zad*10.);
 394   3                              OutModem2(tmp, 26);
 395   3                              rk+=6;
 396   3                              //      
 397   3                              flTransmiter = 1;
 398   3                              
 399   3                              SFRPAGE = 0x00;
 400   3                              TI0 = 1;
 401   3                      }
 402   2              }
 403   1      }
*** WARNING C280 IN LINE 115 OF SERVO_T3.C: 'Bfloat': unreferenced local variable
*** WARNING C280 IN LINE 116 OF SERVO_T3.C: 'tmpLong': unreferenced local variable
*** WARNING C280 IN LINE 118 OF SERVO_T3.C: 'ValidGPS': unreferenced local variable
*** WARNING C280 IN LINE 118 OF SERVO_T3.C: 'flPoint': unreferenced local variable
*** WARNING C280 IN LINE 119 OF SERVO_T3.C: 'i_comma': unreferenced local variable
*** WARNING C280 IN LINE 119 OF SERVO_T3.C: 'tmpGPS': unreferenced local variable
*** WARNING C280 IN LINE 120 OF SERVO_T3.C: 'temp_koord': unreferenced local variable
 404          //------------------------------------------------------------------------------------
 405          void INT0 (void) interrupt 0 //skorost vetra
 406          {
 407   1              EX0 =   0;
 408   1              VeterFlag = 1;
 409   1              TV = RTC - RTCV;
 410   1              RTCV = RTC;
 411   1              return;
 412   1      }
 413          
 414          //------------------------------------------------------------------------------------
 415          void TIMER_ISR0 (void) interrupt 1
 416          {
 417   1              xdata float tmp;
 418   1              static xdata  unsigned int shim;
 419   1              xdata char SFRPAGE_SAVE = SFRPAGE;
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 8   

 420   1              static xdata char flShim = 0;
 421   1              SFRPAGE = TIMER01_PAGE;
 422   1              RTC++;
 423   1              u0timer++;
 424   1      
 425   1      /*      
 426   1              if(WSpeed != 0)
 427   1                      EX0 = 1;
 428   1      
 429   1              if(WAngle != 0)
 430   1                      EX1 = 1;
 431   1      */
 432   1      if(flShim == 0)
 433   1      {       
 434   2                      flShim = 1;
 435   2      
 436   2                      LData = 0;
 437   2                      EA = 0; //опрос ЛИР
 438   2              
 439   2                      LIR_SCK = 1;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 440   2                      LIR_SCK = 0;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 441   2                              
 442   2                      LIR_SCK = 1;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 443   2                      LIR_SCK = 0;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++; 
 444   2                      LData = LData | LIR_DATA;       
 445   2      
 446   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 447   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 448   2                      LData = (LData << 1) | LIR_DATA;        
 449   2              
 450   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 451   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 452   2                      LData = (LData << 1) | LIR_DATA;        
 453   2      
 454   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 455   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 456   2                      LData = (LData << 1) | LIR_DATA;        
 457   2              
 458   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 459   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 460   2                      LData = (LData << 1) | LIR_DATA;        
 461   2      
 462   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 463   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 464   2                      LData = (LData << 1) | LIR_DATA;        
 465   2      
 466   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 467   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 468   2                      LData = (LData << 1) | LIR_DATA;        
 469   2      
 470   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 471   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 472   2                      LData = (LData << 1) | LIR_DATA;        
 473   2      
 474   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 475   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 476   2                      LData = (LData << 1) | LIR_DATA;        
 477   2      
 478   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 479   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 480   2                      LData = (LData << 1) | LIR_DATA;        
 481   2      
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 9   

 482   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 483   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 484   2                      LData = (LData << 1) | LIR_DATA;        
 485   2      
 486   2                      LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 487   2                      LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 488   2                      LData = (LData << 1) | LIR_DATA;
 489   2      
 490   2                      LIR_SCK = 1; 
 491   2                      EA = 1;
 492   2              
 493   2                      //управление антеной------------------------------------------------------------------------
 494   2                      tmp = 360.0/4095.0*LData;
 495   2                      if ((A > 270) && (tmp < 90))
 496   2                      {
 497   3                              A = A+(tmp+360-A)/FREQT0*K;
 498   3                              if (A > 360)
 499   3                                      A = A-360;
 500   3                      }
 501   2                      else if ((tmp > 270) && (A < 90))
 502   2                      {
 503   3                              A = A+(tmp-A-360)/FREQT0*K;
 504   3                              if (A < 0)
 505   3                                      A = A+360;
 506   3                      }
 507   2                      else
 508   2                              A = A+(tmp-A)/FREQT0*K;
 509   2      
 510   2                      if ((A_pr > 270) && (A < 90))
 511   2                              V = V+((A+360-A_pr)*FREQT0-V)/FREQT0*K; 
 512   2                      else if ((A > 270) && (A_pr < 90))
 513   2                              V = V+((A-A_pr-360)*FREQT0-V)/FREQT0*K; 
 514   2                      else
 515   2                              V = V+((A-A_pr)*FREQT0-V)/FREQT0*K; 
 516   2                      A_pr = A;
 517   2      
 518   2                      u = u+((V-V_pr)*FREQT0-u)/FREQT0*K;
 519   2                      V_pr = V;
 520   2              
 521   2                      V_zad = A_zad-A;
 522   2                      while (V_zad > 180)
 523   2                      V_zad -= 360;
 524   2                      while (V_zad < -180)
 525   2                      V_zad += 360;
 526   2      
 527   2      /*              if ((V_pr > ) && (V < 90))
 528   2                              u = u+((A+360-A_pr)*FREQT0-u_zad)/FREQT0*K; 
 529   2                      else if ((V > 270) && (V_pr < 90))
 530   2      //                      u = u+((A-A_pr-360)*FREQT0-u_zad)/FREQT0*K; 
 531   2                              u_zad = u_zad+((V_zad-V_zad_pr)*FREQT0-u_zad)/FREQT0*K;
 532   2                      else
 533   2                              u_zad = u_zad+((V_zad-V_zad_pr)*FREQT0-u_zad)/FREQT0*K; */
 534   2      
 535   2                      V_zad = 50*V_zad;
 536   2                      if(V_zad>Vmax){V_zad=Vmax;}
 537   2                      else if(V_zad<-Vmax){V_zad=-Vmax;}
 538   2      
 539   2                      u_zad = u_zad+((V_zad-V_zad_pr)*1000-u_zad)/FREQT0*K;
 540   2                      V_zad_pr = V_zad;
 541   2                      
 542   2              //      tmp = (12*u_zad-u)*ctau + (10*V_zad-V)/Vmax*ctau;
 543   2      //              tmp =((10*V_zad-V)/Vmax*ctau)/(1+(12*u_zad-u)*ctau*(10*V_zad-V)/Vmax*ctau);
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 10  

 544   2                      tmp = (u_zad-u)/Umax*ctau + 0.5*(V_zad-V)/Vmax*ctau + 0.2*(A_zad-A)/360*ctau;
 545   2      //              tmp = ((V_zad-V)/Vmax*ctau)/(1+(u_zad-u)*ctau*(V_zad-V)/Vmax*ctau)+0.2*(A_zad-A)/360*ctau;
 546   2      
 547   2                      if (tmp > (ctau)) tmp = ctau;
 548   2                      if (tmp < -(ctau)) tmp = -(ctau);
 549   2      
 550   2                      if (tmp > 512)
 551   2                      {
 552   3                              shim = 0xffff-tmp;
 553   3                      LED2 = 0;
 554   3                              LED = 1;
 555   3                              TH0 = (shim & 0xff00) >> 8;
 556   3                         TL0 = shim & 0x00ff;
 557   3                      }
 558   2                      else if(tmp < -512)
 559   2                      {
 560   3                              shim = 0xffff+tmp;
 561   3                         LED = 0;
 562   3                              LED2 = 1;
 563   3                              TH0 = (shim & 0xff00) >> 8;
 564   3                         TL0 = shim & 0x00ff;
 565   3                      }
 566   2                      else
 567   2                      {
 568   3                      LED = 0;
 569   3                              LED2 = 0;
 570   3                              flShim = 0;
 571   3                      }
 572   2              }
 573   1              else
 574   1              {
 575   2                      flShim = 0;
 576   2                      LED = 0;
 577   2                      LED2 = 0;
 578   2                      
 579   2                      shim = cT + 4*ctau;
 580   2                      TH0 = (shim & 0xff00) >> 8;
 581   2                      TL0 = shim & 0x00ff;
 582   2              }
 583   1              SFRPAGE = SFRPAGE_SAVE;
 584   1              return;
 585   1      }
 586          
 587          //------------------------------------------------------------------------------------
 588          void INT1 (void) interrupt 2 //napravl vetra
 589          {
 590   1              EX1=0;
 591   1              TA = RTC - RTCA;
 592   1              RTCA = RTC;
 593   1              return;
 594   1      }
 595          
 596          //------------------------------------------------------------------------------------
 597          void COM_UART0_isr(void) interrupt 4
 598          {
 599   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 600   1              SFRPAGE = UART0_PAGE;
 601   1              
 602   1              if (RI0)
 603   1              {
 604   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 605   2                      if(wBFM >= NBFM)
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 11  

 606   2                      {
 607   3                      wBFM = 0;
 608   3                              marBFM = 1;
 609   3                      }
 610   2                      RI0 = 0;
 611   2              }
 612   1              if (TI0)
 613   1              {
 614   2                      if(r0 < rk)
 615   2                      {
 616   3                              SBUF0 = BufferInModem[r0++];
 617   3                      }
 618   2                      else
 619   2                      {
 620   3                              flTransmiter = 0;
 621   3                      }
 622   2                      TI0 = 0;
 623   2              }
 624   1              
 625   1              SFRPAGE = SFRPAGE_SAVE;
 626   1              return;
 627   1      }
 628          
 629          //-------------------------------------------------------------------
 630          
 631          void PCA_isr (void)interrupt 9 
 632          {
 633   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 634   1              SFRPAGE = PCA0_PAGE;
 635   1              CF = 0;                                                                                 //Сброс флага прерывания шимогенератора
 636   1              SFRPAGE = SFRPAGE_SAVE;
 637   1              return;
 638   1      }
 639          //-------------------------------------------------------------------
 640          
 641          void ADC0_ISR (void) interrupt 15
 642          {
 643   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 644   1              SFRPAGE = ADC0_PAGE;
 645   1              AD0INT = 0;                         // Clear ADC conversion complete
 646   1                                             // indicator
 647   1         accumulator += ADC0;                // Read ADC value and add to running
 648   1                                             // total
 649   1         int_dec--;                          // Update decimation counter
 650   1      
 651   1         if (int_dec == 0)                   // If zero, then post result
 652   1         {
 653   2                      int_dec = 256;                          // Reset counter
 654   2            Result = accumulator >> 8;
 655   2            accumulator = 0L;                // Reset accumulator
 656   2                      DavlFlag = 1;
 657   2                      EIP2  &= ~0x02;
 658   2         }
 659   1              SFRPAGE = SFRPAGE_SAVE;
 660   1              return;
 661   1      }
 662          //-------------------------------------------------------------------
 663          void GPS_UART1_isr(void) interrupt 20
 664          {
 665   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 666   1              SFRPAGE = UART1_PAGE;
 667   1              if (RI1)
C51 COMPILER V9.00   SERVO_T3                                                              11/23/2012 14:28:37 PAGE 12  

 668   1              {
 669   2                      flNewGPS = 1;
 670   2                      mess [w++] = SBUF1;  // read character
 671   2                      if(w >= NS)
 672   2                      {
 673   3                      w = 0;
 674   3                              mar = 1;
 675   3                      }
 676   2                      RI1 = 0;
 677   2              }
 678   1              if (TI1)
 679   1              {
 680   2                              
 681   2              }
 682   1              SFRPAGE = SFRPAGE_SAVE;
 683   1              return;
 684   1      }
 685          
 686          
 687          //#endif
 688          
 689          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7438    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    324      34
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
