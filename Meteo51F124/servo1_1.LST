C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO1_1
OBJECT MODULE PLACED IN servo1_1.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo1_1.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "init6.h"
*** WARNING C318 IN LINE 2 OF servo1_1.c: can't open file 'init6.h'
   3          #include "comport.h"
   4          #include <intrins.h>
   5          #include <ctype.h>
   6          #include <stdio.h>
   7          #include <stdlib.h>
   8                              
   9          
  10          #define SYSCLK 24500000 //Hz
  11          #define FREQT0 1183 //Hz
  12          
  13          //отладочные
  14          sbit LED = P1^6;
  15          sbit LED2 = P2^6;
  16          sbit BUTTON = P3^7;
  17          xdata unsigned char InitFlag;
  18          //--------------
  19          //лир
  20          sbit LIR_DATA = P2^0;
  21          sbit LIR_SCK = P2^1;
  22          
  23          xdata unsigned char F;
  24          xdata unsigned int delta, LirData, LirTarget, Fdelta, shim;
  25          
  26          typedef union INT {                   
  27             unsigned int i;
  28             unsigned char b[2];
  29          } INT;
  30          //---
  31          //ветер
  32          sbit WSpeed = P1^1;
  33          sbit WAngle = P1^3;
  34          
  35          xdata float Vspeed, Angle;
  36          xdata unsigned long RTC, RTCV, RTCA;
  37          xdata unsigned long TV,TA;
  38          
  39          typedef union FLOAT {                   
  40             float f;
  41             unsigned char b[4];
  42          } FLOAT;
  43          //-----
  44          //UART0
  45          #define NBFM            50
  46          xdata unsigned char BuferFromModem [NBFM]; 
  47          xdata unsigned char wBFM, rBFM, marBFM, u0timer;
  48          
  49          #define SIZE_BUFFER0            50
  50          xdata char BufferInModem[SIZE_BUFFER0]; // Для отправки в последовательный порт
  51          xdata int r0, rk;
  52          bit flTransmiter;       
  53          
  54          //SMBus
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 2   

  55          xdata unsigned int Humidity, Temperature;
  56          
  57          //GPS
  58          #define NS      75
  59          xdata char mess [NS], r, w, mar;                // Для анализа посылки GPS
  60          bit flNewGPS;
  61          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  62          xdata unsigned long LatFly, LonFly;
  63          //------------------------------------------------------------------------------
  64          void OutModem1(unsigned char Data, char i)
  65          {
  66   1              BufferInModem[i] = Data | 0x80;
  67   1      }
  68          
  69          //------------------------------------------------------------------------------
  70          void OutModem2(unsigned int Data, char i)
  71          {
  72   1              BufferInModem[i] = (Data & 0x007f)| 0x80;
  73   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  74   1      }
  75          
  76          //------------------------------------------------------------------------------
  77          void OutModem4(unsigned long int Data, char i)
  78          {
  79   1              BufferInModem[i] = (Data & 0x0000007f)| 0x80;
  80   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
  81   1              BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
  82   1         BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
  83   1      }
  84          //------------------------------------------------------------------------------------------
  85          void LirQ(void)
  86          {
  87   1                      //Опрос ЛИР----------------------------
  88   1              LirData = 0;
  89   1              EA = 0; //опрос ЛИР
  90   1              
  91   1              LIR_SCK = 1;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
  92   1              LIR_SCK = 0;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
  93   1                              
  94   1      /*      LIR_SCK = 1;    //---D n-1
  95   1              shim++;
  96   1              LIR_SCK = 0;
  97   1              shim++;
  98   1      */                      
  99   1              LIR_SCK = 1;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 100   1              LIR_SCK = 0;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++; 
 101   1              LirData = LirData | LIR_DATA;   
 102   1      
 103   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 104   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 105   1              LirData = (LirData << 1) | LIR_DATA;    
 106   1              
 107   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 108   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 109   1              LirData = (LirData << 1) | LIR_DATA;    
 110   1      
 111   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 112   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 113   1              LirData = (LirData << 1) | LIR_DATA;    
 114   1              
 115   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 116   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 3   

 117   1              LirData = (LirData << 1) | LIR_DATA;    
 118   1      
 119   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 120   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 121   1              LirData = (LirData << 1) | LIR_DATA;    
 122   1      
 123   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 124   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 125   1              LirData = (LirData << 1) | LIR_DATA;    
 126   1      
 127   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 128   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 129   1              LirData = (LirData << 1) | LIR_DATA;    
 130   1      
 131   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 132   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 133   1              LirData = (LirData << 1) | LIR_DATA;    
 134   1      
 135   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 136   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 137   1              LirData = (LirData << 1) | LIR_DATA;    
 138   1      
 139   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 140   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 141   1              LirData = (LirData << 1) | LIR_DATA;    
 142   1      
 143   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 144   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 145   1              LirData = (LirData << 1) | LIR_DATA;
 146   1      
 147   1              LIR_SCK = 1; 
 148   1              EA = 1;
 149   1      }
 150          //------------------------------------------------------------------------------------------
 151          
 152          void main(void)
 153          {
 154   1              //LIR------
 155   1      //      xdata unsigned char FdKoeff;
 156   1              //---------
 157   1              xdata unsigned int i;
 158   1              INT Aint;
 159   1              FLOAT Bfloat;
 160   1              //UART----------
 161   1      //   xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 162   1      //      unsigned int Value;
 163   1              //--------------
 164   1         bit ValidGPS, flPoint;       
 165   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 166   1              xdata unsigned long temp_koord;
 167   1      
 168   1              Init_Device();
*** WARNING C206 IN LINE 168 OF SERVO1_1.C: 'Init_Device': missing function-prototype
 169   1      
 170   1              LirTarget = 0x03ff;
 171   1              Fdelta = 0;
 172   1              flNewGPS = 0;
 173   1              LED = 0;
 174   1         while(1)
 175   1              {
 176   2      //расчет скорости ветра и угла--------------------------------------------------------------
 177   2                      Vspeed = (float)FREQT0/((float)TV*0.75);
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 4   

 178   2                      Angle = 360. - (360.*(float)TV/(float)TA);
 179   2              }
 180   1      //Опрос GPS---------------------------------------------------------------------------
 181   1      {
 182   2              if(flNewGPS)    
 183   2              {
 184   3                      flNewGPS = 0;
 185   3                      //Расшифровка посылки GPS
 186   3                      if (r < w+mar*NS) 
 187   3                      {
 188   4                              if(mess[r] == '$')
 189   4                              {
 190   5                  nLetter = 0;
 191   5                              }
 192   4               else if ((nLetter == 0) && (mess[r] == 'G'))
 193   4                  nLetter++;
 194   4               else if ((nLetter == 1) && (mess[r] == 'P'))
 195   4                  nLetter++;
 196   4               else if ((nLetter == 2) && (mess[r] == 'R'))
 197   4                  nLetter++;
 198   4               else if ((nLetter == 3) && (mess[r] == 'M'))
 199   4                  nLetter++;
 200   4               else if ((nLetter == 4) && (mess[r] == 'C'))
 201   4               {
 202   5                  nLetter++;
 203   5                                      i_comma = 0;
 204   5                                      ValidGPS = 0;
 205   5               } 
 206   4                         else if(mess[r] == ',')
 207   4                              {
 208   5                                      i_comma++;
 209   5                                      i = 0;
 210   5                                      flPoint = 0;
 211   5                              }
 212   4                         else if(i_comma == 2)
 213   4                              {
 214   5                                      if(mess[r] == 'A') 
 215   5                                              ValidGPS = 1;
 216   5                                      else
 217   5                                      {
 218   6                                              ValidGPS = 0;
 219   6      //                                      flNoKoord = 1;
 220   6      //                                      liTimer_tick_GPS = liTimer_tick;
 221   6                                      }
 222   5                              }
 223   4               else if (ValidGPS)
 224   4                              {
 225   5                                      
 226   5                                      if (i_comma == 3)                                       //Latitude
 227   5                                      {
 228   6                                              if(mess[r] == '.')
 229   6                                              {
 230   7                                                      flPoint = 1;
 231   7                                                      i = 0;
 232   7                                              }
 233   6                                              else if (flPoint == 0)                                          //Целая часть
 234   6                                              {
 235   7                                                      tmpGPS[i++] = mess[r];
 236   7                                                      if(i == 2)
 237   7                                                      {
 238   8                                         tmpGPS[i] = 0;
 239   8                                                              temp_koord = atoi(tmpGPS);
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 5   

 240   8                                      temp_koord = 60UL*10000*temp_koord;
 241   8                                                      }       
 242   7                                                      else if(i == 4)
 243   7                                                      {
 244   8                                                              tmpGPS[0] = tmpGPS[1] = '0';
 245   8                                         tmpGPS[i] = 0;
 246   8                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 247   8                                                      }       
 248   7                                              }
 249   6                                              else                                                                                            //Дробная часть
 250   6                                              {
 251   7                                                      tmpGPS[i++] = mess[r];
 252   7                                 tmpGPS[i] = 0;
 253   7                                              }
 254   6                                      }
 255   5                                      else if (i_comma == 4)
 256   5                                      {
 257   6                              temp_koord = temp_koord+atoi(tmpGPS);
 258   6      //-----------
 259   6      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 260   6      //--------
 261   6                                              if (mess[r] == 'S')                                             //знак Latitude
 262   6                                                      LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 263   6                                              else              
 264   6                                                      LatFly = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 265   6                                      }
 266   5                                      else if (i_comma == 5)                          //Longitude
 267   5                                      {
 268   6                                              if(mess[r] == '.')
 269   6                                              {
 270   7                                                      flPoint = 1;
 271   7                                                      i = 0;
 272   7                                              }
 273   6                                              else if (flPoint == 0)                                          //Целая часть
 274   6                                              {
 275   7                                                      tmpGPS[i++] = mess[r];
 276   7                                                      if(i == 3)
 277   7                                                      {
 278   8                                         tmpGPS[i] = 0;
 279   8                                      temp_koord = atoi(tmpGPS);
 280   8                                      temp_koord = 60UL*10000*temp_koord;
 281   8                                                      }       
 282   7                                                      else if(i == 5)
 283   7                                                      {
 284   8                                                              tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 285   8                                         tmpGPS[i] = 0;
 286   8                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 287   8                                                      }       
 288   7                                              }
 289   6                                              else                                                                                            //Дробная часть
 290   6                                              {
 291   7                                                      tmpGPS[i++] = mess[r];
 292   7                                 tmpGPS[i] = 0;
 293   7                                              }
 294   6                                      }
 295   5                                      else if (i_comma == 6)
 296   5                                      {
 297   6                              temp_koord = temp_koord+atoi(tmpGPS);
 298   6      //----------------
 299   6      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 300   6      //----------------
 301   6                                              if (mess[r] == 'W')                                             //знак Longitude
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 6   

 302   6                                                      LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 303   6                                              else       
 304   6                                                      LonFly = temp_koord+108000000UL;                //180UL*60*10000;
 305   6                                      }
 306   5                                      else if (i_comma == 7)                                                  //скорость в узлах
 307   5                                      {
 308   6                                              if(mess[r] == '.')
 309   6                                              {
 310   7                                                      flPoint = 1;
 311   7                              Vz = 1.852*atoi(tmpGPS)/3.6;            //Преобразовать из узлов в м/с
 312   7      //---------
 313   7      //Vz = 20;
 314   7      //-----------
 315   7                                              }
 316   6                                              else if(flPoint == 0)
 317   6                                              {
 318   7                                                      tmpGPS[i++] = mess[r];
 319   7                              tmpGPS[i] = 0;
 320   7                                              }
 321   6                  }
 322   5                                      else if (i_comma == 8)                                                  //курс в градусах
 323   5                                      {
 324   6                                              if(mess[r] == '.')
 325   6                                              {
 326   7                                                      flPoint = 1;
 327   7                              koors = atoi(tmpGPS);
 328   7                        if (koors < 0)
 329   7                           koors = 360+koors;
 330   7      
 331   7                                                      flNoKoord = 0;
 332   7                                                      flNewGPS = 1;
 333   7                                                      liTimer_tick_GPS = liTimer_tick;        
 334   7      //                          OutModem20();
 335   7      //-----------                                              
 336   7      //koors = 30;
 337   7      //-----------
 338   7                                              }
 339   6                                              else if(flPoint == 0)
 340   6                                              {
 341   7                                                      tmpGPS[i++] = mess[r];
 342   7                              tmpGPS[i] = 0;
 343   7                                              }
 344   6                  }
 345   5                              }
 346   4                              r++;
 347   4                      if(r >= NS)
 348   4                              {
 349   5                      r = 0;
 350   5                                      mar = 0;        
 351   5                              }      
 352   4                      }
 353   3              }
 354   2              
 355   2      //Опрос SMBus-------------------------------------------------------------------------
 356   2      //sfr SMB0CN   = 0xC0;    /* SMBUS 0 CONTROL                              */
 357   2      //sfr SMB0STA  = 0xC1;    /* SMBUS 0 STATUS                               */
 358   2      //sfr SMB0DAT  = 0xC2;    /* SMBUS 0 DATA                                 */
 359   2      //sfr SMB0ADR  = 0xC3;    /* SMBUS 0 SLAVE ADDRESS                        */
 360   2      //sfr SMB0CR   = 0xCF;    /* SMBUS 0 CLOCK RATE                           */
 361   2      /* SMB0CN 0xC0 */
 362   2      //sbit BUSY   = SMB0CN ^ 7;           /* SMBUS 0 BUSY                    */
 363   2      //sbit ENSMB  = SMB0CN ^ 6;           /* SMBUS 0 ENABLE                  */
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 7   

 364   2      //sbit STA    = SMB0CN ^ 5;           /* SMBUS 0 START FLAG              */
 365   2      //sbit STO    = SMB0CN ^ 4;           /* SMBUS 0 STOP FLAG               */
 366   2      //sbit SI     = SMB0CN ^ 3;           /* SMBUS 0 INTERRUPT PENDING FLAG  */
 367   2      //sbit AA     = SMB0CN ^ 2;           /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG */
 368   2      //sbit SMBFTE = SMB0CN ^ 1;           /* SMBUS 0 FREE TIMER ENABLE       */
 369   2      //sbit SMBTOE = SMB0CN ^ 0;           /* SMBUS 0 TIMEOUT ENABLE          */
 370   2      //#define  SMB0_PAGE         0x00     /* SMBUS 0                            */
 371   2      
 372   2      if(u0timer>0xf0)
 373   2      {
 374   3              LED=!LED;
 375   3              SFRPAGE   = SMB0_PAGE;
 376   3              ENSMB = 1;
 377   3              
 378   3              SMB0ADR = 000;
 379   3              STA = 1;
 380   3              SMB0DAT = 0x03;
 381   3                      Temperature = SMB0DAT;
 382   3              STO = 1;
 383   3      
 384   3              STA = 1;
 385   3              SMB0DAT = 0x05;
 386   3                      Humidity = SMB0DAT;
 387   3              STO = 1;
 388   3              
 389   3              ENSMB = 0;
 390   3      }
 391   2      
 392   2      //Работа с COM портом-----------------------------------------------------------------
 393   2      
 394   2      if(u0timer>0xf0)
 395   2      {
 396   3              u0timer = 0;
 397   3      //      ES0=1;
 398   3              if(wBFM > 4)
 399   3              {
 400   4                      if(BuferFromModem [wBFM-1]==0x41)
 401   4                      {
 402   5                              if(BuferFromModem [wBFM-4]==0x40)
 403   5                              {
 404   6                                      Aint.b[0] = BuferFromModem[wBFM-3];
 405   6                                      Aint.b[1] = BuferFromModem[wBFM-2];
 406   6                                      if(Aint.i<=0x0fff)
 407   6                                      {
 408   7                                              LirTarget = Aint.i;
 409   7                                      }
 410   6                              }       
 411   5                      }
 412   4                      wBFM = 0;
 413   4              }
 414   3                      //      TI0 = 1; //Read redy UART0
 415   3                      //Write to UART0--------------------------------------
 416   3                      Aint.i = LirData;
 417   3                      BufferInModem[0] = 0x40+1;
 418   3                      BufferInModem[1] = Aint.b[0];           
 419   3                      BufferInModem[2] = Aint.b[1];
 420   3                      Bfloat.f= Vspeed; 
 421   3                      BufferInModem[3] = Bfloat.b[0];
 422   3                      BufferInModem[4] = Bfloat.b[1];
 423   3                      BufferInModem[5] = Bfloat.b[2];
 424   3                      BufferInModem[6] = Bfloat.b[3];
 425   3                      Bfloat.f= Angle;
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 8   

 426   3                      BufferInModem[7] = Bfloat.b[0];
 427   3                      BufferInModem[8] = Bfloat.b[1];
 428   3                      BufferInModem[9] = Bfloat.b[2];
 429   3                      BufferInModem[10] = Bfloat.b[3];
 430   3                      BufferInModem[11] = 0x40;
 431   3      
 432   3                      BufferInModem[12] = 0;
 433   3                      for (i = 0; i < 12; i++ )
 434   3                              BufferInModem[12] = BufferInModem[12] ^ BufferInModem[i];
 435   3                      BufferInModem[12] = 0x80 | BufferInModem[12];
 436   3      
 437   3                      flTransmiter = 1;
 438   3              
 439   3              r0 = 0;
 440   3              rk = 13;
 441   3                      SFRPAGE = 0x00;
 442   3      
 443   3                      while (flTransmiter)
 444   3                      {
 445   4                              if(r0 < rk)
 446   4                              {
 447   5                                      flTransmiter = 1;
 448   5                                      SBUF0 = BufferInModem[r0++];
 449   5                              }
 450   4                              else
 451   4                              {
 452   5                                      flTransmiter = 0;
 453   5                              }
 454   4                      }
 455   3      //              ES0=0;
 456   3      }
 457   2              //------------------------------------------------------------
 458   2              }
 459   1      /*
 460   1      //UART----------------------------
 461   1              rBFM = wBFM = marBFM = 0;
 462   1              for(PWM = 1; PWM < 15; PWM++)
 463   1              {
 464   1                      Value = 37500;
 465   1                      write(PWM+112, Value);
 466   1              }
 467   1      
 468   1              while(1)
 469   1              {
 470   1              if(rBFM < wBFM+marBFM*NBFM)
 471   1              {
 472   1                              if ((BuferFromModem[rBFM] & 0xC0) == 0x40)
 473   1                              {
 474   1                                      nByte = 0;
 475   1                                      KontrSumma = 0;
 476   1                                      PWM = BuferFromModem[rBFM] & 0x3f;
 477   1                              }
 478   1                              if (nByte > 25)
 479   1                                      nByte = 25;
 480   1                              RK_code[nByte] = BuferFromModem[rBFM] & 0x7f;
 481   1                              KontrSumma = KontrSumma^RK_code[nByte++];
 482   1      
 483   1                              if ( (nByte == 5) && (KontrSumma == 0) )
 484   1                              {
 485   1                                      Value = RK_code[1]+((unsigned int)RK_code[2] << 7)+((unsigned int)RK_code[3] << 14);
 486   1                                      write(PWM+112, Value);
 487   1                              }
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 9   

 488   1      
 489   1               rBFM++;
 490   1                              if(rBFM >= NBFM)
 491   1                              {
 492   1                              rBFM = 0;
 493   1                                      marBFM = 0;
 494   1                              }
 495   1            }
 496   1                                      //-----------------------------------------------------------------------------------
 497   1                      if(flNewGPS)    
 498   1                      {
 499   1                              flNewGPS = 0;
 500   1               OutModem20();
 501   1      
 502   1                              if (RegimeKren == 0 || RegimeStart == 0) //не ручное управление
 503   1                                      break; 
 504   1      start1:
 505   1                              dz = LonMar[n_];
 506   1                              dz = 0.1856*(dz - LonFly)*cos_Lat0;
 507   1                         dx = LatMar[n_];
 508   1                         dx = 0.1856*(dx-LatFly);
 509   1      
 510   1      //                      if(RegimeKren)//автономный полет
 511   1      //                      {
 512   1                              dz_pr = LonMar[n_-1];
 513   1                                 dz_pr = 0.1856*(dz_pr-LonFly)*cos_Lat0;
 514   1                              dx_pr = LatMar[n_-1];
 515   1                              dx_pr = 0.1856*(dx_pr-LatFly);
 516   1      
 517   1                                 tmp =sqrt(dz*dz+dx*dx);              //tmp = rasst_toch_mar
 518   1                              if ((EPSILON > tmp) && (n_ != i_mar) && (n_ != 0))
 519   1                                 {
 520   1                              if ((n_ == i_mar-2) && (fabs(H_dat-100) > 50))
 521   1                                      ;
 522   1                              else
 523   1                              {
 524   1                                      n_++;
 525   1                                      flCommand = 1;
 526   1      
 527   1                                      if (RegimeV == 2)
 528   1                              Vz_zad = Vz_Mar[n_];
 529   1                                      if (RegimeVy == 2)
 530   1                              H_zad_buf = H_Mar[n_];
 531   1                                      goto start1;
 532   1                              }
 533   1      //                      }
 534   1      
 535   1                         if ( (fabs(dx-dx_pr) <= FLT_EPSILON) && (fabs(dz-dz_pr) <= FLT_EPSILON) )
 536   1                              napr_vetv_mar = 0;
 537   1                              else
 538   1                              napr_vetv_mar = atan2(dz-dz_pr, dx-dx_pr);
 539   1      
 540   1                      if ( (fabs(dx) <= FLT_EPSILON) && (fabs(dz) <= FLT_EPSILON) )
 541   1                              angle = 0;
 542   1                      else
 543   1                              angle = atan2(dz, dx);  //napr_toch_mar = atan2(dz, dx),
 544   1                      angle = angle-napr_vetv_mar;
 545   1      
 546   1                                 otkl_ot_mar = tmp*sin(angle);
 547   1                                      if (fabs(otkl_ot_mar) > 500) tmp = 200; //tmp = l_km
 548   1                                      else                         tmp = 500;
 549   1                                 dz = otkl_ot_mar*cos(napr_vetv_mar)+tmp*sin(napr_vetv_mar);  //dz = z_toch_pricel
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 10  

 550   1                              dx = -otkl_ot_mar*sin(napr_vetv_mar)+tmp*cos(napr_vetv_mar);    //dx = x_toch_pricel
 551   1                              }
 552   1                              tmp = koors;
 553   1                              tmp =  -tmp/ToGrad;
 554   1                      if ( (fabs(dx) > FLT_EPSILON) && (fabs(dz) > FLT_EPSILON) )
 555   1                                      tmp =  tmp + atan2(dz, dx);
 556   1      
 557   1                         while (tmp > M_PI)
 558   1                      tmp -= D_PI;
 559   1                         while (tmp < -M_PI)
 560   1                      tmp += D_PI;
 561   1      
 562   1                         tmp = ToGrad*tmp;            
 563   1                              if(tmp > 42)
 564   1                                      tmp = 42;
 565   1                         else if(tmp < -42)
 566   1                                      tmp = -42;
 567   1                              kren_zad_buf = tmp;
 568   1                      }
 569   1            else if (liTimer_tick-liTimer_tick_GPS > 2*FREQ) //Отсутствие координат
 570   1                      {
 571   1                              flNoKoord = 1;
 572   1                              liTimer_tick_GPS = liTimer_tick;        
 573   1               OutModem20();
 574   1                      }
 575   1      
 576   1                      //Расшифровка посылки GPS
 577   1                      if (r < w+mar*NS) 
 578   1                      {
 579   1                              if(mess[r] == '$')
 580   1                              {
 581   1                  nLetter = 0;
 582   1                              }
 583   1               else if ((nLetter == 0) && (mess[r] == 'G'))
 584   1                  nLetter++;
 585   1               else if ((nLetter == 1) && (mess[r] == 'P'))
 586   1                  nLetter++;
 587   1               else if ((nLetter == 2) && (mess[r] == 'R'))
 588   1                  nLetter++;
 589   1               else if ((nLetter == 3) && (mess[r] == 'M'))
 590   1                  nLetter++;
 591   1               else if ((nLetter == 4) && (mess[r] == 'C'))
 592   1               {
 593   1                  nLetter++;
 594   1                                      i_comma = 0;
 595   1                                      ValidGPS = 0;
 596   1               } 
 597   1                         else if(mess[r] == ',')
 598   1                              {
 599   1                                      i_comma++;
 600   1                                      i = 0;
 601   1                                      flPoint = 0;
 602   1                              }
 603   1                         else if(i_comma == 2)
 604   1                              {
 605   1                                      if(mess[r] == 'A') 
 606   1                                              ValidGPS = 1;
 607   1                                      else
 608   1                                      {
 609   1                                              ValidGPS = 0;
 610   1      //                                      flNoKoord = 1;
 611   1      //                                      liTimer_tick_GPS = liTimer_tick;
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 11  

 612   1                                      }
 613   1                              }
 614   1               else if (ValidGPS)
 615   1                              {
 616   1                                      if (i_comma == 3)                //Latitude
 617   1                                      {
 618   1                                              if(mess[r] == '.')
 619   1                                              {
 620   1                                                      flPoint = 1;
 621   1                                                      i = 0;
 622   1                                              }
 623   1                                              else if (flPoint == 0)                  //Целая часть
 624   1                                              {
 625   1                                                      tmpGPS[i++] = mess[r];
 626   1                                                      if(i == 2)
 627   1                                                      {
 628   1                                         tmpGPS[i] = 0;
 629   1                                                              temp_koord = atoi(tmpGPS);
 630   1                                      temp_koord = 60UL*10000*temp_koord;
 631   1                                                      }       
 632   1                                                      else if(i == 4)
 633   1                                                      {
 634   1                                                              tmpGPS[0] = tmpGPS[1] = '0';
 635   1                                         tmpGPS[i] = 0;
 636   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 637   1                                                      }       
 638   1                                              }
 639   1                                              else                                    //Дробная часть
 640   1                                              {
 641   1                                                      tmpGPS[i++] = mess[r];
 642   1                                 tmpGPS[i] = 0;
 643   1                                              }
 644   1                                      }
 645   1                                      else if (i_comma == 4)
 646   1                                      {
 647   1                              temp_koord = temp_koord+atoi(tmpGPS);
 648   1      //-----------
 649   1      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 650   1      //--------
 651   1                                              if (mess[r] == 'S')                             //знак Latitude
 652   1                                                      LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 653   1                                              else              
 654   1                                                      LatFly = 54000000UL+temp_koord; //90UL*60*10000+koord;
 655   1                                      }
 656   1                                      else if (i_comma == 5)                //Longitude
 657   1                                      {
 658   1                                              if(mess[r] == '.')
 659   1                                              {
 660   1                                                      flPoint = 1;
 661   1                                                      i = 0;
 662   1                                              }
 663   1                                              else if (flPoint == 0)                  //Целая часть
 664   1                                              {
 665   1                                                      tmpGPS[i++] = mess[r];
 666   1                                                      if(i == 3)
 667   1                                                      {
 668   1                                         tmpGPS[i] = 0;
 669   1                                      temp_koord = atoi(tmpGPS);
 670   1                                      temp_koord = 60UL*10000*temp_koord;
 671   1                                                      }       
 672   1                                                      else if(i == 5)
 673   1                                                      {
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 12  

 674   1                                                              tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 675   1                                         tmpGPS[i] = 0;
 676   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 677   1                                                      }       
 678   1                                              }
 679   1                                              else                                    //Дробная часть
 680   1                                              {
 681   1                                                      tmpGPS[i++] = mess[r];
 682   1                                 tmpGPS[i] = 0;
 683   1                                              }
 684   1                                      }
 685   1                                      else if (i_comma == 6)
 686   1                                      {
 687   1                              temp_koord = temp_koord+atoi(tmpGPS);
 688   1      //----------------
 689   1      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 690   1      //----------------
 691   1                                              if (mess[r] == 'W')   //знак Longitude
 692   1                                                      LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 693   1                                              else       
 694   1                                                      LonFly = temp_koord+108000000UL;        //180UL*60*10000;
 695   1                                      }
 696   1                                      else if (i_comma == 7)  //скорость в узлах
 697   1                                      {
 698   1                                              if(mess[r] == '.')
 699   1                                              {
 700   1                                                      flPoint = 1;
 701   1                              Vz = 1.852*atoi(tmpGPS)/3.6;   //??? Преобразовать из узлов в м/с
 702   1      //---------
 703   1      //Vz = 20;
 704   1      //-----------
 705   1                                              }
 706   1                                              else if(flPoint == 0)
 707   1                                              {
 708   1                                                      tmpGPS[i++] = mess[r];
 709   1                              tmpGPS[i] = 0;
 710   1                                              }
 711   1                  }
 712   1                                      else if (i_comma == 8)  //курс в градусах
 713   1                                      {
 714   1                                              if(mess[r] == '.')
 715   1                                              {
 716   1                                                      flPoint = 1;
 717   1                              koors = atoi(tmpGPS);
 718   1                        if (koors < 0)
 719   1                           koors = 360+koors;
 720   1      
 721   1                                                      flNoKoord = 0;
 722   1                                                      flNewGPS = 1;
 723   1                                                      liTimer_tick_GPS = liTimer_tick;        
 724   1                                  OutModem20();
 725   1      //-----------                                              
 726   1      //koors = 30;
 727   1      //-----------
 728   1                                              }
 729   1                                              else if(flPoint == 0)
 730   1                                              {
 731   1                                                      tmpGPS[i++] = mess[r];
 732   1                              tmpGPS[i] = 0;
 733   1                                              }
 734   1                  }
 735   1                              }
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 13  

 736   1                              r++;
 737   1                      if(r >= NS)
 738   1                              {
 739   1                      r = 0;
 740   1                                      mar = 0;        
 741   1                              }      
 742   1                      }
 743   1      
 744   1      
 745   1              }       
 746   1      */      
 747   1      //-----------------
 748   1      
 749   1      }
 750          
 751          //------------------------------------------------------------------------------------------
 752          //скорость ветра
 753          void INT0 (void) interrupt 0
 754          {
 755   1              TV = RTC - RTCV;
 756   1              RTCV = RTC;;
 757   1              EX0=0;
 758   1              return;
 759   1      }
 760          
 761          //------------------------------------------------------------------------------------
 762          void TIMER0_ISR (void) interrupt 1
 763          {
 764   1      //      xdata unsigned int i, delta, FdKoeff;
 765   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 766   1              SFRPAGE = TIMER01_PAGE;
 767   1              RTC++;
 768   1              //управление антеной------------------------------------------------------------------------
 769   1                      PCA0CN    = 0x40;
 770   1                 PCA0MD    = 0x01;
 771   1                      PCA0CPM0  = 0x43;
 772   1                      PCA0CPM1  = 0x43;
 773   1                      PCA0CPH0  = 0xFF;
 774   1                      PCA0CPH1  = 0xFF;
 775   1                      if(F==0x02)
 776   1                      {
 777   2                              LirQ();
 778   2                              delta = (LirTarget - LirData);  
 779   2                              if(delta > 0xF000)
 780   2                                      delta = delta - 0xF000;
 781   2                              if(delta >= 0x07FF)
 782   2                              {
 783   3                                      delta = 0x0FFF - delta;
 784   3                                      if(delta < 0x0155)
 785   3                                      {
 786   4                                              F = 0xC1;
 787   4                                              if(delta < 0x20 && delta > 0x0B)
 788   4                                              {
 789   5                                                      F = 0xC1;
 790   5                                              }
 791   4                                              else if(delta <= 0x0B)
 792   4                                              {
 793   5                                                      F = 0x03; 
 794   5                                              }
 795   4                                      }
 796   3                                      else
 797   3                                      {
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 14  

 798   4                                              F=0xA1;
 799   4                                      }
 800   3                              }
 801   2                              else if(delta < 0x07FF)
 802   2                              {
 803   3                                      if(delta < 0x0155)
 804   3                                      {
 805   4                                              F = 0xC2;
 806   4                                              if(delta < 0x20 && delta > 0x0B)
 807   4                                              {
 808   5                                                      F = 0xC2;
 809   5                                              } 
 810   4                                              else if(delta <= 0x0B)
 811   4                                              {
 812   5                                                      F = 0x03; 
 813   5                                              }
 814   4                                      }
 815   3                                      else
 816   3                                      {
 817   4                                              F=0xA2;
 818   4                                      }
 819   3                              }
 820   2                      }
 821   1                      if(LirData==0x0FFF)//при отключенном лир, воздействие отсутствует
 822   1                      {
 823   2                              F=0x03;
 824   2                      }
 825   1      //ШИМы на машинку--------------------------
 826   1                      if(F==0xA1)
 827   1                      {
 828   2                              PCA0CPH1  = 0xFF;
 829   2                              Fdelta =  delta - Fdelta;
 830   2                              Fdelta = delta;
 831   2                              PCA0CPH0  = 0xC0;
 832   2                      }
 833   1                      else if(F==0xA2)
 834   1                      {
 835   2                              PCA0CPH0  = 0xFF;
 836   2                              Fdelta =  delta - Fdelta;
 837   2                              Fdelta = delta;
 838   2                              PCA0CPH1  = 0xC0;
 839   2                      }
 840   1                      else if(F==0xC1)
 841   1                      {
 842   2                              PCA0CPH1  = 0xFF;
 843   2                              Fdelta = delta-Fdelta;
 844   2                              if(Fdelta>0x0002)
 845   2                              {
 846   3                                      PCA0CPH0  = 0xFF;
 847   3                              }
 848   2                              else
 849   2                              {
 850   3                                      PCA0CPH0  = 0xC0;
 851   3                              }
 852   2                              Fdelta = delta;
 853   2                      }
 854   1                      else if(F==0xC2)
 855   1                      {
 856   2                              PCA0CPH0  = 0xFF;
 857   2                              Fdelta =  delta - Fdelta;
 858   2                              if(Fdelta>0x0002)
 859   2                              {
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 15  

 860   3                                      PCA0CPH1  = 0xFF;
 861   3                              }
 862   2                              else
 863   2                              {
 864   3                                      PCA0CPH1  = 0xC0;
 865   3                              }
 866   2                              Fdelta = delta;
 867   2                      }  
 868   1                      if(F==0x03)
 869   1                      {
 870   2                         PCA0CPH0  = 0xFF;
 871   2                      PCA0CPH1  = 0xFF;
 872   2                      }
 873   1                      F=0x02;
 874   1      //ветер-------------
 875   1              if(WSpeed)
 876   1                      EX0=1;
 877   1      
 878   1              if(WAngle)
 879   1                      EX1=1;
 880   1      //-------------------
 881   1              u0timer++; // COM u0
 882   1      //      u1timer++; // GPS u1
 883   1      //-------------------
 884   1              SFRPAGE = SFRPAGE_SAVE;
 885   1              return;
 886   1      }
 887          
 888          
 889          
 890          //направление ветра-------------------------------------------------------------------
 891          void INT1 (void) interrupt 2
 892          {
 893   1              TA = RTC - RTCA;
 894   1              RTCA = RTC;
 895   1              EX1=0;
 896   1              return;
 897   1      }
 898          
 899          //------------------------------------------------------------------------------------
 900          void TIMER_ISR1 (void) interrupt 3
 901          {
 902   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 903   1              SFRPAGE = TIMER01_PAGE;
 904   1              
 905   1              SFRPAGE = SFRPAGE_SAVE;
 906   1              return;
 907   1      }
 908          
 909          //-------------------------------------------------------------------
 910          void COM_UART0_isr(void) interrupt 4
 911          {
 912   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 913   1      //      INT Aint;
 914   1              SFRPAGE = UART0_PAGE;
 915   1      
 916   1              if (RI0)
 917   1              {
 918   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 919   2                      if(wBFM >= NBFM)
 920   2                      {
 921   3                      wBFM = 0;
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 16  

 922   3                              marBFM = 1;
 923   3                      }/*
 924   2                      if(BuferFromModem [wBFM-1]==0x41)
 925   2                      {
 926   2                              if(BuferFromModem [wBFM-4]==0x40)
 927   2                              {
 928   2                                      Aint.b[0] = BuferFromModem[wBFM-3];
 929   2                                      Aint.b[1] = BuferFromModem[wBFM-2];
 930   2                                      if(Aint.i<=0x0fff)
 931   2                                      {
 932   2                                              LirTarget = Aint.i;
 933   2                                      }
 934   2                              }       
 935   2                      }*/
 936   2                      RI0 = 0;
 937   2              }
 938   1              if (TI0)
 939   1              {
 940   2                              
 941   2      
 942   2              }
 943   1      
 944   1              SFRPAGE = UART1_PAGE;
 945   1              if (RI1)
 946   1              {
 947   2                      flNewGPS = 1;
 948   2                      mess [w++] = SBUF1;  // read character
 949   2                      if(w >= NS)
 950   2                      {
 951   3                      w = 0;
 952   3                              mar = 1;
 953   3                      }
 954   2                      RI1 = 0;
 955   2              }
 956   1              SFRPAGE = SFRPAGE_SAVE;
 957   1              return;
 958   1      }
 959          void Timer2_ISR(void) interrupt 5
 960          {
 961   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 962   1              SFRPAGE = 0x00;
 963   1      
 964   1              SFRPAGE = SFRPAGE_SAVE;
 965   1              return;
 966   1      }
 967          //------------------------------------------------------------------------------------
 968          void SMBus_isr(void) interrupt 7
 969          {
 970   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 971   1              SFRPAGE = SMB0_PAGE;
 972   1      
 973   1              SFRPAGE = SFRPAGE_SAVE;
 974   1              return;
 975   1      }
 976          
 977          //------------------------------------------------------------------------------------
 978          void PCA_isr(void) interrupt 9
 979          {
 980   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 981   1              SFRPAGE = PCA0_PAGE;
 982   1      
 983   1              SFRPAGE = SFRPAGE_SAVE;
C51 COMPILER V9.00   SERVO1_1                                                              11/17/2012 10:48:39 PAGE 17  

 984   1              return;
 985   1      }
 986          //------------------------------------------------------------------------------------
 987          void TIMER_ISR3 (void) interrupt 14
 988          {
 989   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 990   1              SFRPAGE = TMR3_PAGE;
 991   1      
 992   1              SFRPAGE = SFRPAGE_SAVE;
 993   1              return;
 994   1      }
 995          //-------------------------------------------------------------------
 996          void GPS_UART1_isr(void) interrupt 20
 997          {
 998   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 999   1              SFRPAGE = UART1_PAGE;
1000   1              if (RI1)
1001   1              {
1002   2                      flNewGPS = 1;
1003   2                      mess [w++] = SBUF1;  // read character
1004   2                      if(w >= NS)
1005   2                      {
1006   3                      w = 0;
1007   3                              mar = 1;
1008   3                      }
1009   2                      RI1 = 0;
1010   2              }
1011   1              if (TI1)
1012   1              {
1013   2                              
1014   2              }
1015   1      
1016   1              SFRPAGE = SFRPAGE_SAVE;
1017   1              return;
1018   1      }
1019          //------------------------------------------------------------------------------------------
1020          //#endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5301    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    248      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
