C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO
OBJECT MODULE PLACED IN servo.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "init.h"
   3          #include "comport.h"
   4          #include <intrins.h>
   5          #include <ctype.h>
   6          #include <stdio.h>
   7          #include <stdlib.h>
   8          #include "servo.h"                     
   9          
  10          #define SYSCLK 24500000 //Hz
  11          #define FREQT0 8006 //Hz
  12          
  13          //отладочные
  14          sbit LED = P1^6;
  15          sbit LED2 = P2^6;
  16          sbit BUTTON = P3^7;
  17          xdata unsigned char InitFlag;
  18          //--------------
  19          //лир
  20          sbit LIR_DATA = P2^0;
  21          sbit LIR_SCK = P2^1;
  22          
  23          xdata unsigned char F;
  24          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  25          
  26          typedef union INT {                   
  27             unsigned int i;
  28             unsigned char b[2];
  29          } INT;
  30          //---
  31          //ветер
  32          xdata unsigned char VeterFlag = 0;
  33          sbit WSpeed = P1^1;
  34          sbit WAngle = P1^3;
  35          
  36          xdata float Vspeed, Angle;
  37          xdata unsigned long RTC, RTCV, RTCA;
  38          xdata unsigned long TV,TA;
  39          
  40          typedef union FLOAT {                   
  41             float f;
  42             unsigned char b[4];
  43          } FLOAT;
  44          //-----
  45          //UART0
  46          #define NBFM            50
  47          xdata unsigned char BuferFromModem [NBFM]; 
  48          xdata unsigned char wBFM, rBFM, marBFM, u0timer;
  49          
  50          #define SIZE_BUFFER0            50
  51          xdata char BufferInModem[SIZE_BUFFER0]; // Для отправки в последовательный порт
  52          xdata int r0, rk;
  53          bit flTransmiter;       
  54          
  55          //SMBus
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 2   

  56          xdata unsigned int Humidity, Temperature;
  57          
  58          //GPS
  59          #define NS      75
  60          xdata char mess [NS], r, w, mar;                // Для анализа посылки GPS
  61          bit flNewGPS;
  62          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  63          xdata unsigned long LatFly, LonFly;
  64          //------------------------------------------------------------------------------
  65          /*
  66          void OutModem1(unsigned char Data, char i)
  67          {
  68                  BufferInModem[i] = Data | 0x80;
  69          }
  70          
  71          //------------------------------------------------------------------------------
  72          void OutModem2(unsigned int Data, char i)
  73          {
  74                  BufferInModem[i] = (Data & 0x007f)| 0x80;
  75                  BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  76          }
  77          
  78          //------------------------------------------------------------------------------
  79          void OutModem4(unsigned long int Data, char i)
  80          {
  81                  BufferInModem[i] = (Data & 0x0000007f)| 0x80;
  82                  BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
  83                  BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
  84             BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
  85          }
  86          */
  87          //------------------------------------------------------------------------------------------
  88          void LirQ(void)
  89          {
  90   1                      //Опрос ЛИР----------------------------
  91   1                      EA=0;
  92   1                      LirData = 0x0000;
  93   1                      //---init
  94   1                      LIR_SCK = 1;
  95   1                      LIR_SCK = 0;
  96   1                      //---D n-1
  97   1                      LIR_SCK = 1;
  98   1                      LIR_SCK = 0;
  99   1                      //---D n-1
 100   1                      LIR_SCK = 1;
 101   1                      LIR_SCK = 0;
 102   1                      if(LIR_DATA!=0) 
 103   1                      {
 104   2                              LirData = LirData | (0x1 << (11));
 105   2                      }
 106   1                      LIR_SCK = 1; 
 107   1                      LIR_SCK = 0;
 108   1                      if(LIR_DATA!=0) 
 109   1                      {
 110   2                              LirData = LirData | (0x1 << (10));
 111   2                      }
 112   1                      LIR_SCK = 1; 
 113   1                      LIR_SCK = 0;
 114   1                      if(LIR_DATA!=0) 
 115   1                      {
 116   2                              LirData = LirData | (0x1 << (9));
 117   2                      }
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 3   

 118   1                      LIR_SCK = 1; 
 119   1                      LIR_SCK = 0;
 120   1                      if(LIR_DATA!=0) 
 121   1                      {
 122   2                              LirData = LirData | (0x1 << (8));
 123   2                      }
 124   1                      LIR_SCK = 1; 
 125   1                      LIR_SCK = 0;
 126   1                      if(LIR_DATA!=0) 
 127   1                      {
 128   2                              LirData = LirData | (0x1 << (7));
 129   2                      }
 130   1                      LIR_SCK = 1; 
 131   1                      LIR_SCK = 0;
 132   1                      if(LIR_DATA!=0) 
 133   1                      {
 134   2                              LirData = LirData | (0x1 << (6));
 135   2                      }
 136   1                      LIR_SCK = 1; 
 137   1                      LIR_SCK = 0;
 138   1                      if(LIR_DATA!=0) 
 139   1                      {
 140   2                              LirData = LirData | (0x1 << (5));
 141   2                      }
 142   1                      LIR_SCK = 1; 
 143   1                      LIR_SCK = 0;
 144   1                      if(LIR_DATA!=0) 
 145   1                      {
 146   2                              LirData = LirData | (0x1 << (4));
 147   2                      }
 148   1                      LIR_SCK = 1; 
 149   1                      LIR_SCK = 0;
 150   1                      if(LIR_DATA!=0) 
 151   1                      {
 152   2                              LirData = LirData | (0x1 << (3));
 153   2                      }
 154   1                      LIR_SCK = 1; 
 155   1                      LIR_SCK = 0;
 156   1                      if(LIR_DATA!=0) 
 157   1                      {
 158   2                              LirData = LirData | (0x1 << (2));
 159   2                      }
 160   1                      LIR_SCK = 1; 
 161   1                      LIR_SCK = 0;
 162   1                      if(LIR_DATA!=0) 
 163   1                      {
 164   2                              LirData = LirData | (0x1 << (1));
 165   2                      }
 166   1                      LIR_SCK = 1; 
 167   1                      LIR_SCK = 0;
 168   1                      if(LIR_DATA!=0) 
 169   1                      {
 170   2                              LirData = LirData | (0x1 << (0));
 171   2                      }
 172   1                      LIR_SCK = 1; 
 173   1                      EA=1;
 174   1      }
 175          //------------------------------------------------------------------------------------------
 176          
 177          void main(void)
 178          {
 179   1              //LIR------
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 4   

 180   1      //      xdata unsigned char FdKoeff;
 181   1              //---------
 182   1              xdata unsigned int i;
 183   1              INT Aint;
 184   1              FLOAT Bfloat;
 185   1              //UART----------
 186   1         xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 187   1              unsigned int Value;
 188   1              //--------------
 189   1         bit ValidGPS, flPoint;       
 190   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 191   1              xdata unsigned long temp_koord;
 192   1      
 193   1              Init_Device();
 194   1      
 195   1              LirTarget = 0x03ff;
 196   1              Fdelta = 0;
 197   1              flNewGPS = 0;
 198   1              LED = 0;
 199   1         while(1)
 200   1              {
 201   2      //расчет скорости ветра и угла--------------------------------------------------------------
 202   2                      CF = 1;
 203   2                      if(VeterFlag)
 204   2                      {
 205   3                              Vspeed = (float)FREQT0/((float)TV*0.75);
 206   3                              Angle = 360. - (360.*(float)TV/(float)TA);
 207   3                              VeterFlag = 0;
 208   3                      }
 209   2      //управление антеной------------------------------------------------------------------------
 210   2                      if(F==0x02)
 211   2                      {
 212   3                              LirQ();
 213   3                              delta = (LirTarget - LirData);  
 214   3                              if(delta > 0xF000)
 215   3                                      delta = delta - 0xF000;
 216   3                              if(delta >= 0x07FF)
 217   3                              {
 218   4                                      delta = 0x0FFF - delta;
 219   4                                      if(delta < 0x0155)
 220   4                                      {
 221   5                                              F = 0xC1;
 222   5                                              if(delta < 0x20 && delta > 0x0B)
 223   5                                              {
 224   6                                                      F = 0xC1;
 225   6                                              }
 226   5                                              else if(delta <= 0x0B)
 227   5                                              {
 228   6                                                      F = 0x03; 
 229   6                                              }
 230   5                                      }
 231   4                                      else
 232   4                                      {
 233   5                                              F=0xA1;
 234   5                                      }
 235   4                              }
 236   3                              else if(delta < 0x07FF)
 237   3                              {
 238   4                                      if(delta < 0x0155)
 239   4                                      {
 240   5                                              F = 0xC2;
 241   5                                              if(delta < 0x20 && delta > 0x0B)
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 5   

 242   5                                              {
 243   6                                                      F = 0xC2;
 244   6                                              } 
 245   5                                              else if(delta <= 0x0B)
 246   5                                              {
 247   6                                                      F = 0x03; 
 248   6                                              }
 249   5                                      }
 250   4                                      else
 251   4                                      {
 252   5                                              F=0xA2;
 253   5                                      }
 254   4                              }
 255   3                      }
 256   2                 if(LirData==0x0FFF)//при отключенном лир, воздействие отсутствует
 257   2                      {
 258   3                              F=0x03;
 259   3                      }
 260   2      //ШИМы на машинку--------------------------
 261   2                      if(F==0xA1)
 262   2                      {
 263   3                              PCA0CPM0  = 0x43;
 264   3                              PCA0CPH0  = 0xC0;
 265   3                              PCA0CPM1  = 0x43;
 266   3                              PCA0CPH1  = 0xFF;
 267   3                              PCA0CPL1  = 0xFF;
 268   3                              Fdelta =  delta - Fdelta;
 269   3                              Fdelta = delta;
 270   3                      }
 271   2                      else if(F==0xA2)
 272   2                      {
 273   3                              PCA0CPM1  = 0x43;
 274   3                              PCA0CPH1  = 0xC0;
 275   3                              PCA0CPM0  = 0x43;
 276   3                              PCA0CPH0  = 0xFF;
 277   3                              PCA0CPL0  = 0xFF;
 278   3                              Fdelta =  delta - Fdelta;
 279   3                              Fdelta = delta;
 280   3                      }
 281   2                      else if(F==0xC1)
 282   2                      {
 283   3                              Fdelta = delta-Fdelta;
 284   3                              if(Fdelta>0x0002)
 285   3                              {
 286   4                                      PCA0CPM0  = 0x43;
 287   4                                      PCA0CPH0  = 0xFF;
 288   4                                      PCA0CPL0  = 0xFF;
 289   4                                      PCA0CPM1  = 0x43;
 290   4                                      PCA0CPH1  = 0xFF;
 291   4                                      PCA0CPL1  = 0xFF;
 292   4                              }
 293   3                              else
 294   3                              {
 295   4                                      PCA0CPM0  = 0x43;
 296   4                                      PCA0CPH0  = 0xe6;
 297   4                                      PCA0CPM1  = 0x43;
 298   4                                      PCA0CPH1  = 0xFF;
 299   4                                      PCA0CPL1  = 0xFF;
 300   4                              }
 301   3                              Fdelta = delta;
 302   3                              
 303   3                      }
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 6   

 304   2                      else if(F==0xC2)
 305   2                      {
 306   3                              Fdelta =  delta - Fdelta;
 307   3                              if(Fdelta>0x0002)
 308   3                              {
 309   4                                      PCA0CPM0  = 0x43;
 310   4                                      PCA0CPH0  = 0xFF;
 311   4                                      PCA0CPL0  = 0xFF;
 312   4                                      PCA0CPM1  = 0x43;
 313   4                                      PCA0CPH1  = 0xFF;
 314   4                                      PCA0CPL1  = 0xFF;
 315   4                              }
 316   3                              else
 317   3                              {
 318   4                                      PCA0CPM1  = 0x43;
 319   4                                      PCA0CPH1  = 0xe6;
 320   4                                      PCA0CPM0  = 0x43;
 321   4                                      PCA0CPH0  = 0xFF;
 322   4                                      PCA0CPL0  = 0xFF;
 323   4                              }
 324   3                              Fdelta = delta;
 325   3                      }  
 326   2                      if(F==0x03)
 327   2                      {
 328   3                         PCA0CPM0  = 0x43;
 329   3                              PCA0CPH0  = 0xFF;
 330   3                              PCA0CPL0  = 0xFF;
 331   3                              PCA0CPM1  = 0x43;
 332   3                              PCA0CPH1  = 0xFF;
 333   3                              PCA0CPL1  = 0xFF;
 334   3                      }
 335   2                      F=0x02;
 336   2      //Опрос GPS---------------------------------------------------------------------------
 337   2      
 338   2              if(flNewGPS)    
 339   2              {
 340   3                      flNewGPS = 0;
 341   3                      //Расшифровка посылки GPS
 342   3                      if (r < w+mar*NS) 
 343   3                      {
 344   4                              if(mess[r] == '$')
 345   4                              {
 346   5                  nLetter = 0;
 347   5                              }
 348   4               else if ((nLetter == 0) && (mess[r] == 'G'))
 349   4                  nLetter++;
 350   4               else if ((nLetter == 1) && (mess[r] == 'P'))
 351   4                  nLetter++;
 352   4               else if ((nLetter == 2) && (mess[r] == 'R'))
 353   4                  nLetter++;
 354   4               else if ((nLetter == 3) && (mess[r] == 'M'))
 355   4                  nLetter++;
 356   4               else if ((nLetter == 4) && (mess[r] == 'C'))
 357   4               {
 358   5                  nLetter++;
 359   5                                      i_comma = 0;
 360   5                                      ValidGPS = 0;
 361   5               } 
 362   4                         else if(mess[r] == ',')
 363   4                              {
 364   5                                      i_comma++;
 365   5                                      i = 0;
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 7   

 366   5                                      flPoint = 0;
 367   5                              }
 368   4                         else if(i_comma == 2)
 369   4                              {
 370   5                                      if(mess[r] == 'A') 
 371   5                                              ValidGPS = 1;
 372   5                                      else
 373   5                                      {
 374   6                                              ValidGPS = 0;
 375   6      //                                      flNoKoord = 1;
 376   6      //                                      liTimer_tick_GPS = liTimer_tick;
 377   6                                      }
 378   5                              }
 379   4               else if (ValidGPS)
 380   4                              {
 381   5                                      
 382   5                                      if (i_comma == 3)                                       //Latitude
 383   5                                      {
 384   6                                              if(mess[r] == '.')
 385   6                                              {
 386   7                                                      flPoint = 1;
 387   7                                                      i = 0;
 388   7                                              }
 389   6                                              else if (flPoint == 0)                                          //Целая часть
 390   6                                              {
 391   7                                                      tmpGPS[i++] = mess[r];
 392   7                                                      if(i == 2)
 393   7                                                      {
 394   8                                         tmpGPS[i] = 0;
 395   8                                                              temp_koord = atoi(tmpGPS);
 396   8                                      temp_koord = 60UL*10000*temp_koord;
 397   8                                                      }       
 398   7                                                      else if(i == 4)
 399   7                                                      {
 400   8                                                              tmpGPS[0] = tmpGPS[1] = '0';
 401   8                                         tmpGPS[i] = 0;
 402   8                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 403   8                                                      }       
 404   7                                              }
 405   6                                              else                                                                                            //Дробная часть
 406   6                                              {
 407   7                                                      tmpGPS[i++] = mess[r];
 408   7                                 tmpGPS[i] = 0;
 409   7                                              }
 410   6                                      }
 411   5                                      else if (i_comma == 4)
 412   5                                      {
 413   6                              temp_koord = temp_koord+atoi(tmpGPS);
 414   6      //-----------
 415   6      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 416   6      //--------
 417   6                                              if (mess[r] == 'S')                                             //знак Latitude
 418   6                                                      LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 419   6                                              else              
 420   6                                                      LatFly = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 421   6                                      }
 422   5                                      else if (i_comma == 5)                          //Longitude
 423   5                                      {
 424   6                                              if(mess[r] == '.')
 425   6                                              {
 426   7                                                      flPoint = 1;
 427   7                                                      i = 0;
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 8   

 428   7                                              }
 429   6                                              else if (flPoint == 0)                                          //Целая часть
 430   6                                              {
 431   7                                                      tmpGPS[i++] = mess[r];
 432   7                                                      if(i == 3)
 433   7                                                      {
 434   8                                         tmpGPS[i] = 0;
 435   8                                      temp_koord = atoi(tmpGPS);
 436   8                                      temp_koord = 60UL*10000*temp_koord;
 437   8                                                      }       
 438   7                                                      else if(i == 5)
 439   7                                                      {
 440   8                                                              tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 441   8                                         tmpGPS[i] = 0;
 442   8                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 443   8                                                      }       
 444   7                                              }
 445   6                                              else                                                                                            //Дробная часть
 446   6                                              {
 447   7                                                      tmpGPS[i++] = mess[r];
 448   7                                 tmpGPS[i] = 0;
 449   7                                              }
 450   6                                      }
 451   5                                      else if (i_comma == 6)
 452   5                                      {
 453   6                              temp_koord = temp_koord+atoi(tmpGPS);
 454   6      //----------------
 455   6      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 456   6      //----------------
 457   6                                              if (mess[r] == 'W')                                             //знак Longitude
 458   6                                                      LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 459   6                                              else       
 460   6                                                      LonFly = temp_koord+108000000UL;                //180UL*60*10000;
 461   6                                      }
 462   5                                      else if (i_comma == 7)                                                  //скорость в узлах
 463   5                                      {
 464   6                                              if(mess[r] == '.')
 465   6                                              {
 466   7                                                      flPoint = 1;
 467   7                              Vz = 1.852*atoi(tmpGPS)/3.6;            //Преобразовать из узлов в м/с
 468   7      //---------
 469   7      //Vz = 20;
 470   7      //-----------
 471   7                                              }
 472   6                                              else if(flPoint == 0)
 473   6                                              {
 474   7                                                      tmpGPS[i++] = mess[r];
 475   7                              tmpGPS[i] = 0;
 476   7                                              }
 477   6                  }
 478   5                                      else if (i_comma == 8)                                                  //курс в градусах
 479   5                                      {
 480   6                                              if(mess[r] == '.')
 481   6                                              {
 482   7                                                      flPoint = 1;
 483   7                              koors = atoi(tmpGPS);
 484   7                        if (koors < 0)
 485   7                           koors = 360+koors;
 486   7      
 487   7                                                      flNoKoord = 0;
 488   7                                                      flNewGPS = 1;
 489   7                                                      liTimer_tick_GPS = liTimer_tick;        
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 9   

 490   7      //                          OutModem20();
 491   7      //-----------                                              
 492   7      //koors = 30;
 493   7      //-----------
 494   7                                              }
 495   6                                              else if(flPoint == 0)
 496   6                                              {
 497   7                                                      tmpGPS[i++] = mess[r];
 498   7                              tmpGPS[i] = 0;
 499   7                                              }
 500   6                  }
 501   5                              }
 502   4                              r++;
 503   4                      if(r >= NS)
 504   4                              {
 505   5                      r = 0;
 506   5                                      mar = 0;        
 507   5                              }      
 508   4                      }
 509   3              }
 510   2              
 511   2      //Опрос SMBus-------------------------------------------------------------------------
 512   2      //sfr SMB0CN   = 0xC0;    /* SMBUS 0 CONTROL                              */
 513   2      //sfr SMB0STA  = 0xC1;    /* SMBUS 0 STATUS                               */
 514   2      //sfr SMB0DAT  = 0xC2;    /* SMBUS 0 DATA                                 */
 515   2      //sfr SMB0ADR  = 0xC3;    /* SMBUS 0 SLAVE ADDRESS                        */
 516   2      //sfr SMB0CR   = 0xCF;    /* SMBUS 0 CLOCK RATE                           */
 517   2      /* SMB0CN 0xC0 */
 518   2      //sbit BUSY   = SMB0CN ^ 7;           /* SMBUS 0 BUSY                    */
 519   2      //sbit ENSMB  = SMB0CN ^ 6;           /* SMBUS 0 ENABLE                  */
 520   2      //sbit STA    = SMB0CN ^ 5;           /* SMBUS 0 START FLAG              */
 521   2      //sbit STO    = SMB0CN ^ 4;           /* SMBUS 0 STOP FLAG               */
 522   2      //sbit SI     = SMB0CN ^ 3;           /* SMBUS 0 INTERRUPT PENDING FLAG  */
 523   2      //sbit AA     = SMB0CN ^ 2;           /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG */
 524   2      //sbit SMBFTE = SMB0CN ^ 1;           /* SMBUS 0 FREE TIMER ENABLE       */
 525   2      //sbit SMBTOE = SMB0CN ^ 0;           /* SMBUS 0 TIMEOUT ENABLE          */
 526   2      //#define  SMB0_PAGE         0x00     /* SMBUS 0                            */
 527   2      
 528   2      if(u0timer>0xf0)
 529   2      {
 530   3              LED=!LED;
 531   3              SFRPAGE   = SMB0_PAGE;
 532   3              ENSMB = 1;
 533   3              
 534   3              SMB0ADR = 000;
 535   3              STA = 1;
 536   3              SMB0DAT = 0x03;
 537   3                      Temperature = SMB0DAT;
 538   3              STO = 1;
 539   3      
 540   3              STA = 1;
 541   3              SMB0DAT = 0x05;
 542   3                      Humidity = SMB0DAT;
 543   3              STO = 1;
 544   3              
 545   3              ENSMB = 0;
 546   3      }
 547   2      
 548   2      //Работа с COM портом-----------------------------------------------------------------
 549   2      
 550   2      if(u0timer>0xf0)
 551   2      {
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 10  

 552   3              u0timer = 0;
 553   3      //      ES0=1;
 554   3              if(wBFM > 4)
 555   3              {
 556   4                      if(BuferFromModem [wBFM-1]==0x41)
 557   4                      {
 558   5                              if(BuferFromModem [wBFM-4]==0x40)
 559   5                              {
 560   6                                      Aint.b[0] = BuferFromModem[wBFM-3];
 561   6                                      Aint.b[1] = BuferFromModem[wBFM-2];
 562   6                                      if(Aint.i<=0x0fff)
 563   6                                      {
 564   7                                              LirTarget = Aint.i;
 565   7                                      }
 566   6                              }       
 567   5                      }
 568   4                      wBFM = 0;
 569   4              }
 570   3                      //      TI0 = 1; //Read redy UART0
 571   3                      //Write to UART0--------------------------------------
 572   3                      Aint.i = LirData;
 573   3                      BufferInModem[0] = 0x40+1;
 574   3                      BufferInModem[1] = Aint.b[0];           
 575   3                      BufferInModem[2] = Aint.b[1];
 576   3                      Bfloat.f= Vspeed; 
 577   3                      BufferInModem[3] = Bfloat.b[0];
 578   3                      BufferInModem[4] = Bfloat.b[1];
 579   3                      BufferInModem[5] = Bfloat.b[2];
 580   3                      BufferInModem[6] = Bfloat.b[3];
 581   3                      Bfloat.f= Angle;
 582   3                      BufferInModem[7] = Bfloat.b[0];
 583   3                      BufferInModem[8] = Bfloat.b[1];
 584   3                      BufferInModem[9] = Bfloat.b[2];
 585   3                      BufferInModem[10] = Bfloat.b[3];
 586   3                      BufferInModem[11] = 0x40;
 587   3      
 588   3                      BufferInModem[12] = 0;
 589   3                      for (i = 0; i < 12; i++ )
 590   3                              BufferInModem[12] = BufferInModem[12] ^ BufferInModem[i];
 591   3                      BufferInModem[12] = 0x80 | BufferInModem[12];
 592   3      
 593   3                      flTransmiter = 1;
 594   3              
 595   3              r0 = 0;
 596   3              rk = 13;
 597   3                      SFRPAGE = 0x00;
 598   3      
 599   3                      while (flTransmiter)
 600   3                      {
 601   4                              if(r0 < rk)
 602   4                              {
 603   5                                      flTransmiter = 1;
 604   5                                      SBUF0 = BufferInModem[r0++];
 605   5                              }
 606   4                              else
 607   4                              {
 608   5                                      flTransmiter = 0;
 609   5                              }
 610   4                      }
 611   3      //              ES0=0;
 612   3      }
 613   2              //------------------------------------------------------------
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 11  

 614   2              }
 615   1      /*
 616   1      //UART----------------------------
 617   1              rBFM = wBFM = marBFM = 0;
 618   1              for(PWM = 1; PWM < 15; PWM++)
 619   1              {
 620   1                      Value = 37500;
 621   1                      write(PWM+112, Value);
 622   1              }
 623   1      
 624   1              while(1)
 625   1              {
 626   1              if(rBFM < wBFM+marBFM*NBFM)
 627   1              {
 628   1                              if ((BuferFromModem[rBFM] & 0xC0) == 0x40)
 629   1                              {
 630   1                                      nByte = 0;
 631   1                                      KontrSumma = 0;
 632   1                                      PWM = BuferFromModem[rBFM] & 0x3f;
 633   1                              }
 634   1                              if (nByte > 25)
 635   1                                      nByte = 25;
 636   1                              RK_code[nByte] = BuferFromModem[rBFM] & 0x7f;
 637   1                              KontrSumma = KontrSumma^RK_code[nByte++];
 638   1      
 639   1                              if ( (nByte == 5) && (KontrSumma == 0) )
 640   1                              {
 641   1                                      Value = RK_code[1]+((unsigned int)RK_code[2] << 7)+((unsigned int)RK_code[3] << 14);
 642   1                                      write(PWM+112, Value);
 643   1                              }
 644   1      
 645   1               rBFM++;
 646   1                              if(rBFM >= NBFM)
 647   1                              {
 648   1                              rBFM = 0;
 649   1                                      marBFM = 0;
 650   1                              }
 651   1            }
 652   1                                      //-----------------------------------------------------------------------------------
 653   1                      if(flNewGPS)    
 654   1                      {
 655   1                              flNewGPS = 0;
 656   1               OutModem20();
 657   1      
 658   1                              if (RegimeKren == 0 || RegimeStart == 0) //не ручное управление
 659   1                                      break; 
 660   1      start1:
 661   1                              dz = LonMar[n_];
 662   1                              dz = 0.1856*(dz - LonFly)*cos_Lat0;
 663   1                         dx = LatMar[n_];
 664   1                         dx = 0.1856*(dx-LatFly);
 665   1      
 666   1      //                      if(RegimeKren)//автономный полет
 667   1      //                      {
 668   1                              dz_pr = LonMar[n_-1];
 669   1                                 dz_pr = 0.1856*(dz_pr-LonFly)*cos_Lat0;
 670   1                              dx_pr = LatMar[n_-1];
 671   1                              dx_pr = 0.1856*(dx_pr-LatFly);
 672   1      
 673   1                                 tmp =sqrt(dz*dz+dx*dx);              //tmp = rasst_toch_mar
 674   1                              if ((EPSILON > tmp) && (n_ != i_mar) && (n_ != 0))
 675   1                                 {
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 12  

 676   1                              if ((n_ == i_mar-2) && (fabs(H_dat-100) > 50))
 677   1                                      ;
 678   1                              else
 679   1                              {
 680   1                                      n_++;
 681   1                                      flCommand = 1;
 682   1      
 683   1                                      if (RegimeV == 2)
 684   1                              Vz_zad = Vz_Mar[n_];
 685   1                                      if (RegimeVy == 2)
 686   1                              H_zad_buf = H_Mar[n_];
 687   1                                      goto start1;
 688   1                              }
 689   1      //                      }
 690   1      
 691   1                         if ( (fabs(dx-dx_pr) <= FLT_EPSILON) && (fabs(dz-dz_pr) <= FLT_EPSILON) )
 692   1                              napr_vetv_mar = 0;
 693   1                              else
 694   1                              napr_vetv_mar = atan2(dz-dz_pr, dx-dx_pr);
 695   1      
 696   1                      if ( (fabs(dx) <= FLT_EPSILON) && (fabs(dz) <= FLT_EPSILON) )
 697   1                              angle = 0;
 698   1                      else
 699   1                              angle = atan2(dz, dx);  //napr_toch_mar = atan2(dz, dx),
 700   1                      angle = angle-napr_vetv_mar;
 701   1      
 702   1                                 otkl_ot_mar = tmp*sin(angle);
 703   1                                      if (fabs(otkl_ot_mar) > 500) tmp = 200; //tmp = l_km
 704   1                                      else                         tmp = 500;
 705   1                                 dz = otkl_ot_mar*cos(napr_vetv_mar)+tmp*sin(napr_vetv_mar);  //dz = z_toch_pricel
 706   1                              dx = -otkl_ot_mar*sin(napr_vetv_mar)+tmp*cos(napr_vetv_mar);    //dx = x_toch_pricel
 707   1                              }
 708   1                              tmp = koors;
 709   1                              tmp =  -tmp/ToGrad;
 710   1                      if ( (fabs(dx) > FLT_EPSILON) && (fabs(dz) > FLT_EPSILON) )
 711   1                                      tmp =  tmp + atan2(dz, dx);
 712   1      
 713   1                         while (tmp > M_PI)
 714   1                      tmp -= D_PI;
 715   1                         while (tmp < -M_PI)
 716   1                      tmp += D_PI;
 717   1      
 718   1                         tmp = ToGrad*tmp;            
 719   1                              if(tmp > 42)
 720   1                                      tmp = 42;
 721   1                         else if(tmp < -42)
 722   1                                      tmp = -42;
 723   1                              kren_zad_buf = tmp;
 724   1                      }
 725   1            else if (liTimer_tick-liTimer_tick_GPS > 2*FREQ) //Отсутствие координат
 726   1                      {
 727   1                              flNoKoord = 1;
 728   1                              liTimer_tick_GPS = liTimer_tick;        
 729   1               OutModem20();
 730   1                      }
 731   1      
 732   1                      //Расшифровка посылки GPS
 733   1                      if (r < w+mar*NS) 
 734   1                      {
 735   1                              if(mess[r] == '$')
 736   1                              {
 737   1                  nLetter = 0;
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 13  

 738   1                              }
 739   1               else if ((nLetter == 0) && (mess[r] == 'G'))
 740   1                  nLetter++;
 741   1               else if ((nLetter == 1) && (mess[r] == 'P'))
 742   1                  nLetter++;
 743   1               else if ((nLetter == 2) && (mess[r] == 'R'))
 744   1                  nLetter++;
 745   1               else if ((nLetter == 3) && (mess[r] == 'M'))
 746   1                  nLetter++;
 747   1               else if ((nLetter == 4) && (mess[r] == 'C'))
 748   1               {
 749   1                  nLetter++;
 750   1                                      i_comma = 0;
 751   1                                      ValidGPS = 0;
 752   1               } 
 753   1                         else if(mess[r] == ',')
 754   1                              {
 755   1                                      i_comma++;
 756   1                                      i = 0;
 757   1                                      flPoint = 0;
 758   1                              }
 759   1                         else if(i_comma == 2)
 760   1                              {
 761   1                                      if(mess[r] == 'A') 
 762   1                                              ValidGPS = 1;
 763   1                                      else
 764   1                                      {
 765   1                                              ValidGPS = 0;
 766   1      //                                      flNoKoord = 1;
 767   1      //                                      liTimer_tick_GPS = liTimer_tick;
 768   1                                      }
 769   1                              }
 770   1               else if (ValidGPS)
 771   1                              {
 772   1                                      if (i_comma == 3)                //Latitude
 773   1                                      {
 774   1                                              if(mess[r] == '.')
 775   1                                              {
 776   1                                                      flPoint = 1;
 777   1                                                      i = 0;
 778   1                                              }
 779   1                                              else if (flPoint == 0)                  //Целая часть
 780   1                                              {
 781   1                                                      tmpGPS[i++] = mess[r];
 782   1                                                      if(i == 2)
 783   1                                                      {
 784   1                                         tmpGPS[i] = 0;
 785   1                                                              temp_koord = atoi(tmpGPS);
 786   1                                      temp_koord = 60UL*10000*temp_koord;
 787   1                                                      }       
 788   1                                                      else if(i == 4)
 789   1                                                      {
 790   1                                                              tmpGPS[0] = tmpGPS[1] = '0';
 791   1                                         tmpGPS[i] = 0;
 792   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 793   1                                                      }       
 794   1                                              }
 795   1                                              else                                    //Дробная часть
 796   1                                              {
 797   1                                                      tmpGPS[i++] = mess[r];
 798   1                                 tmpGPS[i] = 0;
 799   1                                              }
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 14  

 800   1                                      }
 801   1                                      else if (i_comma == 4)
 802   1                                      {
 803   1                              temp_koord = temp_koord+atoi(tmpGPS);
 804   1      //-----------
 805   1      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 806   1      //--------
 807   1                                              if (mess[r] == 'S')                             //знак Latitude
 808   1                                                      LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 809   1                                              else              
 810   1                                                      LatFly = 54000000UL+temp_koord; //90UL*60*10000+koord;
 811   1                                      }
 812   1                                      else if (i_comma == 5)                //Longitude
 813   1                                      {
 814   1                                              if(mess[r] == '.')
 815   1                                              {
 816   1                                                      flPoint = 1;
 817   1                                                      i = 0;
 818   1                                              }
 819   1                                              else if (flPoint == 0)                  //Целая часть
 820   1                                              {
 821   1                                                      tmpGPS[i++] = mess[r];
 822   1                                                      if(i == 3)
 823   1                                                      {
 824   1                                         tmpGPS[i] = 0;
 825   1                                      temp_koord = atoi(tmpGPS);
 826   1                                      temp_koord = 60UL*10000*temp_koord;
 827   1                                                      }       
 828   1                                                      else if(i == 5)
 829   1                                                      {
 830   1                                                              tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 831   1                                         tmpGPS[i] = 0;
 832   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 833   1                                                      }       
 834   1                                              }
 835   1                                              else                                    //Дробная часть
 836   1                                              {
 837   1                                                      tmpGPS[i++] = mess[r];
 838   1                                 tmpGPS[i] = 0;
 839   1                                              }
 840   1                                      }
 841   1                                      else if (i_comma == 6)
 842   1                                      {
 843   1                              temp_koord = temp_koord+atoi(tmpGPS);
 844   1      //----------------
 845   1      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 846   1      //----------------
 847   1                                              if (mess[r] == 'W')   //знак Longitude
 848   1                                                      LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 849   1                                              else       
 850   1                                                      LonFly = temp_koord+108000000UL;        //180UL*60*10000;
 851   1                                      }
 852   1                                      else if (i_comma == 7)  //скорость в узлах
 853   1                                      {
 854   1                                              if(mess[r] == '.')
 855   1                                              {
 856   1                                                      flPoint = 1;
 857   1                              Vz = 1.852*atoi(tmpGPS)/3.6;   //??? Преобразовать из узлов в м/с
 858   1      //---------
 859   1      //Vz = 20;
 860   1      //-----------
 861   1                                              }
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 15  

 862   1                                              else if(flPoint == 0)
 863   1                                              {
 864   1                                                      tmpGPS[i++] = mess[r];
 865   1                              tmpGPS[i] = 0;
 866   1                                              }
 867   1                  }
 868   1                                      else if (i_comma == 8)  //курс в градусах
 869   1                                      {
 870   1                                              if(mess[r] == '.')
 871   1                                              {
 872   1                                                      flPoint = 1;
 873   1                              koors = atoi(tmpGPS);
 874   1                        if (koors < 0)
 875   1                           koors = 360+koors;
 876   1      
 877   1                                                      flNoKoord = 0;
 878   1                                                      flNewGPS = 1;
 879   1                                                      liTimer_tick_GPS = liTimer_tick;        
 880   1                                  OutModem20();
 881   1      //-----------                                              
 882   1      //koors = 30;
 883   1      //-----------
 884   1                                              }
 885   1                                              else if(flPoint == 0)
 886   1                                              {
 887   1                                                      tmpGPS[i++] = mess[r];
 888   1                              tmpGPS[i] = 0;
 889   1                                              }
 890   1                  }
 891   1                              }
 892   1                              r++;
 893   1                      if(r >= NS)
 894   1                              {
 895   1                      r = 0;
 896   1                                      mar = 0;        
 897   1                              }      
 898   1                      }
 899   1      
 900   1      
 901   1              }       
 902   1      */      
 903   1      //-----------------
 904   1      
 905   1      }
*** WARNING C280 IN LINE 186 OF SERVO.C: 'RK_code': unreferenced local variable
*** WARNING C280 IN LINE 186 OF SERVO.C: 'PWM': unreferenced local variable
*** WARNING C280 IN LINE 187 OF SERVO.C: 'Value': unreferenced local variable
 906          
 907          //------------------------------------------------------------------------------------------
 908          //скорость ветра
 909          void INT0 (void) interrupt 0
 910          {
 911   1              VeterFlag = 1;
 912   1              TV = RTC - RTCV;
 913   1              RTCV = RTC;;
 914   1              EX0=0;
 915   1              return;
 916   1      }
 917          
 918          //------------------------------------------------------------------------------------
 919          void TIMER_ISR0 (void) interrupt 1
 920          {
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 16  

 921   1              xdata unsigned int i, delta, FdKoeff;
 922   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 923   1              SFRPAGE = TIMER01_PAGE;
 924   1              RTC++;
 925   1      //ветер-------------
 926   1              if(WSpeed!=0)
 927   1                      EX0=1;
 928   1      
 929   1              if(WAngle!=0)
 930   1                      EX1=1;
 931   1      //-------------------
 932   1              u0timer++; // COM u0
 933   1      //      u1timer++; // GPS u1
 934   1      //-------------------
 935   1              SFRPAGE = SFRPAGE_SAVE;
 936   1              return;
 937   1      }
*** WARNING C280 IN LINE 921 OF SERVO.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 921 OF SERVO.C: 'delta': unreferenced local variable
*** WARNING C280 IN LINE 921 OF SERVO.C: 'FdKoeff': unreferenced local variable
 938          
 939          
 940          
 941          //направление ветра-------------------------------------------------------------------
 942          void INT1 (void) interrupt 2
 943          {
 944   1              VeterFlag = 1;
 945   1              TA = RTC - RTCA;
 946   1              RTCA = RTC;
 947   1              EX1=0;
 948   1              return;
 949   1      }
 950          
 951          //------------------------------------------------------------------------------------
 952          void TIMER_ISR1 (void) interrupt 3
 953          {
 954   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 955   1              SFRPAGE = TIMER01_PAGE;
 956   1              
 957   1              SFRPAGE = SFRPAGE_SAVE;
 958   1              return;
 959   1      }
 960          
 961          //-------------------------------------------------------------------
 962          void COM_UART0_isr(void) interrupt 4
 963          {
 964   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 965   1              INT Aint;
 966   1              SFRPAGE = UART0_PAGE;
 967   1      
 968   1              if (RI0)
 969   1              {
 970   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 971   2                      if(wBFM >= NBFM)
 972   2                      {
 973   3                      wBFM = 0;
 974   3                              marBFM = 1;
 975   3                      }/*
 976   2                      if(BuferFromModem [wBFM-1]==0x41)
 977   2                      {
 978   2                              if(BuferFromModem [wBFM-4]==0x40)
 979   2                              {
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 17  

 980   2                                      Aint.b[0] = BuferFromModem[wBFM-3];
 981   2                                      Aint.b[1] = BuferFromModem[wBFM-2];
 982   2                                      if(Aint.i<=0x0fff)
 983   2                                      {
 984   2                                              LirTarget = Aint.i;
 985   2                                      }
 986   2                              }       
 987   2                      }*/
 988   2                      RI0 = 0;
 989   2              }
 990   1              if (TI0)
 991   1              {
 992   2                              
 993   2      
 994   2              }
 995   1      
 996   1              SFRPAGE = UART1_PAGE;
 997   1              if (RI1)
 998   1              {
 999   2                      flNewGPS = 1;
1000   2                      mess [w++] = SBUF1;  // read character
1001   2                      if(w >= NS)
1002   2                      {
1003   3                      w = 0;
1004   3                              mar = 1;
1005   3                      }
1006   2                      RI1 = 0;
1007   2              }
1008   1              SFRPAGE = SFRPAGE_SAVE;
1009   1              return;
1010   1      }
*** WARNING C280 IN LINE 965 OF SERVO.C: 'Aint': unreferenced local variable
1011          void Timer2_ISR interrupt 5
1012          {
*** ERROR C136 IN LINE 1012 OF SERVO.C: 'Timer2_ISR': 'void' on variable
*** ERROR C129 IN LINE 1012 OF SERVO.C: missing ';' before '{'
1013                  xdata char SFRPAGE_SAVE = SFRPAGE;
1014                  SFRPAGE = 0x00;
1015          
1016                  SFRPAGE = SFRPAGE_SAVE;
1017                  return;
1018          }
1019          //------------------------------------------------------------------------------------
1020          void SMBus_isr interrupt 7
1021          {
1022                  xdata char SFRPAGE_SAVE = SFRPAGE;
1023                  SFRPAGE = SMB0_PAGE;
1024          
1025                  SFRPAGE = SFRPAGE_SAVE;
1026                  return;
1027          }
1028          
1029          //------------------------------------------------------------------------------------
1030          void PCA_isr(void) interrupt 9
1031          {
1032                  xdata int a;
1033                  xdata char SFRPAGE_SAVE = SFRPAGE;
1034                  SFRPAGE = PCA0_PAGE;
1035                  
1036                  a=0;
1037                  CF = 0;
1038          
C51 COMPILER V9.00   SERVO                                                                 08/17/2012 15:08:36 PAGE 18  

1039                  SFRPAGE = SFRPAGE_SAVE;
1040                  return;
1041          }
1042          //------------------------------------------------------------------------------------
1043          void TIMER_ISR3 (void) interrupt 14
1044          {
1045                  xdata char SFRPAGE_SAVE = SFRPAGE;
1046                  SFRPAGE = TMR3_PAGE;
1047          
1048                  SFRPAGE = SFRPAGE_SAVE;
1049                  return;
1050          }
1051          //-------------------------------------------------------------------
1052          void GPS_UART1_isr(void) interrupt 20
1053          {
1054                  xdata char SFRPAGE_SAVE = SFRPAGE;
1055                  SFRPAGE = UART1_PAGE;
1056                  if (RI1)
1057                  {
1058                          flNewGPS = 1;
1059                          mess [w++] = SBUF1;  // read character
1060                          if(w >= NS)
1061                          {
1062                          w = 0;
1063                                  mar = 1;
1064                          }
1065                          RI1 = 0;
1066                  }
1067                  if (TI1)
1068                  {
1069                                  
1070                  }
1071          
1072                  SFRPAGE = SFRPAGE_SAVE;
1073                  return;
1074          }
1075          //------------------------------------------------------------------------------------------
1076          //#endif

C51 COMPILATION COMPLETE.  7 WARNING(S),  2 ERROR(S)
