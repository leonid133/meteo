C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO2
OBJECT MODULE PLACED IN servo2.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo2.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "init.h"
   3          #include "comport.h"
   4          #include <intrins.h>
   5          #include <ctype.h>
   6          #include <stdio.h>
   7          #include <stdlib.h>
   8          #include "servo.h"                     
   9          
  10          #define SYSCLK 24500000 //Hz
  11          #define FREQT0 8006 //Hz
  12          
  13          //отладочные
  14          sbit LED = P1^6;
  15          sbit LED2 = P2^6;
  16          sbit BUTTON = P3^7;
  17          xdata unsigned char InitFlag;
  18          //--------------
  19          //лир
  20          sbit LIR_DATA = P2^2; //P2^0;
  21          sbit LIR_SCK = P2^1;
  22          
  23          xdata unsigned char F;
  24          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  25          
  26          typedef union INT {                   
  27             unsigned int i;
  28             unsigned char b[2];
  29          } INT;
  30          //---
  31          //ветер
  32          xdata unsigned char VeterFlag = 0;
  33          sbit WSpeed = P1^1;
  34          sbit WAngle = P1^3;
  35          
  36          xdata float Vspeed, Angle;
  37          xdata unsigned long RTC, RTCV, RTCA;
  38          xdata unsigned long TV,TA;
  39          
  40          typedef union FLOAT {                   
  41             float f;
  42             unsigned char b[4];
  43          } FLOAT;
  44          //-----
  45          //UART0
  46          #define NBFM            50
  47          xdata unsigned char BuferFromModem [NBFM]; 
  48          xdata unsigned char wBFM, rBFM, marBFM;
  49          xdata unsigned int u0timer;
  50          
  51          #define SIZE_BUFFER0            50
  52          xdata char BufferInModem[SIZE_BUFFER0]; // Для отправки в последовательный порт
  53          xdata int r0, rk;
  54          bit flTransmiter;       
  55          
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 2   

  56          //SMBus
  57          #define WRITE 0x00                  // SMBus WRITE command
  58          #define READ  0x01                  // SMBus READ command
  59          // Device addresses (7 bits, lsb is a don't care)
  60          #define CHIP_A 0x00                 // Device address for chip A
  61          #define CHIP_B 0x05                 // Device address for chip B
  62          #define CHIP_C 0xA4                 // Device address for chip C
  63          
  64          // SMBus states:
  65          // MT = Master Transmitter
  66          // MR = Master Receiver
  67          #define  SMB_BUS_ERROR  0x00        // (all modes) BUS ERROR
  68          #define  SMB_START      0x08        // (MT & MR) START transmitted
  69          #define  SMB_RP_START   0x10        // (MT & MR) repeated START
  70          #define  SMB_MTADDACK   0x18        // (MT) Slave address + W transmitted;
  71                                              //  ACK received
  72          #define  SMB_MTADDNACK  0x20        // (MT) Slave address + W transmitted;
  73                                              //  NACK received
  74          #define  SMB_MTDBACK    0x28        // (MT) data byte transmitted; ACK rec'vd
  75          #define  SMB_MTDBNACK   0x30        // (MT) data byte transmitted; NACK rec'vd
  76          #define  SMB_MTARBLOST  0x38        // (MT) arbitration lost
  77          #define  SMB_MRADDACK   0x40        // (MR) Slave address + R transmitted;
  78                                              //  ACK received
  79          #define  SMB_MRADDNACK  0x48        // (MR) Slave address + R transmitted;
  80                                              //  NACK received
  81          #define  SMB_MRDBACK    0x50        // (MR) data byte rec'vd; ACK transmitted
  82          #define  SMB_MRDBNACK   0x58        // (MR) data byte rec'vd; NACK transmitted
  83          
  84          char COMMAND;                       // Holds the slave address + R/W bit for
  85                                              // use in the SMBus ISR.
  86          
  87          char WORD;                          // Holds data to be transmitted by the SMBus
  88                                              // OR data that has just been received.
  89          
  90          char BYTE_NUMBER;                   // Used by ISR to check what data has just been
  91                                              // sent - High address byte, Low byte, or data
  92                                              // byte
  93          
  94          unsigned char HIGH_ADD, LOW_ADD;    // High & Low byte for EEPROM memory address
  95          
  96          bit SM_BUSY;                        // This bit is set when a send or receive
  97                                              // is started. It is cleared by the
  98                                              // ISR when the operation is finished.
  99          
 100          xdata unsigned int Humidity, Temperature, i_measure;
 101          
 102          //GPS
 103          #define NS      75
 104          xdata unsigned int GPStimepulse;
 105          xdata char mess [NS], r, w, mar;                // Для анализа посылки GPS
 106          bit flNewGPS;
 107          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
 108          xdata unsigned long LatFly, LonFly;
 109          
 110          /***********************************************************************************
 111          Project:          SHT1x/7x demo program (V2.4)
 112          Filename:         SHT1x_sample_code.c    
 113          
 114          Prozessor:        80C51 family
 115          Compiler:         Keil Version 6.23a
 116          
 117          Autor:            MST
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 3   

 118          Copyrigth:        (c) Sensirion AG      
 119          ***********************************************************************************/
 120          // Revisions:
 121          // V2.4  calc_sht11()       Coefficients for humidity and temperature conversion 
 122          //                          changed (for V4 sensors)
 123          //       calc_dewpoint()        New formula for dew point calculation 
 124          #include <math.h>    //Keil library 
 125          
 126          typedef union 
 127          { unsigned int i;
 128            float f;
 129          } value;
 130          
 131          //----------------------------------------------------------------------------------
 132          // modul-var
 133          //----------------------------------------------------------------------------------
 134          enum {TEMP,HUMI};
 135          
 136          #define DATA    LED
 137          #define SCK     LED2
 138          
 139          #define noACK 0
 140          #define ACK   1
 141                                      //adr  command  r/w
 142          #define STATUS_REG_W 0x06   //000   0011    0
 143          #define STATUS_REG_R 0x07   //000   0011    1
 144          #define MEASURE_TEMP 0x03   //000   0001    1
 145          #define MEASURE_HUMI 0x05   //000   0010    1
 146          #define RESET        0x1e   //000   1111    0
 147          
 148          //----------------------------------------------------------------------------------
 149          char s_write_byte(unsigned char value)
 150          //----------------------------------------------------------------------------------
 151          // writes a byte on the Sensibus and checks the acknowledge 
 152          { 
 153   1        unsigned char i,error=0;  
 154   1        for (i=0x80;i>0;i/=2)             //shift bit for masking
 155   1        { if (i & value) DATA=1;          //masking value with i , write to SENSI-BUS
 156   2          else DATA=0;                        
 157   2          _nop_();                        //observe setup time
 158   2          SCK=1;                          //clk for SENSI-BUS
 159   2          _nop_();_nop_();_nop_();        //pulswith approx. 5 us     
 160   2          SCK=0;
 161   2          _nop_();                         //observe hold time
 162   2        }
 163   1        DATA=1;                           //release DATA-line
 164   1        _nop_();                          //observe setup time
 165   1        SCK=1;                            //clk #9 for ack 
 166   1        error=DATA;                       //check ack (DATA will be pulled down by SHT11)
 167   1        SCK=0;        
 168   1        return error;                     //error=1 in case of no acknowledge
 169   1      }
 170          
 171          //----------------------------------------------------------------------------------
 172          char s_read_byte(unsigned char ack)
 173          //----------------------------------------------------------------------------------
 174          // reads a byte form the Sensibus and gives an acknowledge in case of "ack=1" 
 175          { 
 176   1        unsigned char i,val=0;
 177   1        DATA=1;                           //release DATA-line
 178   1        for (i=0x80;i>0;i/=2)             //shift bit for masking
 179   1        { SCK=1;                          //clk for SENSI-BUS
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 4   

 180   2          if (DATA) val=(val | i);        //read bit  
 181   2          SCK=0;                                       
 182   2        }
 183   1        DATA=!ack;                        //in case of "ack==1" pull down DATA-Line
 184   1        _nop_();                          //observe setup time
 185   1        SCK=1;                            //clk #9 for ack
 186   1        _nop_();_nop_();_nop_();          //pulswith approx. 5 us 
 187   1        SCK=0;
 188   1        _nop_();                          //observe hold time                                             
 189   1        DATA=1;                           //release DATA-line
 190   1        return val;
 191   1      }
 192          
 193          //----------------------------------------------------------------------------------
 194          void s_transstart(void)
 195          //----------------------------------------------------------------------------------
 196          // generates a transmission start 
 197          //       _____         ________
 198          // DATA:      |_______|
 199          //           ___     ___
 200          // SCK : ___|   |___|   |______
 201          {  
 202   1         DATA=1; SCK=0;                   //Initial state
 203   1         _nop_();
 204   1         SCK=1;
 205   1         _nop_();
 206   1         DATA=0;
 207   1         _nop_();
 208   1         SCK=0;  
 209   1         _nop_();_nop_();_nop_();
 210   1         SCK=1;
 211   1         _nop_();
 212   1         DATA=1;                 
 213   1         _nop_();
 214   1         SCK=0;                  
 215   1      }
 216          
 217          //----------------------------------------------------------------------------------
 218          void s_connectionreset(void)
 219          //----------------------------------------------------------------------------------
 220          // communication reset: DATA-line=1 and at least 9 SCK cycles followed by transstart
 221          //       _____________________________________________________         ________
 222          // DATA:                                                      |_______|
 223          //          _    _    _    _    _    _    _    _    _        ___     ___
 224          // SCK : __| |__| |__| |__| |__| |__| |__| |__| |__| |______|   |___|   |______
 225          {  
 226   1        unsigned char i; 
 227   1        DATA=1; SCK=0;                    //Initial state
 228   1        for(i=0;i<9;i++)                  //9 SCK cycles
 229   1        { SCK=1;
 230   2          SCK=0;
 231   2        }
 232   1        s_transstart();                   //transmission start
 233   1      }
 234          
 235          //----------------------------------------------------------------------------------
 236          char s_softreset(void)
 237          //----------------------------------------------------------------------------------
 238          // resets the sensor by a softreset 
 239          { 
 240   1        unsigned char error=0;  
 241   1        s_connectionreset();              //reset communication
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 5   

 242   1        error+=s_write_byte(RESET);       //send RESET-command to sensor
 243   1        return error;                     //error=1 in case of no response form the sensor
 244   1      }
 245          
 246          //----------------------------------------------------------------------------------
 247          char s_read_statusreg(unsigned char *p_value, unsigned char *p_checksum)
 248          //----------------------------------------------------------------------------------
 249          // reads the status register with checksum (8-bit)
 250          { 
 251   1        unsigned char error=0;
 252   1        s_transstart();                   //transmission start
 253   1        error=s_write_byte(STATUS_REG_R); //send command to sensor
 254   1        *p_value=s_read_byte(ACK);        //read status register (8-bit)
 255   1        *p_checksum=s_read_byte(noACK);   //read checksum (8-bit)  
 256   1        return error;                     //error=1 in case of no response form the sensor
 257   1      }
 258          
 259          //----------------------------------------------------------------------------------
 260          char s_write_statusreg(unsigned char *p_value)
 261          //----------------------------------------------------------------------------------
 262          // writes the status register with checksum (8-bit)
 263          { 
 264   1        unsigned char error=0;
 265   1        s_transstart();                   //transmission start
 266   1        error+=s_write_byte(STATUS_REG_W);//send command to sensor
 267   1        error+=s_write_byte(*p_value);    //send value of status register
 268   1        return error;                     //error>=1 in case of no response form the sensor
 269   1      }
 270                                                                     
 271          //----------------------------------------------------------------------------------
 272          char s_measure(unsigned char *p_value, unsigned char *p_checksum, unsigned char mode)
 273          //----------------------------------------------------------------------------------
 274          // makes a measurement (humidity/temperature) with checksum
 275          { 
 276   1        unsigned char error=0;
 277   1        unsigned int i;
 278   1      
 279   1        s_transstart();                   //transmission start
 280   1        switch(mode){                     //send command to sensor
 281   2          case TEMP   : error+=s_write_byte(MEASURE_TEMP); break;
 282   2          case HUMI   : error+=s_write_byte(MEASURE_HUMI); break;
 283   2          default     : break;         
 284   2        }
 285   1        for (i=0;i<65535;i++) if(DATA==0) break; //wait until sensor has finished the measurement
 286   1        if(DATA) error+=1;                // or timeout (~2 sec.) is reached
 287   1        *(p_value)  =s_read_byte(ACK);    //read the first byte (MSB)
 288   1        *(p_value+1)=s_read_byte(ACK);    //read the second byte (LSB)
 289   1        *p_checksum =s_read_byte(noACK);  //read checksum
 290   1        return error;
 291   1      }
 292          
 293          //----------------------------------------------------------------------------------------
 294          void calc_sth11(float *p_humidity ,float *p_temperature)
 295          //----------------------------------------------------------------------------------------
 296          // calculates temperature [°C] and humidity [%RH] 
 297          // input :  humi [Ticks] (12 bit) 
 298          //          temp [Ticks] (14 bit)
 299          // output:  humi [%RH]
 300          //          temp [°C]
 301          { const float C1=-2.0468;           // for 12 Bit RH
 302   1        const float C2=+0.0367;           // for 12 Bit RH
 303   1        const float C3=-0.0000015955;     // for 12 Bit RH
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 6   

 304   1        const float T1=+0.01;             // for 12 Bit RH
 305   1        const float T2=+0.00008;          // for 12 Bit RH    
 306   1      
 307   1        float rh=*p_humidity;             // rh:      Humidity [Ticks] 12 Bit 
 308   1        float t=*p_temperature;           // t:       Temperature [Ticks] 14 Bit
 309   1        float rh_lin;                     // rh_lin:  Humidity linear
 310   1        float rh_true;                    // rh_true: Temperature compensated humidity
 311   1        float t_C;                        // t_C   :  Temperature [°C]
 312   1      
 313   1        t_C=t*0.01 - 40.1;                //calc. temperature [°C] from 14 bit temp. ticks @ 5V
 314   1        rh_lin=C3*rh*rh + C2*rh + C1;     //calc. humidity from ticks to [%RH]
 315   1        rh_true=(t_C-25)*(T1+T2*rh)+rh_lin;   //calc. temperature compensated humidity [%RH]
 316   1        if(rh_true>100)rh_true=100;       //cut if the value is outside of
 317   1        if(rh_true<0.1)rh_true=0.1;       //the physical possible range
 318   1      
 319   1        *p_temperature=t_C;               //return temperature [°C]
 320   1        *p_humidity=rh_true;              //return humidity[%RH]
 321   1      }
 322          
 323          //--------------------------------------------------------------------
 324          float calc_dewpoint(float h,float t)
 325          //--------------------------------------------------------------------
 326          // calculates dew point
 327          // input:   humidity [%RH], temperature [°C]
 328          // output:  dew point [°C]
 329          { float k,dew_point ;
 330   1        
 331   1        k = (log10(h)-2)/0.4343 + (17.62*t)/(243.12+t);
 332   1        dew_point = 243.12*k/(17.62-k);
 333   1        return dew_point;
 334   1      }
 335          
 336          //удалять до сюда-----------------------------------------------------------------------
 337          
 338          
 339          
 340          
 341          
 342          // SMBus byte write function-----------------------------------------------------
 343          // Writes a single byte at the specified memory location.
 344          //
 345          // out_byte = data byte to be written
 346          // byte_address = memory location to be written into (2 bytes)
 347          // chip_select = device address of EEPROM chip to be written to
 348          void SM_Send (char chip_select, unsigned int byte_address, char out_byte)
 349          {
 350   1         while (SM_BUSY);                          // Wait for SMBus to be free.
 351   1         SM_BUSY = 1;                              // Occupy SMBus (set to busy)
 352   1         SMB0CN = 0x44;                            // SMBus enabled,
 353   1                                                   // ACK on acknowledge cycle
 354   1      
 355   1         BYTE_NUMBER = 2;                          // 2 address bytes.
 356   1         COMMAND = (chip_select | WRITE);          // Chip select + WRITE
 357   1      
 358   1         HIGH_ADD = ((byte_address >> 8) & 0x00FF);// Upper 8 address bits
 359   1         LOW_ADD = (byte_address & 0x00FF);        // Lower 8 address bits
 360   1      
 361   1         WORD = out_byte;                          // Data to be writen
 362   1         
 363   1         STO = 0;
 364   1         STA = 1;                                  // Start transfer
 365   1      }
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 7   

 366          
 367          // SMBus random read function------------------------------------------------------
 368          // Reads 1 byte from the specified memory location.
 369          //
 370          // byte_address = memory address of byte to read
 371          // chip_select = device address of EEPROM to be read from
 372          char SM_Receive (char chip_select, unsigned int byte_address)
 373          {
 374   1         SFRPAGE   = SMB0_PAGE;
 375   1              while (SM_BUSY);                          // Wait for bus to be free.
 376   1         SM_BUSY = 1;                              // Occupy SMBus (set to busy)
 377   1              SMB0CN = 0x44;                            // SMBus enabled, ACK on acknowledge cycle
 378   1      
 379   1         BYTE_NUMBER = 2;                          // 2 address bytes
 380   1         COMMAND = (chip_select | READ);           // Chip select + READ
 381   1      
 382   1         HIGH_ADD = ((byte_address >> 8) & 0x00FF);// Upper 8 address bits
 383   1         LOW_ADD = (byte_address & 0x00FF);        // Lower 8 address bits
 384   1         
 385   1         STO = 0;
 386   1         STA = 1;                                  // Start transfer
 387   1         while (SM_BUSY);                          // Wait for transfer to finish
 388   1         return WORD;
 389   1      }
 390          //------------------------------------------------------------------------------
 391          /*
 392          void OutModem1(unsigned char Data, char i)
 393          {
 394                  BufferInModem[i] = Data | 0x80;
 395          }
 396          
 397          //------------------------------------------------------------------------------
 398          void OutModem2(unsigned int Data, char i)
 399          {
 400                  BufferInModem[i] = (Data & 0x007f)| 0x80;
 401                  BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
 402          }
 403          
 404          //------------------------------------------------------------------------------
 405          void OutModem4(unsigned long int Data, char i)
 406          {
 407                  BufferInModem[i] = (Data & 0x0000007f)| 0x80;
 408                  BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
 409                  BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
 410             BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
 411          }
 412          */
 413          //------------------------------------------------------------------------------------------
 414          void LirQ(void)
 415          {
 416   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 417   1              SFRPAGE = 0x00;
 418   1      
 419   1                      //Опрос ЛИР----------------------------
 420   1              //      EA=0;
 421   1                      LirData = 0x0000;
 422   1                      //---init
 423   1                      LIR_SCK = 1;
 424   1                      LIR_SCK = 0;
 425   1                      //---D n-1
 426   1                      LIR_SCK = 1;
 427   1                      LIR_SCK = 0;
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 8   

 428   1                      //---D n-1
 429   1                      LIR_SCK = 1;
 430   1                      LIR_SCK = 0;
 431   1                      if(LIR_DATA!=0) 
 432   1                      {
 433   2                              LirData = LirData | (0x1 << (11));
 434   2                      }
 435   1                      LIR_SCK = 1; 
 436   1                      LIR_SCK = 0;
 437   1                      if(LIR_DATA!=0) 
 438   1                      {
 439   2                              LirData = LirData | (0x1 << (10));
 440   2                      }
 441   1                      LIR_SCK = 1; 
 442   1                      LIR_SCK = 0;
 443   1                      if(LIR_DATA!=0) 
 444   1                      {
 445   2                              LirData = LirData | (0x1 << (9));
 446   2                      }
 447   1                      LIR_SCK = 1; 
 448   1                      LIR_SCK = 0;
 449   1                      if(LIR_DATA!=0) 
 450   1                      {
 451   2                              LirData = LirData | (0x1 << (8));
 452   2                      }
 453   1                      LIR_SCK = 1; 
 454   1                      LIR_SCK = 0;
 455   1                      if(LIR_DATA!=0) 
 456   1                      {
 457   2                              LirData = LirData | (0x1 << (7));
 458   2                      }
 459   1                      LIR_SCK = 1; 
 460   1                      LIR_SCK = 0;
 461   1                      if(LIR_DATA!=0) 
 462   1                      {
 463   2                              LirData = LirData | (0x1 << (6));
 464   2                      }
 465   1                      LIR_SCK = 1; 
 466   1                      LIR_SCK = 0;
 467   1                      if(LIR_DATA!=0) 
 468   1                      {
 469   2                              LirData = LirData | (0x1 << (5));
 470   2                      }
 471   1                      LIR_SCK = 1; 
 472   1                      LIR_SCK = 0;
 473   1                      if(LIR_DATA!=0) 
 474   1                      {
 475   2                              LirData = LirData | (0x1 << (4));
 476   2                      }
 477   1                      LIR_SCK = 1; 
 478   1                      LIR_SCK = 0;
 479   1                      if(LIR_DATA!=0) 
 480   1                      {
 481   2                              LirData = LirData | (0x1 << (3));
 482   2                      }
 483   1                      LIR_SCK = 1; 
 484   1                      LIR_SCK = 0;
 485   1                      if(LIR_DATA!=0) 
 486   1                      {
 487   2                              LirData = LirData | (0x1 << (2));
 488   2                      }
 489   1                      LIR_SCK = 1; 
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 9   

 490   1                      LIR_SCK = 0;
 491   1                      if(LIR_DATA!=0) 
 492   1                      {
 493   2                              LirData = LirData | (0x1 << (1));
 494   2                      }
 495   1                      LIR_SCK = 1; 
 496   1                      LIR_SCK = 0;
 497   1                      if(LIR_DATA!=0) 
 498   1                      {
 499   2                              LirData = LirData | (0x1 << (0));
 500   2                      }
 501   1                      LIR_SCK = 1; 
 502   1              //      EA=1;
 503   1              SFRPAGE = SFRPAGE_SAVE;
 504   1              return;
 505   1      }
 506          //------------------------------------------------------------------------------------------
 507          
 508          void main(void)
 509          {
 510   1      value humi_val,temp_val;
 511   1        float dew_point;
 512   1        unsigned char error,checksum;
 513   1        unsigned int i;
 514   1      
 515   1        init_uart();
*** WARNING C206 IN LINE 515 OF SERVO2.C: 'init_uart': missing function-prototype
 516   1        s_connectionreset();
 517   1        while(1)
 518   1        { error=0;
 519   2          error+=s_measure((unsigned char*) &humi_val.i,&checksum,HUMI);  //measure humidity
 520   2          error+=s_measure((unsigned char*) &temp_val.i,&checksum,TEMP);  //measure temperature
 521   2          if(error!=0) s_connectionreset();                 //in case of an error: connection reset
 522   2          else
 523   2          { humi_val.f=(float)humi_val.i;                   //converts integer to float
 524   3            temp_val.f=(float)temp_val.i;                   //converts integer to float
 525   3            calc_sth11(&humi_val.f,&temp_val.f);            //calculate humidity, temperature
 526   3            dew_point=calc_dewpoint(humi_val.f,temp_val.f); //calculate dew point
 527   3            printf("temp:%5.1fC humi:%5.1f%% dew point:%5.1fC\n",temp_val.f,humi_val.f,dew_point);
 528   3          }
 529   2          //----------wait approx. 0.8s to avoid heating up SHTxx------------------------------      
 530   2          for (i=0;i<40000;i++);     //(be sure that the compiler doesn't eliminate this line!)
 531   2          //-----------------------------------------------------------------------------------                 
             -      
 532   2        }
 533   1      
 534   1      /*
 535   1              //---------
 536   1              xdata unsigned int i;
 537   1              INT Aint;
 538   1              FLOAT Bfloat;
 539   1              //UART----------
 540   1         xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 541   1              unsigned int Value;
 542   1              //--------------
 543   1         bit ValidGPS, flPoint;       
 544   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 545   1              xdata unsigned long temp_koord;
 546   1              //SMBus---------
 547   1              unsigned char check;             // Used for testing purposes
 548   1              //--------------
 549   1      
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 10  

 550   1              Init_Device();
 551   1      
 552   1              LirTarget = 0x03ff;
 553   1              Fdelta = 0;
 554   1              flNewGPS = 0;
 555   1      
 556   1              SM_BUSY = 0;                     // Free SMBus for first transfer.
 557   1         while(1)
 558   1              {
 559   1              
 560   1              
 561   1      //расчет скорости ветра и угла--------------------------------------------------------------
 562   1                      if(VeterFlag)
 563   1                      {
 564   1                              Vspeed = (float)FREQT0/((float)TV*0.75);
 565   1                              Angle = 360. - (360.*(float)TV/(float)TA);
 566   1                              VeterFlag = 0;
 567   1                      }
 568   1      
 569   1      //Опрос GPS---------------------------------------------------------------------------
 570   1      
 571   1                      if(flNewGPS)    
 572   1                      {
 573   1                              flNewGPS = 0;
 574   1                      //Расшифровка посылки GPS
 575   1                              if (r < w+mar*NS) 
 576   1                              {
 577   1                                      if(mess[r] == '$')
 578   1                                      {
 579   1                      nLetter = 0;
 580   1                                      }
 581   1                      else if ((nLetter == 0) && (mess[r] == 'G'))
 582   1                      nLetter++;
 583   1                      else if ((nLetter == 1) && (mess[r] == 'P'))
 584   1                      nLetter++;
 585   1                      else if ((nLetter == 2) && (mess[r] == 'R'))
 586   1                      nLetter++;
 587   1                       else if ((nLetter == 3) && (mess[r] == 'M'))
 588   1                       nLetter++;
 589   1                 else if ((nLetter == 4) && (mess[r] == 'C'))
 590   1                      {
 591   1                      nLetter++;
 592   1                                              i_comma = 0;
 593   1                                              ValidGPS = 0;
 594   1                 } 
 595   1                              else if(mess[r] == ',')
 596   1                                      {
 597   1                                              i_comma++;
 598   1                                              i = 0;
 599   1                                              flPoint = 0;
 600   1                                      }
 601   1                              else if(i_comma == 2)
 602   1                                      {
 603   1                                              if(mess[r] == 'A') 
 604   1                                                      ValidGPS = 1;
 605   1                                              else
 606   1                                              {
 607   1                                                      ValidGPS = 0;
 608   1              //                                      flNoKoord = 1;
 609   1              //                                      liTimer_tick_GPS = liTimer_tick;
 610   1                                              }
 611   1                                      }
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 11  

 612   1                      else if (ValidGPS)
 613   1                                      {
 614   1                                              if (i_comma == 3)                                       //Latitude
 615   1                                              {
 616   1                                                      if(mess[r] == '.')
 617   1                                                      {
 618   1                                                              flPoint = 1;
 619   1                                                              i = 0;
 620   1                                                      }
 621   1                                                      else if (flPoint == 0)                                          //Целая часть
 622   1                                                      {
 623   1                                                              tmpGPS[i++] = mess[r];
 624   1                                                              if(i == 2)
 625   1                                                              {
 626   1                                              tmpGPS[i] = 0;
 627   1                                                                      temp_koord = atoi(tmpGPS);
 628   1                                              temp_koord = 60UL*10000*temp_koord;
 629   1                                                              }       
 630   1                                                              else if(i == 4)
 631   1                                                              {
 632   1                                                                      tmpGPS[0] = tmpGPS[1] = '0';
 633   1                                              tmpGPS[i] = 0;
 634   1                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 635   1                                                              }       
 636   1                                                      }
 637   1                                                      else                                                                                            //Дробная часть
 638   1                                                      {
 639   1                                                              tmpGPS[i++] = mess[r];
 640   1                                      tmpGPS[i] = 0;
 641   1                                                      }
 642   1                                              }
 643   1                                              else if (i_comma == 4)
 644   1                                              {
 645   1                                      temp_koord = temp_koord+atoi(tmpGPS);
 646   1      //-----------
 647   1      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 648   1      //--------
 649   1                                                      if (mess[r] == 'S')                                             //знак Latitude
 650   1                                                              LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 651   1                                                      else              
 652   1                                                              LatFly = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 653   1                                              }
 654   1                                              else if (i_comma == 5)                          //Longitude
 655   1                                              {
 656   1                                                      if(mess[r] == '.')
 657   1                                                      {
 658   1                                                              flPoint = 1;
 659   1                                                              i = 0;
 660   1                                                      }
 661   1                                                      else if (flPoint == 0)                                          //Целая часть
 662   1                                                      {
 663   1                                                              tmpGPS[i++] = mess[r];
 664   1                                                              if(i == 3)
 665   1                                                              {
 666   1                                              tmpGPS[i] = 0;
 667   1                                              temp_koord = atoi(tmpGPS);
 668   1                                              temp_koord = 60UL*10000*temp_koord;
 669   1                                                              }       
 670   1                                                              else if(i == 5)
 671   1                                                              {
 672   1                                                                      tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 673   1                                              tmpGPS[i] = 0;
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 12  

 674   1                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 675   1                                                              }       
 676   1                                                      }
 677   1                                                      else                                                                                            //Дробная часть
 678   1                                                      {
 679   1                                                              tmpGPS[i++] = mess[r];
 680   1                                      tmpGPS[i] = 0;
 681   1                                                      }
 682   1                                              }
 683   1                                              else if (i_comma == 6)
 684   1                                              {
 685   1                                      temp_koord = temp_koord+atoi(tmpGPS);
 686   1      //----------------
 687   1      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 688   1      //----------------
 689   1                                                      if (mess[r] == 'W')                                             //знак Longitude
 690   1                                                              LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 691   1                                                      else       
 692   1                                                              LonFly = temp_koord+108000000UL;                //180UL*60*10000;
 693   1                                              }
 694   1                                              else if (i_comma == 7)                                                  //скорость в узлах
 695   1                                              {
 696   1                                                      if(mess[r] == '.')
 697   1                                                      {
 698   1                                                              flPoint = 1;
 699   1                                      Vz = 1.852*atoi(tmpGPS)/3.6;            //Преобразовать из узлов в м/с
 700   1      //---------
 701   1      //Vz = 20;
 702   1      //-----------
 703   1                                                      }
 704   1                                                      else if(flPoint == 0)
 705   1                                                      {
 706   1                                                              tmpGPS[i++] = mess[r];
 707   1                                      tmpGPS[i] = 0;
 708   1                                                      }
 709   1                      }
 710   1                                              else if (i_comma == 8)                                                  //курс в градусах
 711   1                                              {
 712   1                                                      if(mess[r] == '.')
 713   1                                                      {
 714   1                                                              flPoint = 1;
 715   1                                      koors = atoi(tmpGPS);
 716   1                              if (koors < 0)
 717   1                              koors = 360+koors;
 718   1                                                              flNoKoord = 0;
 719   1                                                              flNewGPS = 1;
 720   1                                                              liTimer_tick_GPS = liTimer_tick;        
 721   1              //                          OutModem20();
 722   1      //-----------                                              
 723   1      //koors = 30;
 724   1      //-----------
 725   1                                                      }
 726   1                                                      else if(flPoint == 0)
 727   1                                                      {
 728   1                                                              tmpGPS[i++] = mess[r];
 729   1                                      tmpGPS[i] = 0;
 730   1                                                      }
 731   1                          }
 732   1                                      }
 733   1                                      r++;
 734   1                              if(r >= NS)
 735   1                                      {
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 13  

 736   1                              r = 0;
 737   1                                              mar = 0;        
 738   1                                      }      
 739   1                              }
 740   1                      }
 741   1              
 742   1      //Опрос SMBus-------------------------------------------------------------------------
 743   1      
 744   1      if(u0timer>0xf0)
 745   1      {
 746   1              SM_Send(CHIP_A, 0x00, 0x1e);      // Send CHIP, address, (data)
 747   1      //      SM_Send(CHIP_A, 0x00, 0x05);      // Send CHIP, address, (data)
 748   1      //      while(SMB0DAT!=0); 
 749   1      //      check = SM_Receive(CHIP_A, 0x00); // Read address on CHIP
 750   1      }
 751   1      
 752   1      
 753   1      //Работа с COM портом-----------------------------------------------------------------
 754   1      
 755   1                      if(u0timer>0xf0)
 756   1                      {
 757   1                              u0timer = 0;
 758   1                              //      ES0=1;
 759   1                              if(wBFM > 4)
 760   1                              {
 761   1                                      if(BuferFromModem [wBFM-1]==0x41)
 762   1                                      {
 763   1                                              if(BuferFromModem [wBFM-4]==0x40)
 764   1                                              {
 765   1                                                      Aint.b[0] = BuferFromModem[wBFM-3];
 766   1                                                      Aint.b[1] = BuferFromModem[wBFM-2];
 767   1                                                      if(Aint.i<=0x0fff)
 768   1                                                      {
 769   1                                                              LirTarget = Aint.i;
 770   1                                                      }
 771   1                                              }       
 772   1                                      }
 773   1                                      wBFM = 0;
 774   1                              }
 775   1                              //      TI0 = 1; //Read redy UART0
 776   1                              //Write to UART0--------------------------------------
 777   1                              Aint.i = LirData;
 778   1                              BufferInModem[0] = 0x40+1;
 779   1                              BufferInModem[1] = Aint.b[0];           
 780   1                              BufferInModem[2] = Aint.b[1];
 781   1                              Bfloat.f= Vspeed; 
 782   1                              BufferInModem[3] = Bfloat.b[0];
 783   1                              BufferInModem[4] = Bfloat.b[1];
 784   1                              BufferInModem[5] = Bfloat.b[2];
 785   1                              BufferInModem[6] = Bfloat.b[3];
 786   1                              Bfloat.f= Angle;
 787   1                              BufferInModem[7] = Bfloat.b[0];
 788   1                              BufferInModem[8] = Bfloat.b[1];
 789   1                              BufferInModem[9] = Bfloat.b[2];
 790   1                              BufferInModem[10] = Bfloat.b[3];
 791   1                              BufferInModem[11] = 0x40;
 792   1                         BufferInModem[12] = 0;
 793   1                      for (i = 0; i < 12; i++ )
 794   1                              BufferInModem[12] = BufferInModem[12] ^ BufferInModem[i];
 795   1                      BufferInModem[12] = 0x80 | BufferInModem[12];
 796   1      
 797   1                              flTransmiter = 1;
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 14  

 798   1              
 799   1                      r0 = 0;
 800   1                              rk = 13;
 801   1                              SFRPAGE = 0x00;
 802   1      
 803   1                              while (flTransmiter)
 804   1                              {
 805   1                                      if(r0 < rk)
 806   1                                      {
 807   1                                              flTransmiter = 1;
 808   1                                              SBUF0 = BufferInModem[r0++];
 809   1                                      }
 810   1                                      else
 811   1                                      {
 812   1                                              flTransmiter = 0;
 813   1                                      }
 814   1                              }
 815   1              //              ES0=0;
 816   1      
 817   1              //------------------------------------------------------------
 818   1              }*/
 819   1      }
 820          
 821          //------------------------------------------------------------------------------------------
 822          //скорость ветра
 823          void INT0 (void) interrupt 0
 824          {
 825   1              VeterFlag = 1;
 826   1              TV = RTC - RTCV;
 827   1              RTCV = RTC;
 828   1              EX0 =   0;
 829   1              return;
 830   1      }
 831          
 832          //------------------------------------------------------------------------------------
 833          void TIMER_ISR0 (void) interrupt 1
 834          {
 835   1              xdata unsigned int i, delta, FdKoeff;
 836   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 837   1              SFRPAGE = TIMER01_PAGE;
 838   1              RTC++;
 839   1              GPStimepulse++;
 840   1              /*
 841   1              if(GPStimepulse==0x4b00)
 842   1              {
 843   1                      LED=1;
 844   1              }
 845   1              else if(GPStimepulse>0x5355)
 846   1              {
 847   1                      LED=0;
 848   1                      GPStimepulse=0;
 849   1              }*/
 850   1      //ветер-------------
 851   1              if(WSpeed!=0)
 852   1                      EX0=1;
 853   1      
 854   1              if(WAngle!=0)
 855   1                      EX1=1;
 856   1      
 857   1              SFRPAGE = SFRPAGE_SAVE;
 858   1              return;
 859   1      }
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 15  

*** WARNING C280 IN LINE 835 OF SERVO2.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 835 OF SERVO2.C: 'delta': unreferenced local variable
*** WARNING C280 IN LINE 835 OF SERVO2.C: 'FdKoeff': unreferenced local variable
 860          
 861          
 862          
 863          //направление ветра-------------------------------------------------------------------
 864          void INT1 (void) interrupt 2
 865          {
 866   1              VeterFlag = 1;
 867   1              TA = RTC - RTCA;
 868   1              RTCA = RTC;
 869   1              EX1=0;
 870   1              return;
 871   1      }
 872          
 873          //------------------------------------------------------------------------------------
 874          void TIMER_ISR1 (void) interrupt 3
 875          {
 876   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 877   1              SFRPAGE = TIMER01_PAGE;
 878   1              
 879   1              SFRPAGE = SFRPAGE_SAVE;
 880   1              return;
 881   1      }
 882          
 883          //-------------------------------------------------------------------
 884          void COM_UART0_isr(void) interrupt 4
 885          {
 886   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 887   1              INT Aint;
 888   1              SFRPAGE = UART0_PAGE;
 889   1      
 890   1              if (RI0)
 891   1              {
 892   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 893   2                      if(wBFM >= NBFM)
 894   2                      {
 895   3                      wBFM = 0;
 896   3                              marBFM = 1;
 897   3                      }/*
 898   2                      if(BuferFromModem [wBFM-1]==0x41)
 899   2                      {
 900   2                              if(BuferFromModem [wBFM-4]==0x40)
 901   2                              {
 902   2                                      Aint.b[0] = BuferFromModem[wBFM-3];
 903   2                                      Aint.b[1] = BuferFromModem[wBFM-2];
 904   2                                      if(Aint.i<=0x0fff)
 905   2                                      {
 906   2                                              LirTarget = Aint.i;
 907   2                                      }
 908   2                              }       
 909   2                      }*/
 910   2                      RI0 = 0;
 911   2              }
 912   1              if (TI0)
 913   1              {
 914   2                      if(flTransmiter == 0)
 915   2                              TI0 = 0;        
 916   2              }
 917   1      
 918   1              SFRPAGE = UART1_PAGE;
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 16  

 919   1              if (RI1)
 920   1              {
 921   2                      flNewGPS = 1;
 922   2                      mess [w++] = SBUF1;  // read character
 923   2                      if(w >= NS)
 924   2                      {
 925   3                      w = 0;
 926   3                              mar = 1;
 927   3                      }
 928   2                      RI1 = 0;
 929   2              }
 930   1              SFRPAGE = SFRPAGE_SAVE;
 931   1              return;
 932   1      }
*** WARNING C280 IN LINE 887 OF SERVO2.C: 'Aint': unreferenced local variable
 933          
 934          //------------------------------------------------------------------------------------
 935          void SMBus_isr (void)interrupt 7
 936          {
 937   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 938   1              SFRPAGE = SMB0_PAGE;
 939   1              
 940   1         switch (SMB0STA){                   // Status code for the SMBus (SMB0STA register)
 941   2      
 942   2            // Master Transmitter/Receiver: START condition transmitted.
 943   2            // The R/W bit of the COMMAND word sent after this state will
 944   2            // always be a zero (W) because for both read and write,
 945   2            // the memory address must be written first.
 946   2            case SMB_START:
 947   2               SMB0DAT = (COMMAND & 0xFE);   // Load address of the slave to be accessed.
 948   2               STA = 0;                      // Manually clear START bit
 949   2               break;
 950   2      
 951   2            // Master Transmitter/Receiver: Repeated START condition transmitted.
 952   2            // This state should only occur during a read, after the memory address has been
 953   2            // sent and acknowledged.
 954   2            case SMB_RP_START:
 955   2               SMB0DAT = COMMAND;            // COMMAND should hold slave address + R.
 956   2               STA = 0;
 957   2               break;
 958   2      
 959   2            // Master Transmitter: Slave address + WRITE transmitted.  ACK received.
 960   2            case SMB_MTADDACK:
 961   2               SMB0DAT = HIGH_ADD;           // Load high byte of memory address
 962   2                                             // to be written.
 963   2               break;
 964   2      
 965   2            // Master Transmitter: Slave address + WRITE transmitted.  NACK received.
 966   2            // The slave is not responding.  Send a STOP followed by a START to try again.
 967   2            case SMB_MTADDNACK:
 968   2               STO = 1;
 969   2               STA = 1;
 970   2               break;
 971   2      
 972   2            // Master Transmitter: Data byte transmitted.  ACK received.
 973   2            // This state is used in both READ and WRITE operations.  Check BYTE_NUMBER
 974   2            // for memory address status - if only HIGH_ADD has been sent, load LOW_ADD.
 975   2            // If LOW_ADD has been sent, check COMMAND for R/W value to determine 
 976   2            // next state.
 977   2            case SMB_MTDBACK:
 978   2               switch (BYTE_NUMBER){
 979   3                  case 2:                    // If BYTE_NUMBER=2, only HIGH_ADD
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 17  

 980   3                     SMB0DAT = LOW_ADD;      // has been sent.
 981   3                     BYTE_NUMBER--;          // Decrement for next time around.
 982   3                     break;
 983   3                  case 1:                    // If BYTE_NUMBER=1, LOW_ADD was just sent.
 984   3                     if (COMMAND & 0x01){    // If R/W=READ, sent repeated START.
 985   4                        STO = 0;
 986   4                        STA = 1;
 987   4      
 988   4                     } else { 
 989   4                        SMB0DAT = WORD;      // If R/W=WRITE, load byte to write.
 990   4                        BYTE_NUMBER--;
 991   4                     }
 992   3                     break;
 993   3                  default:                   // If BYTE_NUMBER=0, transfer is finished.
 994   3                     STO = 1;
 995   3                     SM_BUSY = 0;            // Free SMBus
 996   3                  }
 997   2               break;
 998   2      
 999   2      
1000   2            // Master Transmitter: Data byte transmitted.  NACK received.
1001   2            // Slave not responding.  Send STOP followed by START to try again.
1002   2            case SMB_MTDBNACK:
1003   2               STO = 1;
1004   2               STA = 1;
1005   2               break;
1006   2      
1007   2            // Master Transmitter: Arbitration lost.
1008   2            // Should not occur.  If so, restart transfer.
1009   2            case SMB_MTARBLOST:
1010   2               STO = 1;
1011   2               STA = 1;
1012   2               break;
1013   2      
1014   2            // Master Receiver: Slave address + READ transmitted.  ACK received.
1015   2            // Set to transmit NACK after next transfer since it will be the last (only)
1016   2            // byte.
1017   2            case SMB_MRADDACK:
1018   2               AA = 0;                       // NACK sent on acknowledge cycle.
1019   2               break;
1020   2      
1021   2            // Master Receiver: Slave address + READ transmitted.  NACK received.
1022   2            // Slave not responding.  Send repeated start to try again.
1023   2            case SMB_MRADDNACK:
1024   2               STO = 0;
1025   2               STA = 1;
1026   2               break;
1027   2      
1028   2            // Data byte received.  ACK transmitted.
1029   2            // State should not occur because AA is set to zero in previous state.
1030   2            // Send STOP if state does occur.
1031   2            case SMB_MRDBACK:
1032   2               STO = 1;
1033   2               SM_BUSY = 0;
1034   2               break;
1035   2      
1036   2            // Data byte received.  NACK transmitted.
1037   2            // Read operation has completed.  Read data register and send STOP.
1038   2            case SMB_MRDBNACK:
1039   2               WORD = SMB0DAT;
1040   2               STO = 1;
1041   2               SM_BUSY = 0;                  // Free SMBus
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 18  

1042   2               break;
1043   2      
1044   2            // All other status codes meaningless in this application. Reset communication.
1045   2            default:
1046   2               STO = 1;                      // Reset communication.
1047   2               SM_BUSY = 0;
1048   2               break;
1049   2            }
1050   1      
1051   1         SI=0;                               // clear interrupt flag
1052   1      
1053   1              SFRPAGE = SFRPAGE_SAVE;
1054   1              return;
1055   1      }
1056          
1057          //------------------------------------------------------------------------------------
1058          void PCA_isr (void)interrupt 9
1059          {
1060   1              xdata char SFRPAGE_SAVE = SFRPAGE;
1061   1              SFRPAGE = PCA0_PAGE;
1062   1      //-------------------
1063   1              u0timer++; // COM u0
1064   1      //      u1timer++; // GPS u1
1065   1      //-------------------   
1066   1              CF = 0;
1067   1      //управление антеной------------------------------------------------------------------------
1068   1                      if(F==0x02)
1069   1                      {
1070   2                              LirQ();
1071   2                              delta = (LirTarget - LirData);  
1072   2                              if(delta > 0xF000)
1073   2                                      delta = delta - 0xF000;
1074   2                              if(delta >= 0x07FF)
1075   2                              {
1076   3                                      delta = 0x0FFF - delta;
1077   3                                      if(delta < 0x0155)
1078   3                                      {
1079   4                                              F = 0xC1;
1080   4                                              if(delta < 0x20 && delta > 0x0B)
1081   4                                              {
1082   5                                                      F = 0xC1;
1083   5                                              }
1084   4                                              else if(delta <= 0x0B)
1085   4                                              {
1086   5                                                      F = 0x03; 
1087   5                                              }
1088   4                                      }
1089   3                                      else
1090   3                                      {
1091   4                                              F=0xA1;
1092   4                                      }
1093   3                              }
1094   2                              else if(delta < 0x07FF)
1095   2                              {
1096   3                                      if(delta < 0x0155)
1097   3                                      {
1098   4                                              F = 0xC2;
1099   4                                              if(delta < 0x20 && delta > 0x0B)
1100   4                                              {
1101   5                                                      F = 0xC2;
1102   5                                              } 
1103   4                                              else if(delta <= 0x0B)
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 19  

1104   4                                              {
1105   5                                                      F = 0x03; 
1106   5                                              }
1107   4                                      }
1108   3                                      else
1109   3                                      {
1110   4                                              F=0xA2;
1111   4                                      }
1112   3                              }
1113   2                      }
1114   1                 if(LirData==0x0FFF)//при отключенном лир, воздействие отсутствует
1115   1                      {
1116   2                              F=0x03;
1117   2                      }
1118   1                      //ШИМы на машинку--------------------------
1119   1                      PCA0CPM0  = 0x43;
1120   1                      PCA0CPH0  = 0xFF;
1121   1                      PCA0CPL0  = 0xFF;
1122   1                      PCA0CPM1  = 0x43;
1123   1                      PCA0CPH1  = 0xFF;
1124   1                      PCA0CPL1  = 0xFF;
1125   1      
1126   1                      if(F==0xA1)
1127   1                      {
1128   2                              PCA0CPM0  = 0x43;
1129   2                              PCA0CPH0  = 0xC0;
1130   2                              PCA0CPM1  = 0x43;
1131   2                              PCA0CPH1  = 0xFF;
1132   2                              PCA0CPL1  = 0xFF;
1133   2                              Fdelta = Fdelta -  delta;
1134   2                              if(Fdelta>0x0033)
1135   2                              {
1136   3                                      PCA0CPM0  = 0x43;
1137   3                                      PCA0CPH0  = 0xf0;
1138   3                                      PCA0CPM1  = 0x43;
1139   3                                      PCA0CPH1  = 0xFF;
1140   3                                      PCA0CPL1  = 0xFF;
1141   3                              }
1142   2                              else
1143   2                              {
1144   3                                      PCA0CPH0  = 0xC0 + Fdelta;
1145   3                              }
1146   2                              Fdelta = delta;
1147   2                      }
1148   1                      else if(F==0xA2)
1149   1                      {
1150   2                              PCA0CPM1  = 0x43;
1151   2                              PCA0CPH1  = 0xC0;
1152   2                              PCA0CPM0  = 0x43;
1153   2                              PCA0CPH0  = 0xFF;
1154   2                              PCA0CPL0  = 0xFF;
1155   2                              Fdelta = Fdelta -  delta;                       
1156   2                              if(Fdelta>0x0033)
1157   2                              {
1158   3                                      PCA0CPM1  = 0x43;
1159   3                                      PCA0CPH1  = 0xf0;
1160   3                                      PCA0CPM0  = 0x43;
1161   3                                      PCA0CPH0  = 0xFF;
1162   3                                      PCA0CPL0  = 0xFF;
1163   3                              }
1164   2                              else
1165   2                              {
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 20  

1166   3                                      PCA0CPH1  = 0xC0 + Fdelta;
1167   3                              }
1168   2                              Fdelta = delta;
1169   2                      }
1170   1                      else if(F==0xC1)
1171   1                      {
1172   2                              PCA0CPM0  = 0x43;
1173   2                              PCA0CPH0  = 0xe6;
1174   2                              PCA0CPM1  = 0x43;
1175   2                              PCA0CPH1  = 0xFF;
1176   2                              PCA0CPL1  = 0xFF;
1177   2                              Fdelta = Fdelta -  delta;
1178   2                              if(Fdelta>0x0019)
1179   2                              {
1180   3                                      PCA0CPM0  = 0x43;
1181   3                                      PCA0CPH0  = 0xFF;
1182   3                                      PCA0CPL0  = 0xFF;
1183   3                                      PCA0CPM1  = 0x43;
1184   3                                      PCA0CPH1  = 0xFF;
1185   3                                      PCA0CPL1  = 0xFF;
1186   3                              }
1187   2                              else
1188   2                              {
1189   3                                      PCA0CPH0  = 0xe6 + Fdelta;
1190   3                              }
1191   2                              Fdelta = delta;
1192   2                      }
1193   1                      else if(F==0xC2)
1194   1                      {
1195   2                              PCA0CPM1  = 0x43;
1196   2                              PCA0CPH1  = 0xe6;
1197   2                              PCA0CPM0  = 0x43;
1198   2                              PCA0CPH0  = 0xFF;
1199   2                              PCA0CPL0  = 0xFF;
1200   2                              Fdelta = Fdelta -  delta;
1201   2                              if(Fdelta>0x0019)
1202   2                              {
1203   3                                      PCA0CPM0  = 0x43;
1204   3                                      PCA0CPH0  = 0xFF;
1205   3                                      PCA0CPL0  = 0xFF;
1206   3                                      PCA0CPM1  = 0x43;
1207   3                                      PCA0CPH1  = 0xFF;
1208   3                                      PCA0CPL1  = 0xFF;
1209   3                              }
1210   2                              else
1211   2                              {
1212   3                                      PCA0CPH1  = 0xe6 + Fdelta;
1213   3                              }
1214   2                              Fdelta = delta;
1215   2                      }  
1216   1                      if(F==0x03)
1217   1                      {
1218   2                         PCA0CPM0  = 0x43;
1219   2                              PCA0CPH0  = 0xFF;
1220   2                              PCA0CPL0  = 0xFF;
1221   2                              PCA0CPM1  = 0x43;
1222   2                              PCA0CPH1  = 0xFF;
1223   2                              PCA0CPL1  = 0xFF;
1224   2                      }
1225   1                      F=0x02;
1226   1              SFRPAGE = SFRPAGE_SAVE;
1227   1              return;
C51 COMPILER V9.00   SERVO2                                                                09/12/2012 14:08:09 PAGE 21  

1228   1      }
1229          //------------------------------------------------------------------------------------
1230          void TIMER_ISR3 (void) interrupt 14
1231          {
1232   1              xdata char SFRPAGE_SAVE = SFRPAGE;
1233   1              SFRPAGE = TMR3_PAGE;
1234   1      
1235   1              SFRPAGE = SFRPAGE_SAVE;
1236   1              return;
1237   1      }
1238          //-------------------------------------------------------------------
1239          void GPS_UART1_isr(void) interrupt 20
1240          {
1241   1              xdata char SFRPAGE_SAVE = SFRPAGE;
1242   1              SFRPAGE = UART1_PAGE;
1243   1              if (RI1)
1244   1              {
1245   2                      flNewGPS = 1;
1246   2                      mess [w++] = SBUF1;  // read character
1247   2                      if(w >= NS)
1248   2                      {
1249   3                      w = 0;
1250   3                              mar = 1;
1251   3                      }
1252   2                      RI1 = 0;
1253   2              }
1254   1              if (TI1)
1255   1              {
1256   2                              
1257   2              }
1258   1      
1259   1              SFRPAGE = SFRPAGE_SAVE;
1260   1              return;
1261   1      }
1262          //------------------------------------------------------------------------------------------
1263          //#endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2978    ----
   CONSTANT SIZE    =     43    ----
   XDATA SIZE       =    252      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      90
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
