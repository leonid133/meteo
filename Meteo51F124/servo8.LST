C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO8
OBJECT MODULE PLACED IN servo8.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo8.c DB OE BR

line level    source

   1          
   2          #include "c8051f120.h"
   3          #include "init.h"
   4          #include "comport.h"
   5          #include <intrins.h>
   6          #include <ctype.h>
   7          #include <stdio.h>
   8          #include <stdlib.h>
   9          #include <math.h> 
  10          //system
  11          #define SYSCLK      24883200  // (24856840L * 1 / 1) 
  12          #define FREQT0 1183 //Hz
  13          
  14          //сигнальные
  15          sbit P3_3 = P3^3;
  16          sbit LED = P1^6;
  17          sbit LED2 = P2^6;
  18          sbit BUTTON = P3^7;
  19          xdata unsigned char InitFlag;
  20          xdata unsigned int iter;
  21          
  22          //ADC
  23          sfr16 ADC0     = 0xbe;   // ADC0 data
  24          bit DavlFlag = 0;
  25          xdata long Result;                    
  26          xdata unsigned int_dec = 256;    
  27          xdata long accumulator = 0L;       
  28          
  29          //LIR
  30          sbit LIR_DATA = P2^0; //P2^2;
  31          sbit LIR_SCK = P2^1;
  32          xdata unsigned int LData;
  33          xdata float A = 0, A_pr = 0, A_zad = 0, A_zad_new = 0, A_zad_pr = 0, V = 0, V_pr = 0, V_zad = 0, V_zad_pr 
             -= 0, u = 0, u_zad = 0/*, Accel=0*/, tau=0.0, K = 200.;
  34          
  35          typedef union INT {                   
  36             unsigned int i;
  37             unsigned char b[2];
  38          } INT;
  39          
  40          xdata int  UgolMaxV = 4, Vmax = 200, Umax = 2;
  41          xdata float taumax = 0.000025;
  42          
  43          xdata unsigned char F;
  44          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  45          //Veter
  46          bit VeterFlag = 0;
  47          sbit WSpeed = P1^1;
  48          sbit WAngle = P1^3;
  49          
  50          xdata float Vspeed=0, Angle=0;
  51          xdata unsigned long RTC, RTCV, RTCA;
  52          xdata unsigned long TV,TA;
  53          
  54          typedef union FLOAT {                   
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 2   

  55             float f;
  56             unsigned char b[4];
  57          } FLOAT;
  58          //UART0
  59          #define NBFM            50
  60          xdata unsigned char BuferFromModem [NBFM]; 
  61          xdata unsigned char wBFM, rBFM, marBFM;
  62          xdata unsigned int u0timer;
  63          
  64          #define SIZE_BUFFER0            50
  65          xdata char BufferInModem[SIZE_BUFFER0]; 
  66          xdata int r0, rk;
  67          bit flTransmiter;       
  68          
  69          //GPS
  70          typedef union LINT {                   
  71             unsigned long i;
  72             unsigned char b[4];
  73          } LINT;
  74          #define NS      75
  75          xdata char mess [NS], r, w, mar;                
  76          bit flNewGPS;
  77          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  78          xdata unsigned long LatGnd=0, LonGnd=0;
  79          //------------------------------------------------------------------------------
  80          void OutModem1(unsigned char Data, char i)
  81          {
  82   1              BufferInModem[i] = Data | 0x80;
  83   1      }
  84          
  85          //------------------------------------------------------------------------------
  86          void OutModem2(unsigned int Data, char i)
  87          {
  88   1              BufferInModem[i] = (Data & 0x007f)| 0x80;
  89   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  90   1      }
  91          
  92          //------------------------------------------------------------------------------
  93          void OutModem4(unsigned long int Data, char i)
  94          {
  95   1              BufferInModem[i] = (Data & 0x0000007f)| 0x80;
  96   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
  97   1              BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
  98   1         BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
  99   1      }
 100          //------------------------------------------------------------------------------------
 101          void main(void)
 102          {
 103   1      //ADC
 104   1              xdata long Pressure = 0;
 105   1              xdata float PressureFl = 0.0;
 106   1      //UART
 107   1      //   xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 108   1      //        unsigned int Value;
 109   1              INT Aint;
 110   1              FLOAT Bfloat;
 111   1              LINT tmpLong;
 112   1      //GPS
 113   1         bit ValidGPS, flPoint;       
 114   1              xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 115   1              xdata unsigned long temp_koord;
 116   1              xdata unsigned int i;
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 3   

 117   1      
 118   1         xdata unsigned char chtmp;
 119   1              xdata int tmp;
 120   1      
 121   1              EA = 0;
 122   1              WDTCN     = 0xDE;       //выкл собаки
 123   1         WDTCN     = 0xAD;
 124   1              EA= 1;   
 125   1              
 126   1              LED=0;
 127   1      
 128   1              Port_IO_Init();
 129   1              Oscillator_Init();   
 130   1              Interrupts_Init(); 
 131   1              Timer_Init();
 132   1              UART0_Init();
 133   1         UART1_Init();
 134   1              PCA_Init();
 135   1         ADC_Init();
 136   1      
 137   1      //      LirTarget = 0x03ff;
 138   1      //      Fdelta = 0;
 139   1              flNewGPS = 0;
 140   1              u0timer=0;
 141   1              while(1)
 142   1              {
 143   2      //ADC
 144   2                      EIP2 |= 0x02;
 145   2                      if(DavlFlag==1)
 146   2                      {
 147   3                              EA = 0; 
 148   3                              Pressure =  Result * 2430 / 4095;
 149   3                              EA = 1; 
 150   3                              DavlFlag = 0;
 151   3                              PressureFl = PressureFl + (Pressure - PressureFl)*0.5;
 152   3                              LED2=!LED2;
 153   3                      }
 154   2      
 155   2      //Veter
 156   2                      if(VeterFlag==1)
 157   2                      {
 158   3                              Vspeed = (float)FREQT0/((float)TV*0.75);        //???
 159   3                              Angle = 360. - (360.*(float)TV/(float)TA);
 160   3                              VeterFlag = 0;
 161   3                      }
 162   2      
 163   2                      //GPS---------------------------------------------------------------------------
 164   2                      if(flNewGPS == 1)       
 165   2                      {
 166   3                              flNewGPS = 0;
 167   3                              if (r < w+mar*NS) 
 168   3                              {
 169   4                                      if(mess[r] == '$')
 170   4                                      {
 171   5                      nLetter = 0;
 172   5                                      }
 173   4                      else if ((nLetter == 0) && (mess[r] == 'G'))
 174   4                      nLetter++;
 175   4                      else if ((nLetter == 1) && (mess[r] == 'P'))
 176   4                      nLetter++;
 177   4                      else if ((nLetter == 2) && (mess[r] == 'R'))
 178   4                      nLetter++;
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 4   

 179   4                       else if ((nLetter == 3) && (mess[r] == 'M'))
 180   4                       nLetter++;
 181   4                 else if ((nLetter == 4) && (mess[r] == 'C'))
 182   4                      {
 183   5                      nLetter++;
 184   5                                              i_comma = 0;
 185   5                                              ValidGPS = 0;
 186   5                 } 
 187   4                              else if(mess[r] == ',')
 188   4                                      {
 189   5                                              i_comma++;
 190   5                                              i = 0;
 191   5                                              flPoint = 0;
 192   5                                      }
 193   4                              else if(i_comma == 2)
 194   4                                      {
 195   5                                              if(mess[r] == 'A') 
 196   5                                                      ValidGPS = 1;
 197   5                                              else
 198   5                                              {
 199   6                                                      ValidGPS = 0;
 200   6              //                                      flNoKoord = 1;
 201   6              //                                      liTimer_tick_GPS = liTimer_tick;
 202   6                                              }
 203   5                                      }
 204   4                      else if (ValidGPS)
 205   4                                      {
 206   5                                              if (i_comma == 3)                                       //Latitude
 207   5                                              {
 208   6                                                      if(mess[r] == '.')
 209   6                                                      {
 210   7                                                              flPoint = 1;
 211   7                                                              i = 0;
 212   7                                                      }
 213   6                                                      else if (flPoint == 0)                                          //celaya chast
 214   6                                                      {
 215   7                                                              tmpGPS[i++] = mess[r];
 216   7                                                              if(i == 2)
 217   7                                                              {
 218   8                                              tmpGPS[i] = 0;
 219   8                                                                      temp_koord = atoi(tmpGPS);
 220   8                                              temp_koord = 60UL*10000*temp_koord;
 221   8                                                              }       
 222   7                                                              else if(i == 4)
 223   7                                                              {
 224   8                                                                      tmpGPS[0] = tmpGPS[1] = '0';
 225   8                                              tmpGPS[i] = 0;
 226   8                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 227   8                                                              }       
 228   7                                                      }
 229   6                                                      else                                                                                            //drobnaya chast
 230   6                                                      {
 231   7                                                              tmpGPS[i++] = mess[r];
 232   7                                      tmpGPS[i] = 0;
 233   7                                                      }
 234   6                                              }
 235   5                                              else if (i_comma == 4)
 236   5                                              {
 237   6                                      temp_koord = temp_koord+atoi(tmpGPS);
 238   6      //-----------
 239   6      //lLatGnd = 55UL*60*10000+50UL*10000+8680;
 240   6      //--------
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 5   

 241   6                                                      if (mess[r] == 'S')                                             //znak Latitude
 242   6                                                              LatGnd = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 243   6                                                      else              
 244   6                                                              LatGnd = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 245   6                                              }
 246   5                                              else if (i_comma == 5)                          //Longitude
 247   5                                              {
 248   6                                                      if(mess[r] == '.')
 249   6                                                      {
 250   7                                                              flPoint = 1;
 251   7                                                              i = 0;
 252   7                                                      }
 253   6                                                      else if (flPoint == 0)                                          //celaya chast
 254   6                                                      {
 255   7                                                              tmpGPS[i++] = mess[r];
 256   7                                                              if(i == 3)
 257   7                                                              {
 258   8                                              tmpGPS[i] = 0;
 259   8                                              temp_koord = atoi(tmpGPS);
 260   8                                              temp_koord = 60UL*10000*temp_koord;
 261   8                                                              }       
 262   7                                                              else if(i == 5)
 263   7                                                              {
 264   8                                                                      tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 265   8                                              tmpGPS[i] = 0;
 266   8                                              temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 267   8                                                              }       
 268   7                                                      }
 269   6                                                      else                                                                                            //drobnaya chast
 270   6                                                      {
 271   7                                                              tmpGPS[i++] = mess[r];
 272   7                                      tmpGPS[i] = 0;
 273   7                                                      }
 274   6                                              }
 275   5                                              else if (i_comma == 6)
 276   5                                              {
 277   6                                      temp_koord = temp_koord+atoi(tmpGPS);
 278   6      //----------------
 279   6      //lLonGnd = 49UL*60*10000+6UL*10000+3760;
 280   6      //----------------
 281   6                                                      if (mess[r] == 'W')                                             //znak Longitude
 282   6                                                              LonGnd = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 283   6                                                      else       
 284   6                                                              LonGnd = temp_koord+108000000UL;                //180UL*60*10000;
 285   6                                              }
 286   5                                              else if (i_comma == 7)                                                  //skorost v uzlah
 287   5                                              {
 288   6                                                      if(mess[r] == '.')
 289   6                                                      {
 290   7                                                              flPoint = 1;
 291   7                                      Vz = 1.852*atoi(tmpGPS)/3.6;            //preobrazovat iz uzlov v m/s
 292   7      //---------
 293   7      //Vz = 20;
 294   7      //-----------
 295   7                                                      }
 296   6                                                      else if(flPoint == 0)
 297   6                                                      {
 298   7                                                              tmpGPS[i++] = mess[r];
 299   7                                      tmpGPS[i] = 0;
 300   7                                                      }
 301   6                      }
 302   5                                              else if (i_comma == 8)                                                  //kurs v gradusah
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 6   

 303   5                                              {
 304   6                                                      if(mess[r] == '.')
 305   6                                                      {
 306   7                                                              flPoint = 1;
 307   7                                      koors = atoi(tmpGPS);
 308   7                              if (koors < 0)
 309   7                              koors = 360+koors;
 310   7                                                              flNoKoord = 0;
 311   7                                                              flNewGPS = 1;
 312   7                                                              liTimer_tick_GPS = liTimer_tick;        
 313   7              //                          OutModem20();
 314   7      //-----------                                              
 315   7      //koors = 30;
 316   7      //-----------
 317   7                                                      }
 318   6                                                      else if(flPoint == 0)
 319   6                                                      {
 320   7                                                              tmpGPS[i++] = mess[r];
 321   7                                      tmpGPS[i] = 0;
 322   7                                                      }
 323   6                          }
 324   5                                      }
 325   4                                      r++;
 326   4                              if(r >= NS)
 327   4                                      {
 328   5                              r = 0;
 329   5                                              mar = 0;        
 330   5                                      }      
 331   4                              }
 332   3                      }
 333   2      
 334   2                      //---------------------------------------------------------------------
 335   2      //              if(u0timer > (3*FREQT0))
 336   2                      if((flTransmiter == 0) && (u0timer > FREQT0))
 337   2                      {
 338   3                              u0timer = 0;
 339   3                              if(wBFM > 4)
 340   3                              {
 341   4                              P3_3=!P3_3;
 342   4                                      chtmp = 0;
 343   4                                      for (i = 0; i < 5; i++ )
 344   4                                      chtmp = chtmp ^ BuferFromModem[i];
 345   4                                      chtmp = chtmp | 0x80;
 346   4                                      if(chtmp == BuferFromModem[5] && BuferFromModem[0] == (46 | 0x40))
 347   4                                      {
 348   5                                              tmp = BuferFromModem[1]&~0x80;
 349   5                              tmp |= ((int)(BuferFromModem[2]&~0x80)<<7);
 350   5                                              if(tmp<=360 && tmp>=0)
 351   5                                              {
 352   6                                                      A_zad_new = tmp;
 353   6                                                      tmp = BuferFromModem[3]&~0x80;
 354   6                                                      tmp |= ((int)(BuferFromModem[4]&~0x80)<<7);
 355   6                                                      K = tmp*0.01;
 356   6                                              }
 357   5                                      }
 358   4                                      wBFM = 0;
 359   4                              }
 360   3      
 361   3                              BufferInModem[0] = 0x40 | 40;                   
 362   3                              OutModem4(LatGnd, 1);
 363   3                              OutModem4(LonGnd, 5);
 364   3                              OutModem2((int)Angle, 9);
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 7   

 365   3                              OutModem2((int)Vspeed, 11);
 366   3                              OutModem2((int)PressureFl, 13);
 367   3                      BufferInModem[15] = 0;
 368   3                              for (i = 0; i < 15; i++ )
 369   3                              BufferInModem[15] = BufferInModem[15] ^ BufferInModem[i];
 370   3                              BufferInModem[15] = 0x80 |      BufferInModem[15];
 371   3      
 372   3                              BufferInModem[16] = 0x40|41;
 373   3                              OutModem2((int)A, 17);
 374   3                      BufferInModem[19] = BufferInModem[16] ^ BufferInModem[17] ^ BufferInModem[18] | 0x80;
 375   3                              r0 = 0;
 376   3                              rk = 20;
 377   3                              //dopolnitelnye dannye
 378   3                              //A, A_zad, V, V_zad
 379   3                              /*tmp = (int)(A*10.);
 380   3                              OutModem2(tmp, 20);
 381   3                              tmp = (int)(A_zad*10.);
 382   3                              OutModem2(tmp, 22);
 383   3                              tmp = (int)(V*10.);
 384   3                              OutModem2(tmp, 24);
 385   3                              tmp = (int)(V_zad*10.);
 386   3                              OutModem2(tmp, 26);
 387   3                              rk+=8;*/
 388   3                              //      
 389   3                              flTransmiter = 1;
 390   3                              
 391   3                              SFRPAGE = 0x00;
 392   3                              TI0 = 1;
 393   3                      }
 394   2              }
 395   1      }
*** WARNING C280 IN LINE 109 OF SERVO8.C: 'Aint': unreferenced local variable
*** WARNING C280 IN LINE 110 OF SERVO8.C: 'Bfloat': unreferenced local variable
*** WARNING C280 IN LINE 111 OF SERVO8.C: 'tmpLong': unreferenced local variable
 396          //------------------------------------------------------------------------------------
 397          void INT0 (void) interrupt 0 //skorost vetra
 398          {
 399   1              EX0 =   0;
 400   1              VeterFlag = 1;
 401   1              TV = RTC - RTCV;
 402   1              RTCV = RTC;
 403   1              return;
 404   1      }
 405          
 406          //------------------------------------------------------------------------------------
 407          void TIMER_ISR0 (void) interrupt 1
 408          {
 409   1              xdata float tmp;
 410   1              xdata unsigned char shim;
 411   1              xdata unsigned int i_t0;
 412   1      
 413   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 414   1              SFRPAGE = TIMER01_PAGE;
 415   1              RTC++;
 416   1              u0timer++;
 417   1              
 418   1              LData = 0;
 419   1              EA = 0; //опрос ЛИР
 420   1              
 421   1              LIR_SCK = 1;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 422   1              LIR_SCK = 0;    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 423   1                              
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 8   

 424   1      /*      LIR_SCK = 1;    //---D n-1
 425   1              shim++;
 426   1              LIR_SCK = 0;
 427   1              shim++;
 428   1      */                      
 429   1              LIR_SCK = 1;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 430   1              LIR_SCK = 0;                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++; 
 431   1              LData = LData | LIR_DATA;       
 432   1      
 433   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 434   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 435   1              LData = (LData << 1) | LIR_DATA;        
 436   1              
 437   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 438   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 439   1              LData = (LData << 1) | LIR_DATA;        
 440   1      
 441   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 442   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 443   1              LData = (LData << 1) | LIR_DATA;        
 444   1              
 445   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 446   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 447   1              LData = (LData << 1) | LIR_DATA;        
 448   1      
 449   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 450   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 451   1              LData = (LData << 1) | LIR_DATA;        
 452   1      
 453   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 454   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 455   1              LData = (LData << 1) | LIR_DATA;        
 456   1      
 457   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 458   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 459   1              LData = (LData << 1) | LIR_DATA;        
 460   1      
 461   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 462   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 463   1              LData = (LData << 1) | LIR_DATA;        
 464   1      
 465   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 466   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 467   1              LData = (LData << 1) | LIR_DATA;        
 468   1      
 469   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 470   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 471   1              LData = (LData << 1) | LIR_DATA;        
 472   1      
 473   1              LIR_SCK = 1;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 474   1              LIR_SCK = 0;                                                    shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;shim++;
 475   1              LData = (LData << 1) | LIR_DATA;
 476   1      
 477   1              LIR_SCK = 1; 
 478   1              EA = 1;
 479   1              
 480   1      
 481   1              //управление антеной------------------------------------------------------------------------
 482   1              tmp = 360.0/4095.0*LData;
 483   1              if ((A > 270) && (tmp < 90))
 484   1              {
 485   2                      A = tmp+360;//A = A+(tmp+360-A)/FREQT0*K;
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 9   

 486   2                      if (A > 360)
 487   2                              A = A-360;
 488   2              }
 489   1              else if ((tmp > 270) && (A < 90))
 490   1              {
 491   2                      A = tmp-360;//A = A+(tmp-A-360)/FREQT0*K;
 492   2                      if (A < 0)
 493   2                              A = A+360;
 494   2              }
 495   1              else
 496   1                      A = tmp;//A = A+(tmp-A)/FREQT0*K;
 497   1      
 498   1              if ((A_pr > 270) && (A < 90))
 499   1                      V = (A+360-A_pr)*FREQT0;//V = V+((A+360-A_pr)*FREQT0-V)/FREQT0*K;
 500   1              else if ((A > 270) && (A_pr < 90))
 501   1                      V = (A-A_pr-360)*FREQT0;//V = V+((A-A_pr-360)*FREQT0-V)/FREQT0*K;
 502   1              else
 503   1                      V = (A-A_pr)*FREQT0;//V = V+((A-A_pr)*FREQT0-V)/FREQT0*K;
 504   1              A_pr = A;
 505   1      
 506   1              if (V > Vmax) 
 507   1                      V = Vmax;
 508   1              else if (V < -Vmax) 
 509   1                      V = -Vmax;
 510   1      /*
 511   1              if ((A_zad > 270) && (A_zad_new < 90))
 512   1                      A_zad = A_zad + (A_zad_new + 360 - A_zad)/FREQT0*K;
 513   1              else if ((A_zad_new > 270) && (A_pr < 90))
 514   1                      A_zad = A_zad + (A_zad_new - 360 - A_zad)/FREQT0*K;
 515   1              else
 516   1                      A_zad = A_zad + (A_zad_new - A_zad)/FREQT0*K;
 517   1      */
 518   1              A_zad = A_zad_new;
 519   1              
 520   1              tmp = (A_zad-A);
 521   1              while (tmp > 180)
 522   1              tmp -= 360;
 523   1              while (tmp < -180)
 524   1              tmp += 360;
 525   1              tmp = tmp/UgolMaxV*Vmax;        
 526   1              if(tmp > Vmax)  
 527   1                      tmp = Vmax;
 528   1              else if(V_zad < -Vmax)  
 529   1                      tmp = -Vmax;
 530   1              
 531   1      //      V_zad = V_zad + (tmp - V_zad)/FREQT0*K;
 532   1              
 533   1              if(fabs(tmp) > fabs(V_zad))
 534   1              {
 535   2                      V_zad = V_zad + (tmp - V_zad)/FREQT0*K;
 536   2              }
 537   1              else if((fabs(V_zad)+0.1)<fabs(tmp))
 538   1              {
 539   2                      V_zad = V_zad + ((tmp*0.01) - V_zad)/FREQT0*1100.;
 540   2              }
 541   1              else
 542   1              {
 543   2                      V_zad = V_zad + (tmp - V_zad)/FREQT0*1100.;
 544   2              }
 545   1              
 546   1              
 547   1      /*
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 10  

 548   1              if(fabs(A_zad - A)<UgolMaxV)
 549   1              {
 550   1                      V_zad = V_zad*0.5;
 551   1              }*/
 552   1      
 553   1      
 554   1              tau = (V_zad-V)/Vmax*taumax;
 555   1              if (tau > taumax)
 556   1                      tau = taumax;
 557   1              else if (tau < -taumax)
 558   1                      tau = -taumax;
 559   1      /*
 560   1              LirData = LData;
 561   1      
 562   1                      LirTarget = A_zad*4096./360.;
 563   1                      delta = (LirTarget - LirData);  
 564   1                              if(delta > 0xF000)
 565   1                                      delta = delta - 0xF000;
 566   1                              if(delta >= 0x07FF)
 567   1                              {
 568   1                                      delta = 0x0FFF - delta;
 569   1                                      if(delta < 0x0155)
 570   1                                      {
 571   1                                              F = 0xC1;
 572   1                                              if(delta < 0x20 && delta > 0x0B)
 573   1                                              {
 574   1                                                      F = 0xC1;
 575   1                                              }
 576   1                                              else if(delta <= 0x0B)
 577   1                                              {
 578   1                                                      F = 0x03; 
 579   1                                              }
 580   1                                      }
 581   1                                      else
 582   1                                      {
 583   1                                              F=0xA1;
 584   1                                      }
 585   1                              }
 586   1                              else if(delta < 0x07FF)
 587   1                              {
 588   1                                      if(delta < 0x0155)
 589   1                                      {
 590   1                                              F = 0xC2;
 591   1                                              if(delta < 0x20 && delta > 0x0B)
 592   1                                              {
 593   1                                                      F = 0xC2;
 594   1                                              } 
 595   1                                              else if(delta <= 0x0B)
 596   1                                              {
 597   1                                                      F = 0x03; 
 598   1                                              }
 599   1                                      }
 600   1                                      else
 601   1                                      {
 602   1                                              F=0xA2;
 603   1                                      }
 604   1                              }
 605   1      
 606   1                      if(LirData==0x0FFF)//при отключенном лир, и в точке 0 град, воздействие отсутствует
 607   1                      {
 608   1                              F=0x03;
 609   1                      }
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 11  

 610   1      //ШИМы на машинку--------------------------
 611   1                      if(F==0xA1)
 612   1                      {
 613   1                              Fdelta =  delta - Fdelta;
 614   1                              Fdelta = delta;
 615   1                              shim = 0xff-0x3f*fabs(tau)/taumax;
 616   1                              PCA0CPH1  = 0xFF;
 617   1                              PCA0CPH0  = shim;
 618   1                      }
 619   1                      else if(F==0xA2)
 620   1                      {
 621   1                              Fdelta =  delta - Fdelta;
 622   1                              Fdelta = delta;
 623   1                              shim = 0xff-0x3f*fabs(tau)/taumax;
 624   1                              PCA0CPH0  = 0xFF;
 625   1                              PCA0CPH1  = shim;
 626   1                      }
 627   1                      else if(F==0xC1)
 628   1                      {
 629   1                              PCA0CPH1  = 0xFF;
 630   1                              Fdelta = delta-Fdelta;
 631   1                              if(fabs(V)>(Vmax/2.))
 632   1                              {
 633   1                                      shim = 0xff-0x3f*fabs(taumax/2.)/taumax;
 634   1                                      PCA0CPH0  = 0xff;
 635   1                                      //PCA0CPH1  = shim;
 636   1                                      PCA0CPH1  = 0xff;
 637   1                              
 638   1                              }
 639   1                              else
 640   1                              {
 641   1                                      if(V_zad<-4.)
 642   1                                              V_zad=-4.;
 643   1                                      shim = 0xff-0x3f*fabs(tau)/taumax;
 644   1                                      PCA0CPH1  = 0xFF;
 645   1                                      PCA0CPH0  = shim;
 646   1                              }
 647   1                              Fdelta = delta;
 648   1                      }
 649   1                      else if(F==0xC2)
 650   1                      {
 651   1                              PCA0CPH0  = 0xFF;
 652   1                              Fdelta =  delta - Fdelta;
 653   1                              if(fabs(V)>(Vmax/2.))
 654   1                              {
 655   1                                      shim = 0xff-0x3f*(taumax/2.)/taumax;
 656   1                                      PCA0CPH1  = 0xff;
 657   1                                      //PCA0CPH0  = shim;
 658   1                                      PCA0CPH0  = 0xff;
 659   1                              }
 660   1                              else
 661   1                              {
 662   1                                      if(V_zad>4.)
 663   1                                              V_zad=4.;
 664   1                                      shim = 0xff-0x3f*fabs(tau)/taumax;
 665   1                                      PCA0CPH0  = 0xFF;
 666   1                                      PCA0CPH1  = shim;
 667   1                              }
 668   1                              Fdelta = delta;
 669   1                      }  
 670   1                      if(F==0x03)
 671   1                      {
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 12  

 672   1                              PCA0CN    = 0x40;
 673   1                         PCA0MD    = 0x01;
 674   1                              PCA0CPM0  = 0x43;
 675   1                              PCA0CPM1  = 0x43;
 676   1                              PCA0CPH0  = 0xFF;
 677   1                              PCA0CPH1  = 0xFF;
 678   1                      }
 679   1                      F=0x02;*/
 680   1      /*
 681   1              tmp = 360.0/4095.0*LData;
 682   1              if ((A > 270) && (tmp < 90))
 683   1              {
 684   1                      A = A+(tmp+360-A)/FREQT0*K;
 685   1                      if (A > 360)
 686   1                              A = A-360;
 687   1              }
 688   1              else if ((tmp > 270) && (A < 90))
 689   1              {
 690   1                      A = A+(tmp-A-360)/FREQT0*K;
 691   1                      if (A < 0)
 692   1                              A = A+360;
 693   1              }
 694   1              else
 695   1                      A = A+(tmp-A)/FREQT0*K;
 696   1      
 697   1              V = V+((A-A_pr)*FREQT0-V)/FREQT0*K;
 698   1              A_pr = A;
 699   1              u = u+((V-V_pr)*FREQT0-u)/FREQT0*K;
 700   1              V_pr = V;
 701   1      
 702   1              //---------------------------------------------
 703   1              tmp = (A_zad-A)*10;///UgolMaxV*Vmax;
 704   1              V_zad = V_zad+(tmp-V_zad)/FREQT0*K; //-360 ... +360гр
 705   1              u_zad = u_zad+((V_zad-V_zad_pr)*FREQT0-u_zad)/FREQT0*K;
 706   1              V_zad_pr = V_zad;
 707   1      
 708   1      //      tmp = (u_zad-u);
 709   1              tmp = u_zad;
 710   1              while (tmp > 180)
 711   1            tmp -= 360;
 712   1              while (tmp < -180)
 713   1            tmp += 360;
 714   1      
 715   1              tau = tmp*0.000001;///Vmax*taumax;
 716   1              if (tau > taumax)
 717   1                      tau = taumax;
 718   1              else if (tau < -taumax)
 719   1                      tau = -taumax;
 720   1              
 721   1      */
 722   1      /*
 723   1              tmp = 360.0/4095.0*LData;
 724   1              if ((A > 270) && (tmp < 90))
 725   1              {
 726   1                      A = A+(tmp+360-A)/FREQT0*(K*0.1);
 727   1                      if (A > 360)
 728   1                              A = A-360;
 729   1              }
 730   1              else if ((tmp > 270) && (A < 90))
 731   1              {
 732   1                      A = A+(tmp-A-360)/FREQT0*(K*0.1);
 733   1                      if (A < 0)
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 13  

 734   1                              A = A+360;
 735   1              }
 736   1              else
 737   1                      A = A+(tmp-A)/FREQT0*(K*0.1);
 738   1      
 739   1              V = V+((A-A_pr)*FREQT0-V)/FREQT0*(K*0.1);
 740   1              A_pr = A;
 741   1              u = u+((V-V_pr)*FREQT0-u)/FREQT0*(K*0.1);
 742   1              V_pr = V;
 743   1      
 744   1              //---------------------------------------------
 745   1              tmp = (A_zad-A)/UgolMaxV*Vmax;
 746   1              if(tmp > Vmax)  
 747   1                      tmp = Vmax;
 748   1              else if(tmp < -Vmax)    
 749   1                      tmp = -Vmax;
 750   1              V_zad = V_zad+(tmp-V_zad)/FREQT0*(K*0.1); //-360 ... +360гр
 751   1              u_zad = u_zad+((V_zad-V_zad_pr)*FREQT0-u_zad)/FREQT0*(K*0.1);
 752   1              if(u_zad> Umax) 
 753   1                      u_zad = Umax;
 754   1              else if(u_zad < -Umax)  
 755   1                      u_zad = -Umax;
 756   1              V_zad_pr = V_zad;
 757   1      
 758   1              
 759   1              tau = (u_zad-u)/Umax*taumax;
 760   1              tmp = (V_zad-V)/Vmax*taumax;
 761   1              if(tau>tmp)
 762   1                      tau = tmp;
 763   1      
 764   1              if (tau > taumax)
 765   1                      tau = taumax;
 766   1              else if (tau < -taumax)
 767   1                      tau = -taumax;
 768   1      */
 769   1      //**
 770   1      //--
 771   1      /*      tmp = 360.0/4095.0*LData;
 772   1              if ((A > 270) && (tmp < 90))
 773   1              {
 774   1                      A = A+(tmp+360-A)/FREQT0*K;
 775   1                      if (A > 360)
 776   1                              A = A-360;
 777   1              }
 778   1              else if ((tmp > 270) && (A < 90))
 779   1              {
 780   1                      A = A+(tmp-A-360)/FREQT0*K;
 781   1                      if (A < 0)
 782   1                              A = A+360;
 783   1              }
 784   1              else
 785   1                      A = A+(tmp-A)/FREQT0*K;
 786   1      
 787   1              if ((A_pr > 270) && (A < 90))
 788   1                      V = V+((A+360-A_pr)*FREQT0-V)/FREQT0*K;
 789   1              else if ((A > 270) && (A_pr < 90))
 790   1                      V = V+((A-A_pr-360)*FREQT0-V)/FREQT0*K;
 791   1              else
 792   1                      V = V+((A-A_pr)*FREQT0-V)/FREQT0*K;
 793   1              A_pr = A;
 794   1      
 795   1              if (V > Vmax) 
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 14  

 796   1                      V = Vmax;
 797   1              else if (V < -Vmax) 
 798   1                      V = -Vmax;
 799   1      
 800   1              V_zad = (A_zad-A);
 801   1              while (V_zad > 180)
 802   1            V_zad -= 360;
 803   1              while (V_zad < -180)
 804   1            V_zad += 360;
 805   1      
 806   1              V_zad = V_zad/UgolMaxV*Vmax;    
 807   1              if(V_zad > Vmax)        
 808   1                      V_zad = Vmax;
 809   1              else if(V_zad < -Vmax)  
 810   1                      V_zad = -Vmax;
 811   1      
 812   1              tau = (V_zad-V)/Vmax*taumax;
 813   1              if (tau > taumax)
 814   1                      tau = taumax;
 815   1              else if (tau < -taumax)
 816   1                      tau = -taumax;*/
 817   1      //--
 818   1      /*
 819   1              if(fabs(A_zad - A)<5 && fabs(V)>5.)
 820   1              {       tau = (-tau)*0.3; }*/
 821   1              shim = 0xff-0x3f*fabs(tau)/taumax;
 822   1              PCA0CN    = 0x40;
 823   1         PCA0MD    = 0x01;
 824   1              PCA0CPM0  = 0x43;
 825   1         PCA0CPM1  = 0x43;
 826   1              if (tau > 0.0000015)
 827   1              {
 828   2                      PCA0CPH0  = 0xFF;
 829   2              PCA0CPH1  = shim;
 830   2              }
 831   1              else if(tau < -0.0000015)
 832   1              {
 833   2                 PCA0CPH1  = 0xFF;
 834   2                      PCA0CPH0  = shim;
 835   2              }
 836   1              else
 837   1              {
 838   2                 PCA0CPH0  = 0xFF;
 839   2              PCA0CPH1  = 0xFF;
 840   2              }
 841   1              
 842   1              if(WSpeed != 0)
 843   1                      EX0 = 1;
 844   1      
 845   1              if(WAngle != 0)
 846   1                      EX1 = 1;
 847   1      
 848   1              SFRPAGE = SFRPAGE_SAVE;
 849   1              return;
 850   1      }
*** WARNING C280 IN LINE 411 OF SERVO8.C: 'i_t0': unreferenced local variable
 851          
 852          //------------------------------------------------------------------------------------
 853          void INT1 (void) interrupt 2 //napravl vetra
 854          {
 855   1              EX1=0;
 856   1              TA = RTC - RTCA;
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 15  

 857   1              RTCA = RTC;
 858   1              return;
 859   1      }
 860          
 861          //------------------------------------------------------------------------------------
 862          void COM_UART0_isr(void) interrupt 4
 863          {
 864   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 865   1              SFRPAGE = UART0_PAGE;
 866   1              
 867   1              if (RI0)
 868   1              {
 869   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 870   2                      if(wBFM >= NBFM)
 871   2                      {
 872   3                      wBFM = 0;
 873   3                              marBFM = 1;
 874   3                      }
 875   2                      RI0 = 0;
 876   2              }
 877   1              if (TI0)
 878   1              {
 879   2                      if(r0 < rk)
 880   2                      {
 881   3                              SBUF0 = BufferInModem[r0++];
 882   3                      }
 883   2                      else
 884   2                      {
 885   3                              flTransmiter = 0;
 886   3                      }
 887   2                      TI0 = 0;
 888   2              }
 889   1              
 890   1              SFRPAGE = SFRPAGE_SAVE;
 891   1              return;
 892   1      }
 893          
 894          //-------------------------------------------------------------------
 895          
 896          void PCA_isr (void)interrupt 9 
 897          {
 898   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 899   1              SFRPAGE = PCA0_PAGE;
 900   1              CF = 0;                                                                                 //Сброс флага прерывания шимогенератора
 901   1              SFRPAGE = SFRPAGE_SAVE;
 902   1              return;
 903   1      }
 904          //-------------------------------------------------------------------
 905          
 906          void ADC0_ISR (void) interrupt 15
 907          {
 908   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 909   1              SFRPAGE = ADC0_PAGE;
 910   1              AD0INT = 0;                         // Clear ADC conversion complete
 911   1                                             // indicator
 912   1         accumulator += ADC0;                // Read ADC value and add to running
 913   1                                             // total
 914   1         int_dec--;                          // Update decimation counter
 915   1      
 916   1         if (int_dec == 0)                   // If zero, then post result
 917   1         {
 918   2                      int_dec = 256;                          // Reset counter
C51 COMPILER V9.00   SERVO8                                                                11/19/2012 10:29:55 PAGE 16  

 919   2            Result = accumulator >> 8;
 920   2            accumulator = 0L;                // Reset accumulator
 921   2                      DavlFlag = 1;
 922   2                      EIP2  &= ~0x02;
 923   2         }
 924   1              SFRPAGE = SFRPAGE_SAVE;
 925   1              return;
 926   1      }
 927          //-------------------------------------------------------------------
 928          void GPS_UART1_isr(void) interrupt 20
 929          {
 930   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 931   1              SFRPAGE = UART1_PAGE;
 932   1              if (RI1)
 933   1              {
 934   2                      flNewGPS = 1;
 935   2                      mess [w++] = SBUF1;  // read character
 936   2                      if(w >= NS)
 937   2                      {
 938   3                      w = 0;
 939   3                              mar = 1;
 940   3                      }
 941   2                      RI1 = 0;
 942   2              }
 943   1              if (TI1)
 944   1              {
 945   2                              
 946   2              }
 947   1              SFRPAGE = SFRPAGE_SAVE;
 948   1              return;
 949   1      }
 950          
 951          
 952          //#endif
 953          
 954          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6131    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    319      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
