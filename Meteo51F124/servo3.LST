C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO3
OBJECT MODULE PLACED IN servo3.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo3.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "init.h"
   3          #include "comport.h"
   4          #include <intrins.h>
   5          #include <ctype.h>
   6          #include <stdio.h>
   7          #include <stdlib.h>
   8          #include "servo.h"  
   9          #include <math.h> 
  10                   
  11          
  12          #define SYSCLK 24500000 //Hz
  13          #define FREQT0 8006 //Hz
  14          
  15          //отладочные
  16          sbit LED = P1^6;
  17          sbit LED2 = P2^6;
  18          sbit LED3 = P3^0;
  19          sbit BUTTON = P3^7;
  20          xdata unsigned char InitFlag;
  21          //--------------
  22          /*
  23          //лир
  24          sbit LIR_DATA = P2^2; //P2^0;
  25          sbit LIR_SCK = P2^1;
  26          
  27          xdata unsigned char F;
  28          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  29          
  30          typedef union INT {                   
  31             unsigned int i;
  32             unsigned char b[2];
  33          } INT;
  34          //---
  35          //ветер
  36          xdata unsigned char VeterFlag = 0;
  37          sbit WSpeed = P1^1;
  38          sbit WAngle = P1^3;
  39          
  40          xdata float Vspeed, Angle;
  41          xdata unsigned long RTC, RTCV, RTCA;
  42          xdata unsigned long TV,TA;
  43          
  44          typedef union FLOAT {                   
  45             float f;
  46             unsigned char b[4];
  47          } FLOAT;
  48          //-----
  49          //UART0
  50          #define NBFM            50
  51          xdata unsigned char BuferFromModem [NBFM]; 
  52          xdata unsigned char wBFM, rBFM, marBFM;
  53          xdata unsigned int u0timer;
  54          
  55          #define SIZE_BUFFER0            50
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 2   

  56          xdata char BufferInModem[SIZE_BUFFER0]; // Для отправки в последовательный порт
  57          xdata int r0, rk;
  58          bit flTransmiter;       
  59          
  60          //GPS
  61          #define NS      75
  62          xdata unsigned int GPStimepulse;
  63          xdata char mess [NS], r, w, mar;                // Для анализа посылки GPS
  64          bit flNewGPS;
  65          xdata unsigned int Vz, koors, flNoKoord, liTimer_tick_GPS, liTimer_tick;
  66          xdata unsigned long LatFly, LonFly;
  67          
  68          /*
  69          
  70          void LirQ(void)
  71          {
  72                  xdata char SFRPAGE_SAVE = SFRPAGE;
  73                  SFRPAGE = 0x00;
  74          
  75                          //Опрос ЛИР----------------------------
  76                  //      EA=0;
  77                          LirData = 0x0000;
  78                          //---init
  79                          LIR_SCK = 1;
  80                          LIR_SCK = 0;
  81                          //---D n-1
  82                          LIR_SCK = 1;
  83                          LIR_SCK = 0;
  84                          //---D n-1
  85                          LIR_SCK = 1;
  86                          LIR_SCK = 0;
  87                          if(LIR_DATA!=0) 
  88                          {
  89                                  LirData = LirData | (0x1 << (11));
  90                          }
  91                          LIR_SCK = 1; 
  92                          LIR_SCK = 0;
  93                          if(LIR_DATA!=0) 
  94                          {
  95                                  LirData = LirData | (0x1 << (10));
  96                          }
  97                          LIR_SCK = 1; 
  98                          LIR_SCK = 0;
  99                          if(LIR_DATA!=0) 
 100                          {
 101                                  LirData = LirData | (0x1 << (9));
 102                          }
 103                          LIR_SCK = 1; 
 104                          LIR_SCK = 0;
 105                          if(LIR_DATA!=0) 
 106                          {
 107                                  LirData = LirData | (0x1 << (8));
 108                          }
 109                          LIR_SCK = 1; 
 110                          LIR_SCK = 0;
 111                          if(LIR_DATA!=0) 
 112                          {
 113                                  LirData = LirData | (0x1 << (7));
 114                          }
 115                          LIR_SCK = 1; 
 116                          LIR_SCK = 0;
 117                          if(LIR_DATA!=0) 
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 3   

 118                          {
 119                                  LirData = LirData | (0x1 << (6));
 120                          }
 121                          LIR_SCK = 1; 
 122                          LIR_SCK = 0;
 123                          if(LIR_DATA!=0) 
 124                          {
 125                                  LirData = LirData | (0x1 << (5));
 126                          }
 127                          LIR_SCK = 1; 
 128                          LIR_SCK = 0;
 129                          if(LIR_DATA!=0) 
 130                          {
 131                                  LirData = LirData | (0x1 << (4));
 132                          }
 133                          LIR_SCK = 1; 
 134                          LIR_SCK = 0;
 135                          if(LIR_DATA!=0) 
 136                          {
 137                                  LirData = LirData | (0x1 << (3));
 138                          }
 139                          LIR_SCK = 1; 
 140                          LIR_SCK = 0;
 141                          if(LIR_DATA!=0) 
 142                          {
 143                                  LirData = LirData | (0x1 << (2));
 144                          }
 145                          LIR_SCK = 1; 
 146                          LIR_SCK = 0;
 147                          if(LIR_DATA!=0) 
 148                          {
 149                                  LirData = LirData | (0x1 << (1));
 150                          }
 151                          LIR_SCK = 1; 
 152                          LIR_SCK = 0;
 153                          if(LIR_DATA!=0) 
 154                          {
 155                                  LirData = LirData | (0x1 << (0));
 156                          }
 157                          LIR_SCK = 1; 
 158                  //      EA=1;
 159                  SFRPAGE = SFRPAGE_SAVE;
 160                  return;
 161          }*/
 162          //------------------------------------------------------------------------------------------
 163          
 164          
 165          /*
 166          void main(void)
 167          {
 168                  //---------
 169                  xdata unsigned int i;
 170                  INT Aint;
 171                  FLOAT Bfloat;
 172                  //UART----------
 173             xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 174                  unsigned int Value;
 175                  //--------------
 176             bit ValidGPS, flPoint;       
 177                  xdata unsigned char i_comma, tmpGPS[6], nLetter = 7;
 178                  xdata unsigned long temp_koord;
 179                  //SMBus---------
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 4   

 180                  unsigned char check;             // Used for testing purposes
 181                  //--------------
 182          
 183                  Init_Device();
 184          
 185                  LirTarget = 0x03ff;
 186                  Fdelta = 0;
 187                  flNewGPS = 0;
 188          
 189                  SM_BUSY = 0;                     // Free SMBus for first transfer.
 190             while(1)
 191                  {
 192                  
 193                  
 194          //расчет скорости ветра и угла--------------------------------------------------------------
 195                          if(VeterFlag)
 196                          {
 197                                  Vspeed = (float)FREQT0/((float)TV*0.75);
 198                                  Angle = 360. - (360.*(float)TV/(float)TA);
 199                                  VeterFlag = 0;
 200                          }
 201          
 202          //Опрос GPS---------------------------------------------------------------------------
 203          
 204                          if(flNewGPS)    
 205                          {
 206                                  flNewGPS = 0;
 207                          //Расшифровка посылки GPS
 208                                  if (r < w+mar*NS) 
 209                                  {
 210                                          if(mess[r] == '$')
 211                                          {
 212                          nLetter = 0;
 213                                          }
 214                          else if ((nLetter == 0) && (mess[r] == 'G'))
 215                          nLetter++;
 216                          else if ((nLetter == 1) && (mess[r] == 'P'))
 217                          nLetter++;
 218                          else if ((nLetter == 2) && (mess[r] == 'R'))
 219                          nLetter++;
 220                           else if ((nLetter == 3) && (mess[r] == 'M'))
 221                           nLetter++;
 222                     else if ((nLetter == 4) && (mess[r] == 'C'))
 223                          {
 224                          nLetter++;
 225                                                  i_comma = 0;
 226                                                  ValidGPS = 0;
 227                     } 
 228                                  else if(mess[r] == ',')
 229                                          {
 230                                                  i_comma++;
 231                                                  i = 0;
 232                                                  flPoint = 0;
 233                                          }
 234                                  else if(i_comma == 2)
 235                                          {
 236                                                  if(mess[r] == 'A') 
 237                                                          ValidGPS = 1;
 238                                                  else
 239                                                  {
 240                                                          ValidGPS = 0;
 241                  //                                      flNoKoord = 1;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 5   

 242                  //                                      liTimer_tick_GPS = liTimer_tick;
 243                                                  }
 244                                          }
 245                          else if (ValidGPS)
 246                                          {
 247                                                  if (i_comma == 3)                                       //Latitude
 248                                                  {
 249                                                          if(mess[r] == '.')
 250                                                          {
 251                                                                  flPoint = 1;
 252                                                                  i = 0;
 253                                                          }
 254                                                          else if (flPoint == 0)                                          //Целая часть
 255                                                          {
 256                                                                  tmpGPS[i++] = mess[r];
 257                                                                  if(i == 2)
 258                                                                  {
 259                                                  tmpGPS[i] = 0;
 260                                                                          temp_koord = atoi(tmpGPS);
 261                                                  temp_koord = 60UL*10000*temp_koord;
 262                                                                  }       
 263                                                                  else if(i == 4)
 264                                                                  {
 265                                                                          tmpGPS[0] = tmpGPS[1] = '0';
 266                                                  tmpGPS[i] = 0;
 267                                                  temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 268                                                                  }       
 269                                                          }
 270                                                          else                                                                                            //Дробная часть
 271                                                          {
 272                                                                  tmpGPS[i++] = mess[r];
 273                                          tmpGPS[i] = 0;
 274                                                          }
 275                                                  }
 276                                                  else if (i_comma == 4)
 277                                                  {
 278                                          temp_koord = temp_koord+atoi(tmpGPS);
 279          //-----------
 280          //lLatFly = 55UL*60*10000+50UL*10000+8680;
 281          //--------
 282                                                          if (mess[r] == 'S')                                             //знак Latitude
 283                                                                  LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 284                                                          else              
 285                                                                  LatFly = 54000000UL+temp_koord;         //90UL*60*10000+koord;
 286                                                  }
 287                                                  else if (i_comma == 5)                          //Longitude
 288                                                  {
 289                                                          if(mess[r] == '.')
 290                                                          {
 291                                                                  flPoint = 1;
 292                                                                  i = 0;
 293                                                          }
 294                                                          else if (flPoint == 0)                                          //Целая часть
 295                                                          {
 296                                                                  tmpGPS[i++] = mess[r];
 297                                                                  if(i == 3)
 298                                                                  {
 299                                                  tmpGPS[i] = 0;
 300                                                  temp_koord = atoi(tmpGPS);
 301                                                  temp_koord = 60UL*10000*temp_koord;
 302                                                                  }       
 303                                                                  else if(i == 5)
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 6   

 304                                                                  {
 305                                                                          tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 306                                                  tmpGPS[i] = 0;
 307                                                  temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 308                                                                  }       
 309                                                          }
 310                                                          else                                                                                            //Дробная часть
 311                                                          {
 312                                                                  tmpGPS[i++] = mess[r];
 313                                          tmpGPS[i] = 0;
 314                                                          }
 315                                                  }
 316                                                  else if (i_comma == 6)
 317                                                  {
 318                                          temp_koord = temp_koord+atoi(tmpGPS);
 319          //----------------
 320          //lLonFly = 49UL*60*10000+6UL*10000+3760;
 321          //----------------
 322                                                          if (mess[r] == 'W')                                             //знак Longitude
 323                                                                  LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 324                                                          else       
 325                                                                  LonFly = temp_koord+108000000UL;                //180UL*60*10000;
 326                                                  }
 327                                                  else if (i_comma == 7)                                                  //скорость в узлах
 328                                                  {
 329                                                          if(mess[r] == '.')
 330                                                          {
 331                                                                  flPoint = 1;
 332                                          Vz = 1.852*atoi(tmpGPS)/3.6;            //Преобразовать из узлов в м/с
 333          //---------
 334          //Vz = 20;
 335          //-----------
 336                                                          }
 337                                                          else if(flPoint == 0)
 338                                                          {
 339                                                                  tmpGPS[i++] = mess[r];
 340                                          tmpGPS[i] = 0;
 341                                                          }
 342                          }
 343                                                  else if (i_comma == 8)                                                  //курс в градусах
 344                                                  {
 345                                                          if(mess[r] == '.')
 346                                                          {
 347                                                                  flPoint = 1;
 348                                          koors = atoi(tmpGPS);
 349                                  if (koors < 0)
 350                                  koors = 360+koors;
 351                                                                  flNoKoord = 0;
 352                                                                  flNewGPS = 1;
 353                                                                  liTimer_tick_GPS = liTimer_tick;        
 354                  //                          OutModem20();
 355          //-----------                                              
 356          //koors = 30;
 357          //-----------
 358                                                          }
 359                                                          else if(flPoint == 0)
 360                                                          {
 361                                                                  tmpGPS[i++] = mess[r];
 362                                          tmpGPS[i] = 0;
 363                                                          }
 364                              }
 365                                          }
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 7   

 366                                          r++;
 367                                  if(r >= NS)
 368                                          {
 369                                  r = 0;
 370                                                  mar = 0;        
 371                                          }      
 372                                  }
 373                          }
 374                  
 375          //Опрос SMBus-------------------------------------------------------------------------
 376          
 377          if(u0timer>0xf0)
 378          {
 379                  SM_Send(CHIP_A, 0x00, 0x1e);      // Send CHIP, address, (data)
 380          //      SM_Send(CHIP_A, 0x00, 0x05);      // Send CHIP, address, (data)
 381          //      while(SMB0DAT!=0); 
 382          //      check = SM_Receive(CHIP_A, 0x00); // Read address on CHIP
 383          }
 384          
 385          
 386          //Работа с COM портом-----------------------------------------------------------------
 387          
 388                          if(u0timer>0xf0)
 389                          {
 390                                  u0timer = 0;
 391                                  //      ES0=1;
 392                                  if(wBFM > 4)
 393                                  {
 394                                          if(BuferFromModem [wBFM-1]==0x41)
 395                                          {
 396                                                  if(BuferFromModem [wBFM-4]==0x40)
 397                                                  {
 398                                                          Aint.b[0] = BuferFromModem[wBFM-3];
 399                                                          Aint.b[1] = BuferFromModem[wBFM-2];
 400                                                          if(Aint.i<=0x0fff)
 401                                                          {
 402                                                                  LirTarget = Aint.i;
 403                                                          }
 404                                                  }       
 405                                          }
 406                                          wBFM = 0;
 407                                  }
 408                                  //      TI0 = 1; //Read redy UART0
 409                                  //Write to UART0--------------------------------------
 410                                  Aint.i = LirData;
 411                                  BufferInModem[0] = 0x40+1;
 412                                  BufferInModem[1] = Aint.b[0];           
 413                                  BufferInModem[2] = Aint.b[1];
 414                                  Bfloat.f= Vspeed; 
 415                                  BufferInModem[3] = Bfloat.b[0];
 416                                  BufferInModem[4] = Bfloat.b[1];
 417                                  BufferInModem[5] = Bfloat.b[2];
 418                                  BufferInModem[6] = Bfloat.b[3];
 419                                  Bfloat.f= Angle;
 420                                  BufferInModem[7] = Bfloat.b[0];
 421                                  BufferInModem[8] = Bfloat.b[1];
 422                                  BufferInModem[9] = Bfloat.b[2];
 423                                  BufferInModem[10] = Bfloat.b[3];
 424                                  BufferInModem[11] = 0x40;
 425                             BufferInModem[12] = 0;
 426                          for (i = 0; i < 12; i++ )
 427                                  BufferInModem[12] = BufferInModem[12] ^ BufferInModem[i];
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 8   

 428                          BufferInModem[12] = 0x80 | BufferInModem[12];
 429          
 430                                  flTransmiter = 1;
 431                  
 432                          r0 = 0;
 433                                  rk = 13;
 434                                  SFRPAGE = 0x00;
 435          
 436                                  while (flTransmiter)
 437                                  {
 438                                          if(r0 < rk)
 439                                          {
 440                                                  flTransmiter = 1;
 441                                                  SBUF0 = BufferInModem[r0++];
 442                                          }
 443                                          else
 444                                          {
 445                                                  flTransmiter = 0;
 446                                          }
 447                                  }
 448                  //              ES0=0;
 449          
 450                  //------------------------------------------------------------
 451                  }
 452          }
 453          */
 454          /*
 455          //------------------------------------------------------------------------------------------
 456          //скорость ветра
 457          void INT0 (void) interrupt 0
 458          {
 459                  VeterFlag = 1;
 460                  TV = RTC - RTCV;
 461                  RTCV = RTC;
 462                  EX0 =   0;
 463                  return;
 464          }
 465          
 466          //------------------------------------------------------------------------------------
 467          void TIMER_ISR0 (void) interrupt 1
 468          {
 469                  xdata unsigned int i, delta, FdKoeff;
 470                  xdata char SFRPAGE_SAVE = SFRPAGE;
 471                  SFRPAGE = TIMER01_PAGE;
 472                  RTC++;
 473                  GPStimepulse++;
 474                  
 475                  if(GPStimepulse==0x4b00)
 476                  {
 477                          LED=1;
 478                  }
 479                  else if(GPStimepulse>0x5355)
 480                  {
 481                          LED=0;
 482                          GPStimepulse=0;
 483                  }
 484          //ветер-------------
 485                  if(WSpeed!=0)
 486                          EX0=1;
 487          
 488                  if(WAngle!=0)
 489                          EX1=1;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 9   

 490          
 491                  SFRPAGE = SFRPAGE_SAVE;
 492                  return;
 493          }
 494          
 495          
 496          
 497          //направление ветра-------------------------------------------------------------------
 498          void INT1 (void) interrupt 2
 499          {
 500                  VeterFlag = 1;
 501                  TA = RTC - RTCA;
 502                  RTCA = RTC;
 503                  EX1=0;
 504                  return;
 505          }
 506          
 507          //------------------------------------------------------------------------------------
 508          void TIMER_ISR1 (void) interrupt 3
 509          {
 510                  xdata char SFRPAGE_SAVE = SFRPAGE;
 511                  SFRPAGE = TIMER01_PAGE;
 512                  
 513                  SFRPAGE = SFRPAGE_SAVE;
 514                  return;
 515          }
 516          
 517          //-------------------------------------------------------------------
 518          void COM_UART0_isr(void) interrupt 4
 519          {
 520                  xdata char SFRPAGE_SAVE = SFRPAGE;
 521                  INT Aint;
 522                  SFRPAGE = UART0_PAGE;
 523          
 524                  if (RI0)
 525                  {
 526                          BuferFromModem [wBFM++] = SBUF0;  // read character
 527                          if(wBFM >= NBFM)
 528                          {
 529                          wBFM = 0;
 530                                  marBFM = 1;
 531                          }
 532                          RI0 = 0;
 533                  }
 534                  if (TI0)
 535                  {
 536                          if(flTransmiter == 0)
 537                                  TI0 = 0;        
 538                  }
 539          
 540                  SFRPAGE = UART1_PAGE;
 541                  if (RI1)
 542                  {
 543                          flNewGPS = 1;
 544                          mess [w++] = SBUF1;  // read character
 545                          if(w >= NS)
 546                          {
 547                          w = 0;
 548                                  mar = 1;
 549                          }
 550                          RI1 = 0;
 551                  }
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 10  

 552                  SFRPAGE = SFRPAGE_SAVE;
 553                  return;
 554          }
 555          
 556          //------------------------------------------------------------------------------------
 557          void SMBus_isr (void)interrupt 7
 558          {
 559                  xdata char SFRPAGE_SAVE = SFRPAGE;
 560                  SFRPAGE = SMB0_PAGE;
 561                  
 562             switch (SMB0STA){                   // Status code for the SMBus (SMB0STA register)
 563          
 564                // Master Transmitter/Receiver: START condition transmitted.
 565                // The R/W bit of the COMMAND word sent after this state will
 566                // always be a zero (W) because for both read and write,
 567                // the memory address must be written first.
 568                case SMB_START:
 569                   SMB0DAT = (COMMAND & 0xFE);   // Load address of the slave to be accessed.
 570                   STA = 0;                      // Manually clear START bit
 571                   break;
 572          
 573                // Master Transmitter/Receiver: Repeated START condition transmitted.
 574                // This state should only occur during a read, after the memory address has been
 575                // sent and acknowledged.
 576                case SMB_RP_START:
 577                   SMB0DAT = COMMAND;            // COMMAND should hold slave address + R.
 578                   STA = 0;
 579                   break;
 580          
 581                // Master Transmitter: Slave address + WRITE transmitted.  ACK received.
 582                case SMB_MTADDACK:
 583                   SMB0DAT = HIGH_ADD;           // Load high byte of memory address
 584                                                 // to be written.
 585                   break;
 586          
 587                // Master Transmitter: Slave address + WRITE transmitted.  NACK received.
 588                // The slave is not responding.  Send a STOP followed by a START to try again.
 589                case SMB_MTADDNACK:
 590                   STO = 1;
 591                   STA = 1;
 592                   break;
 593          
 594                // Master Transmitter: Data byte transmitted.  ACK received.
 595                // This state is used in both READ and WRITE operations.  Check BYTE_NUMBER
 596                // for memory address status - if only HIGH_ADD has been sent, load LOW_ADD.
 597                // If LOW_ADD has been sent, check COMMAND for R/W value to determine 
 598                // next state.
 599                case SMB_MTDBACK:
 600                   switch (BYTE_NUMBER){
 601                      case 2:                    // If BYTE_NUMBER=2, only HIGH_ADD
 602                         SMB0DAT = LOW_ADD;      // has been sent.
 603                         BYTE_NUMBER--;          // Decrement for next time around.
 604                         break;
 605                      case 1:                    // If BYTE_NUMBER=1, LOW_ADD was just sent.
 606                         if (COMMAND & 0x01){    // If R/W=READ, sent repeated START.
 607                            STO = 0;
 608                            STA = 1;
 609          
 610                         } else { 
 611                            SMB0DAT = WORD;      // If R/W=WRITE, load byte to write.
 612                            BYTE_NUMBER--;
 613                         }
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 11  

 614                         break;
 615                      default:                   // If BYTE_NUMBER=0, transfer is finished.
 616                         STO = 1;
 617                         SM_BUSY = 0;            // Free SMBus
 618                      }
 619                   break;
 620          
 621          
 622                // Master Transmitter: Data byte transmitted.  NACK received.
 623                // Slave not responding.  Send STOP followed by START to try again.
 624                case SMB_MTDBNACK:
 625                   STO = 1;
 626                   STA = 1;
 627                   break;
 628          
 629                // Master Transmitter: Arbitration lost.
 630                // Should not occur.  If so, restart transfer.
 631                case SMB_MTARBLOST:
 632                   STO = 1;
 633                   STA = 1;
 634                   break;
 635          
 636                // Master Receiver: Slave address + READ transmitted.  ACK received.
 637                // Set to transmit NACK after next transfer since it will be the last (only)
 638                // byte.
 639                case SMB_MRADDACK:
 640                   AA = 0;                       // NACK sent on acknowledge cycle.
 641                   break;
 642          
 643                // Master Receiver: Slave address + READ transmitted.  NACK received.
 644                // Slave not responding.  Send repeated start to try again.
 645                case SMB_MRADDNACK:
 646                   STO = 0;
 647                   STA = 1;
 648                   break;
 649          
 650                // Data byte received.  ACK transmitted.
 651                // State should not occur because AA is set to zero in previous state.
 652                // Send STOP if state does occur.
 653                case SMB_MRDBACK:
 654                   STO = 1;
 655                   SM_BUSY = 0;
 656                   break;
 657          
 658                // Data byte received.  NACK transmitted.
 659                // Read operation has completed.  Read data register and send STOP.
 660                case SMB_MRDBNACK:
 661                   WORD = SMB0DAT;
 662                   STO = 1;
 663                   SM_BUSY = 0;                  // Free SMBus
 664                   break;
 665          
 666                // All other status codes meaningless in this application. Reset communication.
 667                default:
 668                   STO = 1;                      // Reset communication.
 669                   SM_BUSY = 0;
 670                   break;
 671                }
 672          
 673             SI=0;                               // clear interrupt flag
 674          
 675                  SFRPAGE = SFRPAGE_SAVE;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 12  

 676                  return;
 677          }
 678          
 679          //------------------------------------------------------------------------------------
 680          void PCA_isr (void)interrupt 9
 681          {
 682                  xdata char SFRPAGE_SAVE = SFRPAGE;
 683                  SFRPAGE = PCA0_PAGE;
 684          //-------------------
 685                  u0timer++; // COM u0
 686          //      u1timer++; // GPS u1
 687          //-------------------   
 688                  CF = 0;
 689          //управление антеной------------------------------------------------------------------------
 690                          if(F==0x02)
 691                          {
 692                                  LirQ();
 693                                  delta = (LirTarget - LirData);  
 694                                  if(delta > 0xF000)
 695                                          delta = delta - 0xF000;
 696                                  if(delta >= 0x07FF)
 697                                  {
 698                                          delta = 0x0FFF - delta;
 699                                          if(delta < 0x0155)
 700                                          {
 701                                                  F = 0xC1;
 702                                                  if(delta < 0x20 && delta > 0x0B)
 703                                                  {
 704                                                          F = 0xC1;
 705                                                  }
 706                                                  else if(delta <= 0x0B)
 707                                                  {
 708                                                          F = 0x03; 
 709                                                  }
 710                                          }
 711                                          else
 712                                          {
 713                                                  F=0xA1;
 714                                          }
 715                                  }
 716                                  else if(delta < 0x07FF)
 717                                  {
 718                                          if(delta < 0x0155)
 719                                          {
 720                                                  F = 0xC2;
 721                                                  if(delta < 0x20 && delta > 0x0B)
 722                                                  {
 723                                                          F = 0xC2;
 724                                                  } 
 725                                                  else if(delta <= 0x0B)
 726                                                  {
 727                                                          F = 0x03; 
 728                                                  }
 729                                          }
 730                                          else
 731                                          {
 732                                                  F=0xA2;
 733                                          }
 734                                  }
 735                          }
 736                     if(LirData==0x0FFF)//при отключенном лир, воздействие отсутствует
 737                          {
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 13  

 738                                  F=0x03;
 739                          }
 740                          //ШИМы на машинку--------------------------
 741                          PCA0CPM0  = 0x43;
 742                          PCA0CPH0  = 0xFF;
 743                          PCA0CPL0  = 0xFF;
 744                          PCA0CPM1  = 0x43;
 745                          PCA0CPH1  = 0xFF;
 746                          PCA0CPL1  = 0xFF;
 747          
 748                          if(F==0xA1)
 749                          {
 750                                  PCA0CPM0  = 0x43;
 751                                  PCA0CPH0  = 0xC0;
 752                                  PCA0CPM1  = 0x43;
 753                                  PCA0CPH1  = 0xFF;
 754                                  PCA0CPL1  = 0xFF;
 755                                  Fdelta = Fdelta -  delta;
 756                                  if(Fdelta>0x0033)
 757                                  {
 758                                          PCA0CPM0  = 0x43;
 759                                          PCA0CPH0  = 0xf0;
 760                                          PCA0CPM1  = 0x43;
 761                                          PCA0CPH1  = 0xFF;
 762                                          PCA0CPL1  = 0xFF;
 763                                  }
 764                                  else
 765                                  {
 766                                          PCA0CPH0  = 0xC0 + Fdelta;
 767                                  }
 768                                  Fdelta = delta;
 769                          }
 770                          else if(F==0xA2)
 771                          {
 772                                  PCA0CPM1  = 0x43;
 773                                  PCA0CPH1  = 0xC0;
 774                                  PCA0CPM0  = 0x43;
 775                                  PCA0CPH0  = 0xFF;
 776                                  PCA0CPL0  = 0xFF;
 777                                  Fdelta = Fdelta -  delta;                       
 778                                  if(Fdelta>0x0033)
 779                                  {
 780                                          PCA0CPM1  = 0x43;
 781                                          PCA0CPH1  = 0xf0;
 782                                          PCA0CPM0  = 0x43;
 783                                          PCA0CPH0  = 0xFF;
 784                                          PCA0CPL0  = 0xFF;
 785                                  }
 786                                  else
 787                                  {
 788                                          PCA0CPH1  = 0xC0 + Fdelta;
 789                                  }
 790                                  Fdelta = delta;
 791                          }
 792                          else if(F==0xC1)
 793                          {
 794                                  PCA0CPM0  = 0x43;
 795                                  PCA0CPH0  = 0xe6;
 796                                  PCA0CPM1  = 0x43;
 797                                  PCA0CPH1  = 0xFF;
 798                                  PCA0CPL1  = 0xFF;
 799                                  Fdelta = Fdelta -  delta;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 14  

 800                                  if(Fdelta>0x0019)
 801                                  {
 802                                          PCA0CPM0  = 0x43;
 803                                          PCA0CPH0  = 0xFF;
 804                                          PCA0CPL0  = 0xFF;
 805                                          PCA0CPM1  = 0x43;
 806                                          PCA0CPH1  = 0xFF;
 807                                          PCA0CPL1  = 0xFF;
 808                                  }
 809                                  else
 810                                  {
 811                                          PCA0CPH0  = 0xe6 + Fdelta;
 812                                  }
 813                                  Fdelta = delta;
 814                          }
 815                          else if(F==0xC2)
 816                          {
 817                                  PCA0CPM1  = 0x43;
 818                                  PCA0CPH1  = 0xe6;
 819                                  PCA0CPM0  = 0x43;
 820                                  PCA0CPH0  = 0xFF;
 821                                  PCA0CPL0  = 0xFF;
 822                                  Fdelta = Fdelta -  delta;
 823                                  if(Fdelta>0x0019)
 824                                  {
 825                                          PCA0CPM0  = 0x43;
 826                                          PCA0CPH0  = 0xFF;
 827                                          PCA0CPL0  = 0xFF;
 828                                          PCA0CPM1  = 0x43;
 829                                          PCA0CPH1  = 0xFF;
 830                                          PCA0CPL1  = 0xFF;
 831                                  }
 832                                  else
 833                                  {
 834                                          PCA0CPH1  = 0xe6 + Fdelta;
 835                                  }
 836                                  Fdelta = delta;
 837                          }  
 838                          if(F==0x03)
 839                          {
 840                             PCA0CPM0  = 0x43;
 841                                  PCA0CPH0  = 0xFF;
 842                                  PCA0CPL0  = 0xFF;
 843                                  PCA0CPM1  = 0x43;
 844                                  PCA0CPH1  = 0xFF;
 845                                  PCA0CPL1  = 0xFF;
 846                          }
 847                          F=0x02;
 848                  SFRPAGE = SFRPAGE_SAVE;
 849                  return;
 850          }
 851          //------------------------------------------------------------------------------------
 852          void TIMER_ISR3 (void) interrupt 14
 853          {
 854                  xdata char SFRPAGE_SAVE = SFRPAGE;
 855                  SFRPAGE = TMR3_PAGE;
 856          
 857                  SFRPAGE = SFRPAGE_SAVE;
 858                  return;
 859          }
 860          //-------------------------------------------------------------------
 861          void GPS_UART1_isr(void) interrupt 20
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 15  

 862          {
 863                  xdata char SFRPAGE_SAVE = SFRPAGE;
 864                  SFRPAGE = UART1_PAGE;
 865                  if (RI1)
 866                  {
 867                          flNewGPS = 1;
 868                          mess [w++] = SBUF1;  // read character
 869                          if(w >= NS)
 870                          {
 871                          w = 0;
 872                                  mar = 1;
 873                          }
 874                          RI1 = 0;
 875                  }
 876                  if (TI1)
 877                  {
 878                                  
 879                  }
 880          
 881                  SFRPAGE = SFRPAGE_SAVE;
 882                  return;
 883          }*/
 884          //SMB begin----------------------------------------------------------------
 885          /*
 886          //SMBus
 887          #define WRITE 0x00                  // SMBus WRITE command
 888          #define READ  0x01                  // SMBus READ command
 889          // Device addresses (7 bits, lsb is a don't care)
 890          #define CHIP_A 0x00                 // Device address for chip A
 891          #define CHIP_B 0x80                 // Device address for chip B
 892          #define CHIP_C 0xA0                 // Device address for chip C
 893          
 894          // SMBus states:
 895          // MT = Master Transmitter
 896          // MR = Master Receiver
 897          #define  SMB_BUS_ERROR  0x00        // (all modes) BUS ERROR
 898          #define  SMB_START      0x08        // (MT & MR) START transmitted
 899          #define  SMB_RP_START   0x10        // (MT & MR) repeated START
 900          #define  SMB_MTADDACK   0x18        // (MT) Slave address + W transmitted;
 901                                              //  ACK received
 902          #define  SMB_MTADDNACK  0x20        // (MT) Slave address + W transmitted;
 903                                              //  NACK received
 904          #define  SMB_MTDBACK    0x28        // (MT) data byte transmitted; ACK rec'vd
 905          #define  SMB_MTDBNACK   0x30        // (MT) data byte transmitted; NACK rec'vd
 906          #define  SMB_MTARBLOST  0x38        // (MT) arbitration lost
 907          #define  SMB_MRADDACK   0x40        // (MR) Slave address + R transmitted;
 908                                              //  ACK received
 909          #define  SMB_MRADDNACK  0x48        // (MR) Slave address + R transmitted;
 910                                              //  NACK received
 911          #define  SMB_MRDBACK    0x50        // (MR) data byte rec'vd; ACK transmitted
 912          #define  SMB_MRDBNACK   0x58        // (MR) data byte rec'vd; NACK transmitted
 913          
 914          char COMMAND;                       // Holds the slave address + R/W bit for
 915                                              // use in the SMBus ISR.
 916          
 917          char WORD;                          // Holds data to be transmitted by the SMBus
 918                                              // OR data that has just been received.
 919          
 920          char BYTE_NUMBER;                   // Used by ISR to check what data has just been
 921                                              // sent - High address byte, Low byte, or data
 922                                              // byte
 923          
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 16  

 924          unsigned char HIGH_ADD, LOW_ADD;    // High & Low byte for EEPROM memory address
 925          
 926          bit SM_BUSY;                        // This bit is set when a send or receive
 927                                              // is started. It is cleared by the
 928                                              // ISR when the operation is finished.
 929          
 930          xdata unsigned int Humidity, Temperature, i_measure;
 931          
 932          
 933          
 934          void nop(void)
 935          {
 936          _nop_();
 937          _nop_();
 938          _nop_();
 939          _nop_();
 940          _nop_();
 941          _nop_();
 942          _nop_();
 943          _nop_();
 944          _nop_();
 945          _nop_();
 946          _nop_();
 947          _nop_();
 948          _nop_();
 949          _nop_();
 950          }
 951          // SMBus byte write function-----------------------------------------------------
 952          // Writes a single byte at the specified memory location.
 953          //
 954          // out_byte = data byte to be written
 955          // byte_address = memory location to be written into (2 bytes)
 956          // chip_select = device address of EEPROM chip to be written to
 957          void SM_Send (char chip_select, unsigned int byte_address, char out_byte)
 958          {
 959             unsigned int i;
 960                  xdata unsigned int timesmb;
 961                  timesmb =0;
 962                  while (SM_BUSY);  
 963                  {       
 964                          timesmb++;
 965                          for(i=0; i<40; i++)
 966                          {       
 967                                  nop();
 968                          }
 969                          if(timesmb==0xfffc){SM_BUSY = 0;}
 970                  };                        // Wait for SMBus to be free.
 971             SM_BUSY = 1;                              // Occupy SMBus (set to busy)
 972             SMB0CN = 0x44;                            // SMBus enabled,
 973                                                       // ACK on acknowledge cycle
 974          
 975             BYTE_NUMBER = 2;                          // 2 address bytes.
 976             COMMAND = (chip_select | WRITE);          // Chip select + WRITE
 977          
 978             HIGH_ADD = ((byte_address >> 8) & 0x00FF);// Upper 8 address bits
 979             LOW_ADD = (byte_address & 0x00FF);        // Lower 8 address bits
 980          
 981             WORD = out_byte;                          // Data to be writen
 982             
 983             STO = 0;
 984             STA = 1;                                  // Start transfer
 985          }
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 17  

 986          
 987          // SMBus random read function------------------------------------------------------
 988          // Reads 1 byte from the specified memory location.
 989          //
 990          // byte_address = memory address of byte to read
 991          // chip_select = device address of EEPROM to be read from
 992          char SM_Receive (char chip_select, unsigned int byte_address)
 993          {
 994             unsigned int i;
 995                  xdata unsigned int timesmb;
 996                  SFRPAGE   = SMB0_PAGE;
 997                  timesmb =0; 
 998                  while (SM_BUSY)
 999                  {       
1000                          timesmb++;
1001                          for(i=0; i<40; i++)
1002                          {       
1003                                  nop();
1004                          }
1005                          if(timesmb==0xfffc){SM_BUSY = 0;}
1006                  };                          // Wait for bus to be free.
1007             SM_BUSY = 1;                              // Occupy SMBus (set to busy)
1008                  SMB0CN = 0x44;                            // SMBus enabled, ACK on acknowledge cycle
1009          
1010             BYTE_NUMBER = 2;                          // 2 address bytes
1011             COMMAND = (chip_select | READ);           // Chip select + READ
1012          
1013             HIGH_ADD = ((byte_address >> 8) & 0x00FF);// Upper 8 address bits
1014             LOW_ADD = (byte_address & 0x00FF);        // Lower 8 address bits
1015             
1016             STO = 0;
1017             STA = 1;   
1018                  timesmb =0;                               // Start transfer
1019                  while (SM_BUSY)
1020                  {
1021                          timesmb++;
1022                          for(i=0; i<40; i++)
1023                          {       
1024                                  nop();
1025                          }
1026                          if(timesmb==0xfffc){SM_BUSY = 0;}
1027                  };                          // Wait for transfer to finish
1028             return WORD;
1029          }
1030          //------------------------------------------------------------------------------
1031          
1032          
1033          void main(void)
1034          {
1035                  unsigned char check;
1036                  unsigned int i;
1037                  Init_Device(); 
1038                  SM_BUSY = 0;   
1039                  while(1)
1040                  {
1041                          SM_Send(CHIP_A, 0x00, 0x03);            // Send CHIP, address, (data)
1042                          for(i=0; i<40000; i++)
1043                          {       
1044                                  nop();
1045                                  nop();
1046                                  nop();
1047                          }
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 18  

1048                          check = SM_Receive(CHIP_A, 0x00);// Read address on CHIP
1049                          for(i=0; i<40000; i++)
1050                          {       
1051                                  nop();
1052                                  nop();
1053                                  nop();
1054                          }
1055                  }
1056          }
1057          
1058          void SMBus_isr (void)interrupt 7
1059          {
1060                  xdata char SFRPAGE_SAVE = SFRPAGE;
1061                  SFRPAGE = SMB0_PAGE;
1062                  
1063             switch (SMB0STA){                   // Status code for the SMBus (SMB0STA register)
1064          
1065                // Master Transmitter/Receiver: START condition transmitted.
1066                // The R/W bit of the COMMAND word sent after this state will
1067                // always be a zero (W) because for both read and write,
1068                // the memory address must be written first.
1069                case SMB_START:
1070                   SMB0DAT = (COMMAND & 0xFE);   // Load address of the slave to be accessed.
1071                   STA = 0;                      // Manually clear START bit
1072                   break;
1073          
1074                // Master Transmitter/Receiver: Repeated START condition transmitted.
1075                // This state should only occur during a read, after the memory address has been
1076                // sent and acknowledged.
1077                case SMB_RP_START:
1078                   SMB0DAT = COMMAND;            // COMMAND should hold slave address + R.
1079                   STA = 0;
1080                   break;
1081          
1082                // Master Transmitter: Slave address + WRITE transmitted.  ACK received.
1083                case SMB_MTADDACK:
1084                   SMB0DAT = HIGH_ADD;           // Load high byte of memory address
1085                                                 // to be written.
1086                   break;
1087          
1088                // Master Transmitter: Slave address + WRITE transmitted.  NACK received.
1089                // The slave is not responding.  Send a STOP followed by a START to try again.
1090                case SMB_MTADDNACK:
1091                   STO = 1;
1092                   STA = 1;
1093                   break;
1094          
1095                // Master Transmitter: Data byte transmitted.  ACK received.
1096                // This state is used in both READ and WRITE operations.  Check BYTE_NUMBER
1097                // for memory address status - if only HIGH_ADD has been sent, load LOW_ADD.
1098                // If LOW_ADD has been sent, check COMMAND for R/W value to determine 
1099                // next state.
1100                case SMB_MTDBACK:
1101                   switch (BYTE_NUMBER){
1102                      case 2:                    // If BYTE_NUMBER=2, only HIGH_ADD
1103                         SMB0DAT = LOW_ADD;      // has been sent.
1104                         BYTE_NUMBER--;          // Decrement for next time around.
1105                         break;
1106                      case 1:                    // If BYTE_NUMBER=1, LOW_ADD was just sent.
1107                         if (COMMAND & 0x01){    // If R/W=READ, sent repeated START.
1108                            STO = 0;
1109                            STA = 1;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 19  

1110          
1111                         } else { 
1112                            SMB0DAT = WORD;      // If R/W=WRITE, load byte to write.
1113                            BYTE_NUMBER--;
1114                         }
1115                         break;
1116                      default:                   // If BYTE_NUMBER=0, transfer is finished.
1117                         STO = 1;
1118                         SM_BUSY = 0;            // Free SMBus
1119                      }
1120                   break;
1121          
1122          
1123                // Master Transmitter: Data byte transmitted.  NACK received.
1124                // Slave not responding.  Send STOP followed by START to try again.
1125                case SMB_MTDBNACK:
1126                   STO = 1;
1127                   STA = 1;
1128                   break;
1129          
1130                // Master Transmitter: Arbitration lost.
1131                // Should not occur.  If so, restart transfer.
1132                case SMB_MTARBLOST:
1133                   STO = 1;
1134                   STA = 1;
1135                   break;
1136          
1137                // Master Receiver: Slave address + READ transmitted.  ACK received.
1138                // Set to transmit NACK after next transfer since it will be the last (only)
1139                // byte.
1140                case SMB_MRADDACK:
1141                   AA = 0;                       // NACK sent on acknowledge cycle.
1142                   break;
1143          
1144                // Master Receiver: Slave address + READ transmitted.  NACK received.
1145                // Slave not responding.  Send repeated start to try again.
1146                case SMB_MRADDNACK:
1147                   STO = 0;
1148                   STA = 1;
1149                   break;
1150          
1151                // Data byte received.  ACK transmitted.
1152                // State should not occur because AA is set to zero in previous state.
1153                // Send STOP if state does occur.
1154                case SMB_MRDBACK:
1155                   STO = 1;
1156                   SM_BUSY = 0;
1157                   break;
1158          
1159                // Data byte received.  NACK transmitted.
1160                // Read operation has completed.  Read data register and send STOP.
1161                case SMB_MRDBNACK:
1162                   WORD = SMB0DAT;
1163                   STO = 1;
1164                   SM_BUSY = 0;                  // Free SMBus
1165                   break;
1166          
1167                // All other status codes meaningless in this application. Reset communication.
1168                default:
1169                   STO = 1;                      // Reset communication.
1170                   SM_BUSY = 0;
1171                   break;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 20  

1172                }
1173          
1174             SI=0;                               // clear interrupt flag
1175          
1176                  SFRPAGE = SFRPAGE_SAVE;
1177                  return;
1178          }
1179          */
1180          //SMBend------------------------------------------------------------------------------
1181          
1182          
1183          #define  BYTE     char
1184          #define DATA            LED
1185          #define SCK             LED2
1186          //#define       DATAOUT 0x02
1187          //#define       DATAIN  0xFD
1188          
1189          #define noACK 0
1190          #define ACK 1
1191          //adr command r/w
1192          #define STATUS_REG_W 0x06 //000 0011 0
1193          #define STATUS_REG_R 0x07 //000 0011 1
1194          #define MEASURE_TEMP 0x03 //000 0001 1
1195          #define MEASURE_HUMI 0x05 //000 0010 1
1196          #define RESET 0x1e //000 1111 0
1197          
1198          
1199          #define C1      -4.0            // for 12 Bit
1200          #define C2      0.0405          // for 12 Bit
1201          #define C3      -0.0000028      // for 12 Bit
1202          #define T1      0.01            // for 14 Bit @ 5V
1203          #define T2      0.00008         // for 14 Bit @ 5V
1204          
1205          float temp, rh, dp;
1206          
1207          void SHTInit(void);
1208          void nop(void);
1209          BYTE reverse(BYTE b);
1210          char s_write_byte(unsigned char value);
1211          BYTE    SHTAskMeasurement(BYTE mode);
1212          BYTE    SHTGetMeasurementNoCrc(float *value);
1213          BYTE    SHTGetMeasurementCrc(float *value);
1214          
1215          BYTE    crc;
1216          BYTE    StartCrc;
1217          
1218          xdata int TempHumTimer;
1219          
1220          void SHTInit(void)
1221          {
1222   1              StartCrc = 0;
1223   1      }
1224          //----------------------------------------------------------------------------------
1225          // writes a byte on the Sensibus and checks the acknowledge
1226          char s_write_byte(unsigned char value)
1227          {
1228   1      unsigned char i,error=0;
1229   1      //P1MDOUT |= DATAOUT;
1230   1      for (i=0x80;i>0;i/=2) //shift bit for masking
1231   1      { 
1232   2              if (i & value) DATA=1; //masking value with i , write to SENSI-BUS
1233   2              else DATA=0;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 21  

1234   2              SCK=1; //clk for SENSI-BUS
1235   2              nop();nop();nop(); //pulswith approx. 5 us
1236   2              SCK=0;
1237   2      }
1238   1      //P1MDOUT &= DATAIN;
1239   1      DATA=1; //release DATA-line
1240   1      SCK=1; //clk #9 for ack
1241   1      error=DATA; //check ack (DATA will be pulled down by SHT11)
1242   1      SCK=0;
1243   1      return error; //error=1 in case of no acknowledge
1244   1      }
1245          
1246          //----------------------------------------------------------------------------------
1247          // reads a byte form the Sensibus and gives an acknowledge in case of "ack=1"
1248          char s_read_byte(unsigned char ack)
1249          {
1250   1      unsigned char i,val=0;
1251   1      
1252   1      DATA=1; //release DATA-line
1253   1      for (i=0x80;i>0;i/=2) //shift bit for masking
1254   1      {
1255   2               SCK=1; //clk for SENSI-BUS
1256   2               nop();
1257   2              if (DATA) val=(val | i); //read bit
1258   2              nop();
1259   2              SCK=0;
1260   2      }
1261   1      //P1MDOUT |= DATAOUT;
1262   1      DATA=!ack; //in case of "ack==1" pull down DATA-Line
1263   1      SCK=1; //clk #9 for ack
1264   1      nop();nop();nop(); //pulswith approx. 5 us
1265   1      SCK=0;
1266   1      //P1MDOUT &= DATAIN;
1267   1      DATA=1; //release DATA-line
1268   1      
1269   1      return val;
1270   1      }
1271          
1272          //----------------------------------------------------------------------------------
1273          void s_transstart(void)
1274          //----------------------------------------------------------------------------------
1275          // generates a transmission start
1276          //              _____             ________
1277          // DATA:      |_______|
1278          //                  ___            ___
1279          // SCK : ___|   |___|   |______
1280          {
1281   1      //P1MDOUT |= DATAOUT;
1282   1      DATA=1; SCK=0; //Initial state
1283   1      nop();
1284   1      SCK=1;
1285   1      nop();
1286   1      DATA=0;
1287   1      nop();
1288   1      SCK=0;
1289   1      nop();nop();nop();
1290   1      SCK=1;
1291   1      nop();
1292   1      DATA=1;
1293   1      nop();
1294   1      SCK=0;
1295   1      //P1MDOUT &= DATAIN;
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 22  

1296   1      }
1297          
1298          //----------------------------------------------------------------------------------
1299          void s_connectionreset(void)
1300          //----------------------------------------------------------------------------------
1301          // communication reset: DATA-line=1 and at least 9 SCK cycles followed by transstart
1302          //              _____________________________________________________                   ________
1303          // DATA:                                                                                                                                 |_______|
1304          //                      _         _      _      _         _      _      _         _      _               ___            ___
1305          // SCK : __| |__| |__| |__| |__| |__| |__| |__| |__| |______|   |___|   |______
1306          {
1307   1      unsigned char i;
1308   1      //P1MDOUT |= DATAOUT;
1309   1      DATA=1; 
1310   1      SCK=0; //Initial state
1311   1      for(i=0;i<9;i++) //9 SCK cycles
1312   1      { 
1313   2              SCK=1;
1314   2              nop();
1315   2              SCK=0;
1316   2              nop();
1317   2      }
1318   1      s_transstart(); //transmission start
1319   1      }
1320          
1321          //----------------------------------------------------------------------------------
1322          BYTE s_softreset(void)
1323          //----------------------------------------------------------------------------------
1324          // resets the sensor by a softreset
1325          {
1326   1      unsigned char error=0;
1327   1      s_connectionreset(); //reset communication
1328   1      error+=s_write_byte(RESET); //send RESET-command to sensor
1329   1      return error; //error=1 in case of no response form the sensor
1330   1      }
1331          
1332          
1333          
1334          float   calcTemp(float t)
1335          {
1336   1      return (t*0.01 - 40);   //calc. Temperature from ticks to [oC]
1337   1      }
1338          
1339          
1340          
1341          float   calcRH(float rh, float tc)
1342          {
1343   1      float rh_lin; // rh_lin: Humidity linear
1344   1      float rh_true; // rh_true: Temperature compensated humidity
1345   1      
1346   1      rh_lin=(C3 *rh + C2)*rh + C1; //calc. Humidity from ticks to [%RH]
1347   1      rh_true=(tc-25)*(T1+T2*rh)+rh_lin; //calc. Temperature compensated humidity [%RH]
1348   1      if(rh_true>100.0)rh_true=100.0; //cut if the value is outside of
1349   1      if(rh_true<0.1)rh_true=0.1; //the physical possible range
1350   1      return  rh_true; 
1351   1      }
1352          
1353          //--------------------------------------------------------------------
1354          float calc_dewpoint(float h,float t)
1355          //--------------------------------------------------------------------
1356          // calculates dew point
1357          // input: humidity [%RH], temperature [oC]
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 23  

1358          // output: dew point [oC]
1359          { 
1360   1              float k,dew_point ;
1361   1      
1362   1              k = (log10(h)-2)/0.4343 + (17.62*t)/(243.12+t);
1363   1              dew_point = 243.12*k/(17.62-k);
1364   1              return dew_point;
1365   1      }
1366          
1367          
1368          
1369          BYTE    sht(BYTE        task)
1370          {
1371   1      BYTE    error = 0;
1372   1      float   val;
1373   1              switch(task)
1374   1              {
1375   2              case 0: //Ask for temperature
1376   2              error += SHTAskMeasurement(MEASURE_TEMP);
1377   2              break;
1378   2              case 1: //Get temperature results
1379   2              error += SHTGetMeasurementNoCrc(&val);
1380   2              if(!error) temp = calcTemp(val);
1381   2              return  error;
1382   2              break;
1383   2              case 2: //Ask for humidity
1384   2              error +=        SHTAskMeasurement(MEASURE_HUMI);
1385   2              break;
1386   2              case 3:
1387   2              return 0;
1388   2              break;
1389   2              case 4: //Get humidity result
1390   2              error += SHTGetMeasurementNoCrc(&val);
1391   2              if(!error)
1392   2              {
1393   3              rh = calcRH(val,temp);
1394   3              dp = calc_dewpoint(rh,temp);
1395   3              }
1396   2              return  error;
1397   2              break;
1398   2              default:
1399   2              return  0x80;
1400   2              break;
1401   2              }
1402   1              return  error;
1403   1      }
1404          
1405          BYTE    SHTAskMeasurement(BYTE mode)
1406          {
1407   1              BYTE error = 0;
1408   1              s_transstart(); //transmission start
1409   1              error+=s_write_byte(mode);
1410   1      //      crc = CrcByte(mode,StartCrc);
1411   1              return error;
1412   1      }
1413          
1414          BYTE    SHTGetMeasurementNoCrc(float *value)
1415          {
1416   1              BYTE error = 0;
1417   1              unsigned int i;
1418   1              unsigned int result = 0;
1419   1              for (i=0;i<65535;i++) 
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 24  

1420   1              {
1421   2                      nop();
1422   2                      if(DATA==0) break; //wait until sensor has finished the measurement
1423   2              }
1424   1              if(DATA) error++; // or timeout (~2 sec.) is reached
1425   1              result = 0x100 * s_read_byte(ACK); //read the first byte (MSB)
1426   1              result += s_read_byte(noACK); //read the second byte (LSB)
1427   1              s_read_byte(noACK); //read checksum
1428   1              *value = (float)result;
1429   1              return error;
1430   1      }
1431          
1432          BYTE    SHTGetMeasurementCrc(float *value)
1433          {
1434   1              BYTE error = 0;
1435   1              unsigned int i;
1436   1              BYTE b;
1437   1              unsigned int result = 0;
1438   1              for (i=0;i<65535;i++) 
1439   1              {
1440   2                      nop();
1441   2                      if(DATA==0) break; //wait until sensor has finished the measurement
1442   2              }
1443   1              if(DATA) error++; // or timeout (~2 sec.) is reached
1444   1              b = s_read_byte(ACK); //read the first byte (MSB)
1445   1      //      crc = CrcByte(b,crc);
1446   1              result = 0x100 * b; 
1447   1              b = s_read_byte(ACK); //read the second byte (LSB)
1448   1      //      crc = CrcByte(b,crc);
1449   1              result += b; 
1450   1              b = s_read_byte(noACK); //read checksum
1451   1              b = reverse(b);
1452   1              //if(b != crc) error++;
1453   1              *value = (float)result;
1454   1              return error;
1455   1      }
1456          
1457          BYTE reverse(BYTE c)
1458          {
1459   1              c = (c & 0x0F) << 4 | (c & 0xF0) >> 4;
1460   1              c = (c & 0x33) << 2 | (c & 0xCC) >> 2;
1461   1              c = (c & 0x55) << 1 | (c & 0xAA) >> 1;
1462   1              return c;
1463   1      }
1464          
1465          void nop(void)
1466          {
1467   1      _nop_();
1468   1      _nop_();
1469   1      _nop_();
1470   1      _nop_();
1471   1      _nop_();
1472   1      _nop_();
1473   1      _nop_();
1474   1      _nop_();
1475   1      _nop_();
1476   1      _nop_();
1477   1      _nop_();
1478   1      _nop_();
1479   1      }
1480          
1481          void main(void)
C51 COMPILER V9.00   SERVO3                                                                09/18/2012 15:37:31 PAGE 25  

1482          {
1483   1              unsigned int i;
1484   1      
1485   1              SFRPAGE = 0x00;
1486   1      
1487   1              Init_Device(); 
1488   1              TempHumTimer=0;
1489   1              while(1)
1490   1              {
1491   2                      if(TempHumTimer==5)
1492   2                      {
1493   3                              s_connectionreset();
1494   3                              TempHumTimer=0;
1495   3                      }
1496   2                      sht(TempHumTimer++);
1497   2                      for(i=0; i<40000; i++)
1498   2                      {       
1499   3                              nop();
1500   3                              nop();
1501   3                              nop();
1502   3                              nop();
1503   3                              nop();
1504   3                              nop();
1505   3                              nop();
1506   3                              nop();
1507   3                              nop();
1508   3                              nop();
1509   3                              nop();
1510   3                              nop();
1511   3                      }
1512   2              }
1513   1      }
1514          
1515          //------------------------------------------------------------------------------------------
1516          //#endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1247    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      65
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
