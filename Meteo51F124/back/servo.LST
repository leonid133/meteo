C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SERVO
OBJECT MODULE PLACED IN servo.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe servo.c DB OE BR

line level    source

   1          #include "c8051f120.h"
   2          #include "init.h"
   3          #include "comport.h"
   4          #include <intrins.h>
   5          #include <stdio.h>                     
   6          #include <ctype.h>
   7          
   8          #define SYSCLK 24500000 //Hz
   9          #define FREQT0 8006 //Hz
  10          
  11          //отладочные
  12          sbit LED = P1^6;
  13          sbit LED2 = P2^6;
  14          sbit BUTTON = P3^7;
  15          xdata unsigned char InitFlag;
  16          //--------------
  17          //лир
  18          sbit LIR_DATA = P2^0;
  19          sbit LIR_SCK = P2^1;
  20          
  21          xdata unsigned char F;
  22          xdata unsigned int delta, LirData, LirTarget, Fdelta;
  23          
  24          typedef union INT {                   
  25             unsigned int i;
  26             unsigned char b[2];
  27          } INT;
  28          //---
  29          //ветер
  30          sbit WSpeed = P1^1;
  31          sbit WAngle = P1^3;
  32          
  33          xdata float Vspeed, Angle;
  34          xdata unsigned long RTC, RTCV, RTCA;
  35          xdata unsigned long TV,TA;
  36          
  37          typedef union FLOAT {                   
  38             float f;
  39             unsigned char b[4];
  40          } FLOAT;
  41          //-----
  42          //UART0
  43          #define NBFM            50
  44          xdata unsigned char BuferFromModem [NBFM]; 
  45          xdata unsigned char wBFM, rBFM, marBFM, u0timer;
  46          
  47          #define SIZE_BUFFER0            50
  48          xdata char BufferInModem[SIZE_BUFFER0]; // Для отправки в последовательный порт
  49          xdata int r0, rk;
  50          bit flTransmiter;       
  51          
  52          #define NS      75
  53          xdata char mess [NS], r, w, mar;                // Для анализа посылки GPS
  54          
  55          //------------------------------------------------------------------------------
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 2   

  56          void OutModem1(unsigned char Data, char i)
  57          {
  58   1              BufferInModem[i] = Data | 0x80;
  59   1      }
  60          
  61          //------------------------------------------------------------------------------
  62          void OutModem2(unsigned int Data, char i)
  63          {
  64   1              BufferInModem[i] = (Data & 0x007f)| 0x80;
  65   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7)| 0x80;
  66   1      }
  67          
  68          //------------------------------------------------------------------------------
  69          void OutModem4(unsigned long int Data, char i)
  70          {
  71   1              BufferInModem[i] = (Data & 0x0000007f)| 0x80;
  72   1              BufferInModem[i+1] = ((Data & 0x3f80) >> 7) | 0x80;
  73   1              BufferInModem[i+2] = ((Data & 0x1fc000) >> 14) | 0x80;
  74   1         BufferInModem[i+3] = ((Data & 0xfe00000)>> 21) | 0x80;
  75   1      }
  76          //------------------------------------------------------------------------------------------
  77          void LirQ(void)
  78          {
  79   1                      //Опрос ЛИР----------------------------
  80   1                      EA=0;
  81   1                      LirData = 0x0000;
  82   1                      //---init
  83   1                      LIR_SCK = 1;
  84   1                      LIR_SCK = 0;
  85   1                      //---D n-1
  86   1                      LIR_SCK = 1;
  87   1                      LIR_SCK = 0;
  88   1                      //---D n-1
  89   1                      LIR_SCK = 1;
  90   1                      LIR_SCK = 0;
  91   1                      if(LIR_DATA!=0) 
  92   1                      {
  93   2                              LirData = LirData | (0x1 << (11));
  94   2                      }
  95   1                      LIR_SCK = 1; 
  96   1                      LIR_SCK = 0;
  97   1                      if(LIR_DATA!=0) 
  98   1                      {
  99   2                              LirData = LirData | (0x1 << (10));
 100   2                      }
 101   1                      LIR_SCK = 1; 
 102   1                      LIR_SCK = 0;
 103   1                      if(LIR_DATA!=0) 
 104   1                      {
 105   2                              LirData = LirData | (0x1 << (9));
 106   2                      }
 107   1                      LIR_SCK = 1; 
 108   1                      LIR_SCK = 0;
 109   1                      if(LIR_DATA!=0) 
 110   1                      {
 111   2                              LirData = LirData | (0x1 << (8));
 112   2                      }
 113   1                      LIR_SCK = 1; 
 114   1                      LIR_SCK = 0;
 115   1                      if(LIR_DATA!=0) 
 116   1                      {
 117   2                              LirData = LirData | (0x1 << (7));
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 3   

 118   2                      }
 119   1                      LIR_SCK = 1; 
 120   1                      LIR_SCK = 0;
 121   1                      if(LIR_DATA!=0) 
 122   1                      {
 123   2                              LirData = LirData | (0x1 << (6));
 124   2                      }
 125   1                      LIR_SCK = 1; 
 126   1                      LIR_SCK = 0;
 127   1                      if(LIR_DATA!=0) 
 128   1                      {
 129   2                              LirData = LirData | (0x1 << (5));
 130   2                      }
 131   1                      LIR_SCK = 1; 
 132   1                      LIR_SCK = 0;
 133   1                      if(LIR_DATA!=0) 
 134   1                      {
 135   2                              LirData = LirData | (0x1 << (4));
 136   2                      }
 137   1                      LIR_SCK = 1; 
 138   1                      LIR_SCK = 0;
 139   1                      if(LIR_DATA!=0) 
 140   1                      {
 141   2                              LirData = LirData | (0x1 << (3));
 142   2                      }
 143   1                      LIR_SCK = 1; 
 144   1                      LIR_SCK = 0;
 145   1                      if(LIR_DATA!=0) 
 146   1                      {
 147   2                              LirData = LirData | (0x1 << (2));
 148   2                      }
 149   1                      LIR_SCK = 1; 
 150   1                      LIR_SCK = 0;
 151   1                      if(LIR_DATA!=0) 
 152   1                      {
 153   2                              LirData = LirData | (0x1 << (1));
 154   2                      }
 155   1                      LIR_SCK = 1; 
 156   1                      LIR_SCK = 0;
 157   1                      if(LIR_DATA!=0) 
 158   1                      {
 159   2                              LirData = LirData | (0x1 << (0));
 160   2                      }
 161   1                      LIR_SCK = 1; 
 162   1                      EA=1;
 163   1                      //---------------------------------------
 164   1      }
 165          //------------------------------------------------------------------------------------------
 166          
 167          void main(void)
 168          {
 169   1              //LIR------
 170   1              xdata unsigned char FdKoeff;
 171   1              //---------
 172   1              xdata unsigned int i;
 173   1              INT Aint;
 174   1              FLOAT Bfloat;
 175   1              //UART----------
 176   1         xdata char RK_code[26], nByte = 0, KontrSumma = 0, PWM;
 177   1              unsigned int Value;
 178   1      
 179   1              //--------------
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 4   

 180   1       /*  bit ValidGPS, flPoint;     
 181   1              xdata unsigned char i, i_comma, tmpGPS[6], nLetter = 7;
 182   1              xdata unsigned long temp_koord;*/
 183   1      
 184   1              Init_Device();
 185   1      
 186   1              LirTarget = 0x03ff;
 187   1              Fdelta = 0;
 188   1              if(InitFlag!=0x00)
 189   1              {
 190   2                      InitFlag=0x00;
 191   2              }
 192   1      
 193   1         while(1)
 194   1              {
 195   2      //расчет скорости ветра и угла--------------------------------------------------------------
 196   2      
 197   2                      Vspeed = (float)FREQT0/((float)TV*0.75);
 198   2                      Angle = 360. - (360.*(float)TV/(float)TA);
 199   2      
 200   2      //управление антеной------------------------------------------------------------------------
 201   2                      PCA0CPH0  = 0xFF;
 202   2                      PCA0CPH1  = 0xFF;
 203   2                      if(F==0x02)
 204   2                      {
 205   3                              LirQ();
 206   3                              delta = (LirTarget - LirData);  
 207   3                              if(delta > 0xF000)
 208   3                                      delta = delta - 0xF000;
 209   3                              if(delta >= 0x07FF)
 210   3                              {
 211   4                                      delta = 0x0FFF - delta;
 212   4                                      if(delta < 0x0155)
 213   4                                      {
 214   5                                              F = 0xC1;
 215   5                                              if(delta < 0x20 && delta > 0x0B)
 216   5                                              {
 217   6                                                      F = 0xC1;
 218   6                                              }
 219   5                                              else if(delta <= 0x0B)
 220   5                                              {
 221   6                                                      F = 0x03; 
 222   6                                              }
 223   5                                      }
 224   4                                      else
 225   4                                      {
 226   5                                              F=0xA1;
 227   5                                      }
 228   4                              }
 229   3                              else if(delta < 0x07FF)
 230   3                              {
 231   4                                      if(delta < 0x0155)
 232   4                                      {
 233   5                                              F = 0xC2;
 234   5                                              if(delta < 0x20 && delta > 0x0B)
 235   5                                              {
 236   6                                                      F = 0xC2;
 237   6                                              } 
 238   5                                              else if(delta <= 0x0B)
 239   5                                              {
 240   6                                                      F = 0x03; 
 241   6                                              }
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 5   

 242   5                                      }
 243   4                                      else
 244   4                                      {
 245   5                                              F=0xA2;
 246   5                                      }
 247   4                              }
 248   3                      }
 249   2                      if(LirData==0x0FFF)//при отключенном лир, воздействие отсутствует
 250   2                      {
 251   3                              F=0x03;
 252   3                      }
 253   2      //ШИМы на машинку--------------------------
 254   2                      if(F==0xA1)
 255   2                      {
 256   3                              PCA0CPM1  = 0x40;
 257   3                              PCA0CPH1  = 0xFF;
 258   3                              Fdelta =  delta - Fdelta;
 259   3                              Fdelta = delta;
 260   3                              PCA0CPM0  = 0x42;
 261   3                              PCA0CPH0  = 0xC0;
 262   3                      }
 263   2                      else if(F==0xA2)
 264   2                      {
 265   3                              PCA0CPM0  = 0x40;
 266   3                              PCA0CPH0  = 0xFF;
 267   3                              Fdelta =  delta - Fdelta;
 268   3                              Fdelta = delta;
 269   3                              PCA0CPM1  = 0x42;
 270   3                              PCA0CPH1  = 0xC0;
 271   3                      }
 272   2                      else if(F==0xC1)
 273   2                      {
 274   3                              PCA0CPM1  = 0x40;
 275   3                              PCA0CPH1  = 0xFF;
 276   3                              Fdelta = delta-Fdelta;
 277   3                              if(Fdelta>0x0002)
 278   3                              {
 279   4                                      PCA0CPM0  = 0x40;
 280   4                                      PCA0CPH0  = 0xFF;
 281   4                              }
 282   3                              else
 283   3                              {
 284   4                                      PCA0CPM0  = 0x42;
 285   4                                      PCA0CPH0  = 0xC0;
 286   4                              }
 287   3                              Fdelta = delta;
 288   3                      }
 289   2                      else if(F==0xC2)
 290   2                      {
 291   3                              PCA0CPM0  = 0x40;
 292   3                              PCA0CPH0  = 0xFF;
 293   3                              Fdelta =  delta - Fdelta;
 294   3                              if(Fdelta>0x0002)
 295   3                              {
 296   4                                      PCA0CPM1  = 0x40;
 297   4                                      PCA0CPH1  = 0xFF;
 298   4                              }
 299   3                              else
 300   3                              {
 301   4                                      PCA0CPM1  = 0x42;
 302   4                                      PCA0CPH1  = 0xC0;
 303   4                              }
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 6   

 304   3                              Fdelta = delta;
 305   3                      }  
 306   2                      if(F==0x03)
 307   2                      {
 308   3                    PCA0CPM0  = 0x40;
 309   3                    PCA0CPM1  = 0x40;
 310   3                         PCA0CPH0  = 0xFF;
 311   3                      PCA0CPH1  = 0xFF;
 312   3                      }
 313   2      
 314   2                      F=0x02;
 315   2      
 316   2      //Опрос GPS---------------------------------------------------------------------------
 317   2      
 318   2                      TI1=1;
 319   2                      SBUF1=0x80;
 320   2      
 321   2      //Опрос SMBus-------------------------------------------------------------------------
 322   2      
 323   2      //Работа с COM портом-----------------------------------------------------------------
 324   2      
 325   2                      //Read redy UART0-------------------------------------
 326   2                      TI0=1;
 327   2                      //Write to UART0--------------------------------------
 328   2                      Aint.i = LirData;
 329   2                      BufferInModem[0] = 0x40+1;
 330   2                      BufferInModem[1] = Aint.b[0];           
 331   2                      BufferInModem[2] = Aint.b[1];
 332   2                      Bfloat.f= Vspeed; 
 333   2                      BufferInModem[3] = Bfloat.b[0];
 334   2                      BufferInModem[4] = Bfloat.b[1];
 335   2                      BufferInModem[5] = Bfloat.b[2];
 336   2                      BufferInModem[6] = Bfloat.b[3];
 337   2                      Bfloat.f= Angle;
 338   2                      BufferInModem[7] = Bfloat.b[0];
 339   2                      BufferInModem[8] = Bfloat.b[1];
 340   2                      BufferInModem[9] = Bfloat.b[2];
 341   2                      BufferInModem[10] = Bfloat.b[3];
 342   2                      BufferInModem[11] = 0x40;
 343   2      
 344   2                      BufferInModem[12] = 0;
 345   2                      for (i = 0; i < 12; i++ )
 346   2                              BufferInModem[12] = BufferInModem[12] ^ BufferInModem[i];
 347   2                      BufferInModem[12] = 0x80 | BufferInModem[12];
 348   2      
 349   2                      if(u0timer>0xf0)
 350   2                      {
 351   3                              flTransmiter = 1;
 352   3                              u0timer = 0;
 353   3                      }
 354   2              r0 = 0;
 355   2              rk = 13;
 356   2                      SFRPAGE = 0x00;
 357   2      
 358   2                      while (flTransmiter)
 359   2                      {
 360   3                              if(r0 < rk)
 361   3                              {
 362   4                                      flTransmiter = 1;
 363   4                                      SBUF0 = BufferInModem[r0++];
 364   4                                 //TI0   = 0; 
 365   4                              //while( !TI0 );
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 7   

 366   4                              }
 367   3                              else
 368   3                              {
 369   4                                      flTransmiter = 0;
 370   4                              }
 371   3                      }
 372   2              //------------------------------------------------------------
 373   2              }
 374   1      
 375   1      //UART----------------------------
 376   1      /*      rBFM = wBFM = marBFM = 0;
 377   1              for(PWM = 1; PWM < 15; PWM++)
 378   1              {
 379   1                      Value = 37500;
 380   1                      write(PWM+112, Value);
 381   1              }
 382   1      
 383   1              while(1)
 384   1              {
 385   1              if(rBFM < wBFM+marBFM*NBFM)
 386   1              {
 387   1                              if ((BuferFromModem[rBFM] & 0xC0) == 0x40)
 388   1                              {
 389   1                                      nByte = 0;
 390   1                                      KontrSumma = 0;
 391   1                                      PWM = BuferFromModem[rBFM] & 0x3f;
 392   1                              }
 393   1                              if (nByte > 25)
 394   1                                      nByte = 25;
 395   1                              RK_code[nByte] = BuferFromModem[rBFM] & 0x7f;
 396   1                              KontrSumma = KontrSumma^RK_code[nByte++];
 397   1      
 398   1                              if ( (nByte == 5) && (KontrSumma == 0) )
 399   1                              {
 400   1                                      Value = RK_code[1]+((unsigned int)RK_code[2] << 7)+((unsigned int)RK_code[3] << 14);
 401   1                                      write(PWM+112, Value);
 402   1                              }
 403   1      
 404   1               rBFM++;
 405   1                              if(rBFM >= NBFM)
 406   1                              {
 407   1                              rBFM = 0;
 408   1                                      marBFM = 0;
 409   1                              }
 410   1            }
 411   1                                      //-----------------------------------------------------------------------------------
 412   1                      if(flNewGPS)    
 413   1                      {
 414   1                              flNewGPS = 0;
 415   1               OutModem20();
 416   1      
 417   1                              if (RegimeKren == 0 || RegimeStart == 0) //не ручное управление
 418   1                                      break; 
 419   1      start1:
 420   1                              dz = LonMar[n_];
 421   1                              dz = 0.1856*(dz - LonFly)*cos_Lat0;
 422   1                         dx = LatMar[n_];
 423   1                         dx = 0.1856*(dx-LatFly);
 424   1      
 425   1      //                      if(RegimeKren)//автономный полет
 426   1      //                      {
 427   1                              dz_pr = LonMar[n_-1];
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 8   

 428   1                                 dz_pr = 0.1856*(dz_pr-LonFly)*cos_Lat0;
 429   1                              dx_pr = LatMar[n_-1];
 430   1                              dx_pr = 0.1856*(dx_pr-LatFly);
 431   1      
 432   1                                 tmp =sqrt(dz*dz+dx*dx);              //tmp = rasst_toch_mar
 433   1                              if ((EPSILON > tmp) && (n_ != i_mar) && (n_ != 0))
 434   1                                 {
 435   1                              if ((n_ == i_mar-2) && (fabs(H_dat-100) > 50))
 436   1                                      ;
 437   1                              else
 438   1                              {
 439   1                                      n_++;
 440   1                                      flCommand = 1;
 441   1      
 442   1                                      if (RegimeV == 2)
 443   1                              Vz_zad = Vz_Mar[n_];
 444   1                                      if (RegimeVy == 2)
 445   1                              H_zad_buf = H_Mar[n_];
 446   1                                      goto start1;
 447   1                              }
 448   1      //                      }
 449   1      
 450   1                         if ( (fabs(dx-dx_pr) <= FLT_EPSILON) && (fabs(dz-dz_pr) <= FLT_EPSILON) )
 451   1                              napr_vetv_mar = 0;
 452   1                              else
 453   1                              napr_vetv_mar = atan2(dz-dz_pr, dx-dx_pr);
 454   1      
 455   1                      if ( (fabs(dx) <= FLT_EPSILON) && (fabs(dz) <= FLT_EPSILON) )
 456   1                              angle = 0;
 457   1                      else
 458   1                              angle = atan2(dz, dx);  //napr_toch_mar = atan2(dz, dx),
 459   1                      angle = angle-napr_vetv_mar;
 460   1      
 461   1                                 otkl_ot_mar = tmp*sin(angle);
 462   1                                      if (fabs(otkl_ot_mar) > 500) tmp = 200; //tmp = l_km
 463   1                                      else                         tmp = 500;
 464   1                                 dz = otkl_ot_mar*cos(napr_vetv_mar)+tmp*sin(napr_vetv_mar);  //dz = z_toch_pricel
 465   1                              dx = -otkl_ot_mar*sin(napr_vetv_mar)+tmp*cos(napr_vetv_mar);    //dx = x_toch_pricel
 466   1                              }
 467   1                              tmp = koors;
 468   1                              tmp =  -tmp/ToGrad;
 469   1                      if ( (fabs(dx) > FLT_EPSILON) && (fabs(dz) > FLT_EPSILON) )
 470   1                                      tmp =  tmp + atan2(dz, dx);
 471   1      
 472   1                         while (tmp > M_PI)
 473   1                      tmp -= D_PI;
 474   1                         while (tmp < -M_PI)
 475   1                      tmp += D_PI;
 476   1      
 477   1                         tmp = ToGrad*tmp;            
 478   1                              if(tmp > 42)
 479   1                                      tmp = 42;
 480   1                         else if(tmp < -42)
 481   1                                      tmp = -42;
 482   1                              kren_zad_buf = tmp;
 483   1                      }
 484   1            else if (liTimer_tick-liTimer_tick_GPS > 2*FREQ) //Отсутствие координат
 485   1                      {
 486   1                              flNoKoord = 1;
 487   1                              liTimer_tick_GPS = liTimer_tick;        
 488   1               OutModem20();
 489   1                      }
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 9   

 490   1      
 491   1                      //Расшифровка посылки GPS
 492   1                      if (r < w+mar*NS) 
 493   1                      {
 494   1                              if(mess[r] == '$')
 495   1                              {
 496   1                  nLetter = 0;
 497   1                              }
 498   1               else if ((nLetter == 0) && (mess[r] == 'G'))
 499   1                  nLetter++;
 500   1               else if ((nLetter == 1) && (mess[r] == 'P'))
 501   1                  nLetter++;
 502   1               else if ((nLetter == 2) && (mess[r] == 'R'))
 503   1                  nLetter++;
 504   1               else if ((nLetter == 3) && (mess[r] == 'M'))
 505   1                  nLetter++;
 506   1               else if ((nLetter == 4) && (mess[r] == 'C'))
 507   1               {
 508   1                  nLetter++;
 509   1                                      i_comma = 0;
 510   1                                      ValidGPS = 0;
 511   1               } 
 512   1                         else if(mess[r] == ',')
 513   1                              {
 514   1                                      i_comma++;
 515   1                                      i = 0;
 516   1                                      flPoint = 0;
 517   1                              }
 518   1                         else if(i_comma == 2)
 519   1                              {
 520   1                                      if(mess[r] == 'A') 
 521   1                                              ValidGPS = 1;
 522   1                                      else
 523   1                                      {
 524   1                                              ValidGPS = 0;
 525   1      //                                      flNoKoord = 1;
 526   1      //                                      liTimer_tick_GPS = liTimer_tick;
 527   1                                      }
 528   1                              }
 529   1               else if (ValidGPS)
 530   1                              {
 531   1                                      if (i_comma == 3)                //Latitude
 532   1                                      {
 533   1                                              if(mess[r] == '.')
 534   1                                              {
 535   1                                                      flPoint = 1;
 536   1                                                      i = 0;
 537   1                                              }
 538   1                                              else if (flPoint == 0)                  //Целая часть
 539   1                                              {
 540   1                                                      tmpGPS[i++] = mess[r];
 541   1                                                      if(i == 2)
 542   1                                                      {
 543   1                                         tmpGPS[i] = 0;
 544   1                                                              temp_koord = atoi(tmpGPS);
 545   1                                      temp_koord = 60UL*10000*temp_koord;
 546   1                                                      }       
 547   1                                                      else if(i == 4)
 548   1                                                      {
 549   1                                                              tmpGPS[0] = tmpGPS[1] = '0';
 550   1                                         tmpGPS[i] = 0;
 551   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 10  

 552   1                                                      }       
 553   1                                              }
 554   1                                              else                                    //Дробная часть
 555   1                                              {
 556   1                                                      tmpGPS[i++] = mess[r];
 557   1                                 tmpGPS[i] = 0;
 558   1                                              }
 559   1                                      }
 560   1                                      else if (i_comma == 4)
 561   1                                      {
 562   1                              temp_koord = temp_koord+atoi(tmpGPS);
 563   1      //-----------
 564   1      //lLatFly = 55UL*60*10000+50UL*10000+8680;
 565   1      //--------
 566   1                                              if (mess[r] == 'S')                             //знак Latitude
 567   1                                                      LatFly = 54000000UL-temp_koord;         //90UL*60*10000-koord;
 568   1                                              else              
 569   1                                                      LatFly = 54000000UL+temp_koord; //90UL*60*10000+koord;
 570   1                                      }
 571   1                                      else if (i_comma == 5)                //Longitude
 572   1                                      {
 573   1                                              if(mess[r] == '.')
 574   1                                              {
 575   1                                                      flPoint = 1;
 576   1                                                      i = 0;
 577   1                                              }
 578   1                                              else if (flPoint == 0)                  //Целая часть
 579   1                                              {
 580   1                                                      tmpGPS[i++] = mess[r];
 581   1                                                      if(i == 3)
 582   1                                                      {
 583   1                                         tmpGPS[i] = 0;
 584   1                                      temp_koord = atoi(tmpGPS);
 585   1                                      temp_koord = 60UL*10000*temp_koord;
 586   1                                                      }       
 587   1                                                      else if(i == 5)
 588   1                                                      {
 589   1                                                              tmpGPS[0] = tmpGPS[1] = tmpGPS[2] = '0';
 590   1                                         tmpGPS[i] = 0;
 591   1                                            temp_koord = temp_koord+10000UL*atoi(tmpGPS);
 592   1                                                      }       
 593   1                                              }
 594   1                                              else                                    //Дробная часть
 595   1                                              {
 596   1                                                      tmpGPS[i++] = mess[r];
 597   1                                 tmpGPS[i] = 0;
 598   1                                              }
 599   1                                      }
 600   1                                      else if (i_comma == 6)
 601   1                                      {
 602   1                              temp_koord = temp_koord+atoi(tmpGPS);
 603   1      //----------------
 604   1      //lLonFly = 49UL*60*10000+6UL*10000+3760;
 605   1      //----------------
 606   1                                              if (mess[r] == 'W')   //знак Longitude
 607   1                                                      LonFly = 108000000UL-temp_koord;                //180UL*60*10000-koord;
 608   1                                              else       
 609   1                                                      LonFly = temp_koord+108000000UL;        //180UL*60*10000;
 610   1                                      }
 611   1                                      else if (i_comma == 7)  //скорость в узлах
 612   1                                      {
 613   1                                              if(mess[r] == '.')
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 11  

 614   1                                              {
 615   1                                                      flPoint = 1;
 616   1                              Vz = 1.852*atoi(tmpGPS)/3.6;   //??? Преобразовать из узлов в м/с
 617   1      //---------
 618   1      //Vz = 20;
 619   1      //-----------
 620   1                                              }
 621   1                                              else if(flPoint == 0)
 622   1                                              {
 623   1                                                      tmpGPS[i++] = mess[r];
 624   1                              tmpGPS[i] = 0;
 625   1                                              }
 626   1                  }
 627   1                                      else if (i_comma == 8)  //курс в градусах
 628   1                                      {
 629   1                                              if(mess[r] == '.')
 630   1                                              {
 631   1                                                      flPoint = 1;
 632   1                              koors = atoi(tmpGPS);
 633   1                        if (koors < 0)
 634   1                           koors = 360+koors;
 635   1      
 636   1                                                      flNoKoord = 0;
 637   1                                                      flNewGPS = 1;
 638   1                                                      liTimer_tick_GPS = liTimer_tick;        
 639   1                                  OutModem20();
 640   1      //-----------                                              
 641   1      //koors = 30;
 642   1      //-----------
 643   1                                              }
 644   1                                              else if(flPoint == 0)
 645   1                                              {
 646   1                                                      tmpGPS[i++] = mess[r];
 647   1                              tmpGPS[i] = 0;
 648   1                                              }
 649   1                  }
 650   1                              }
 651   1                              r++;
 652   1                      if(r >= NS)
 653   1                              {
 654   1                      r = 0;
 655   1                                      mar = 0;        
 656   1                              }      
 657   1                      }
 658   1      
 659   1      
 660   1              }       
 661   1              */
 662   1      //-----------------
 663   1      }
*** WARNING C280 IN LINE 170 OF SERVO.C: 'FdKoeff': unreferenced local variable
*** WARNING C280 IN LINE 176 OF SERVO.C: 'RK_code': unreferenced local variable
*** WARNING C280 IN LINE 176 OF SERVO.C: 'PWM': unreferenced local variable
*** WARNING C280 IN LINE 177 OF SERVO.C: 'Value': unreferenced local variable
 664          
 665          //------------------------------------------------------------------------------------------
 666          //скорость ветра
 667          void INT0 (void) interrupt 0
 668          {
 669   1              TV = RTC - RTCV;
 670   1              RTCV = RTC;;
 671   1              EX0=0;
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 12  

 672   1              return;
 673   1      }
 674          
 675          //------------------------------------------------------------------------------------
 676          void TIMER_ISR0 (void) interrupt 1
 677          {
 678   1              xdata unsigned int i, delta, FdKoeff;
 679   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 680   1              SFRPAGE = TIMER01_PAGE;
 681   1              RTC++;
 682   1      //ветер-------------
 683   1              if(WSpeed!=0)
 684   1                      EX0=1;
 685   1      
 686   1              if(WAngle!=0)
 687   1                      EX1=1;
 688   1      //-------------------
 689   1              u0timer++; // COM u0
 690   1      //      u1timer++; // GPS u1
 691   1      //-------------------
 692   1              SFRPAGE = SFRPAGE_SAVE;
 693   1              return;
 694   1      }
*** WARNING C280 IN LINE 678 OF SERVO.C: 'i': unreferenced local variable
*** WARNING C280 IN LINE 678 OF SERVO.C: 'delta': unreferenced local variable
*** WARNING C280 IN LINE 678 OF SERVO.C: 'FdKoeff': unreferenced local variable
 695          
 696          
 697          
 698          //направление ветра-------------------------------------------------------------------
 699          void INT1 (void) interrupt 2
 700          {
 701   1              TA = RTC - RTCA;
 702   1              RTCA = RTC;
 703   1              EX1=0;
 704   1              return;
 705   1      }
 706          
 707          //------------------------------------------------------------------------------------
 708          void TIMER_ISR1 (void) interrupt 3
 709          {
 710   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 711   1              SFRPAGE = TIMER01_PAGE;
 712   1                      
 713   1              SFRPAGE = SFRPAGE_SAVE;
 714   1              return;
 715   1      }
 716          
 717          //-------------------------------------------------------------------
 718          void COM_UART0_isr(void) interrupt 4
 719          {
 720   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 721   1              INT Aint;
 722   1              SFRPAGE = UART0_PAGE;
 723   1      
 724   1              if (RI0)
 725   1              {
 726   2                      BuferFromModem [wBFM++] = SBUF0;  // read character
 727   2                      if(wBFM >= NBFM)
 728   2                      {
 729   3                      wBFM = 0;
 730   3                              marBFM = 1;
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 13  

 731   3                      }
 732   2                      if(BuferFromModem [wBFM-1]==0x41)
 733   2                      {
 734   3                              if(BuferFromModem [wBFM-4]==0x40)
 735   3                              {
 736   4                                      Aint.b[0] = BuferFromModem[wBFM-3];
 737   4                                      Aint.b[1] = BuferFromModem[wBFM-2];
 738   4                                      if(Aint.i<=0x0fff)
 739   4                                      {
 740   5                                              LirTarget = Aint.i;
 741   5                                      }
 742   4                              }       
 743   3                      }
 744   2                      RI0 = 0;
 745   2              }
 746   1              if (TI0)
 747   1              {
 748   2                              
 749   2      /*              if(r0 < rk)
 750   2                      {
 751   2                              flTransmiter = 1;
 752   2                              SBUF0 = BufferInModem[r0++];
 753   2                      }
 754   2                      else                                            
 755   2                      {
 756   2                              flTransmiter = 0;                       //Окончание передачи
 757   2                              
 758   2                      }*/
 759   2              
 760   2              /*      while(r0 < rk)
 761   2                      {
 762   2                              flTransmiter = 1;
 763   2                              SBUF0 = BufferInModem[r0++];
 764   2                      }
 765   2                      flTransmiter = 0;*/
 766   2              }
 767   1              SFRPAGE = SFRPAGE_SAVE;
 768   1              return;
 769   1      }
 770          void Timer2_ISR(void) interrupt 5
 771          {
 772   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 773   1              SFRPAGE = 0x00;
 774   1      
 775   1              SFRPAGE = SFRPAGE_SAVE;
 776   1              return;
 777   1      }
 778          //------------------------------------------------------------------------------------
 779          void SMBus_isr(void) interrupt 7
 780          {
 781   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 782   1              SFRPAGE = SMB0_PAGE;
 783   1      
 784   1              SFRPAGE = SFRPAGE_SAVE;
 785   1              return;
 786   1      }
 787          
 788          //------------------------------------------------------------------------------------
 789          void PCA_isr(void) interrupt 9
 790          {
 791   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 792   1              SFRPAGE = PCA0_PAGE;
C51 COMPILER V9.00   SERVO                                                                 06/06/2012 11:34:31 PAGE 14  

 793   1      
 794   1              SFRPAGE = SFRPAGE_SAVE;
 795   1              return;
 796   1      }
 797          //------------------------------------------------------------------------------------
 798          void TIMER_ISR3 (void) interrupt 14
 799          {
 800   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 801   1              SFRPAGE = TMR3_PAGE;
 802   1              TF3=0;
 803   1      
 804   1              SFRPAGE = SFRPAGE_SAVE;
 805   1              return;
 806   1      }
 807          //-------------------------------------------------------------------
 808          void GPS_UART1_isr(void) interrupt 20
 809          {
 810   1              xdata char SFRPAGE_SAVE = SFRPAGE;
 811   1              SFRPAGE = UART1_PAGE;
 812   1              if (RI1)
 813   1              {
 814   2                      RI1 = 0;
 815   2                      LED=!LED;
 816   2              }
 817   1              if (TI1)
 818   1              {
 819   2                              
 820   2              }
 821   1      
 822   1              SFRPAGE = SFRPAGE_SAVE;
 823   1              return;
 824   1      }
 825          //------------------------------------------------------------------------------------------
 826          //#endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2127    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    224      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
